{
  "api/index.html": {
    "href": "api/index.html",
    "title": "IX API Documentation | System.Dynamic.ExpandoObject",
    "keywords": "IX API Documentation"
  },
  "apictrl/index.html": {
    "href": "apictrl/index.html",
    "title": "IX API Documentation | System.Dynamic.ExpandoObject",
    "keywords": "IX API Documentation"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoBoolArray8.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoBoolArray8.html",
    "title": "Class AxoBoolArray8 | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoBoolArray8 Inheritance AxoBoolArray AxoBoolArray8 Inherited Members DataChanged ToggleDataChangedFlag() Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoBoolArray8 Properties Data Declaration Data : ARRAY [0..7] OF BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionControl.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionControl.html",
    "title": "Struct AxoDataman_AcquisitionControl | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_AcquisitionControl Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_AcquisitionControl Properties TriggerEnable Declaration TriggerEnable : BOOL Property Value Type Description Trigger Declaration Trigger : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionStatus.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionStatus.html",
    "title": "Struct AxoDataman_AcquisitionStatus | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_AcquisitionStatus Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_AcquisitionStatus Properties TriggerReady Declaration TriggerReady : BOOL Property Value Type Description TriggerAcknowledge Declaration TriggerAcknowledge : BOOL Property Value Type Description Acquiring Declaration Acquiring : BOOL Property Value Type Description MissedAcquisition Declaration MissedAcquisition : BOOL Property Value Type Description TriggerID Declaration TriggerID : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Config.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Config.html",
    "title": "Struct AxoDataman_Config | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_Config Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_Config Properties ContinuousReading Declaration ContinuousReading : BOOL Property Value Type Description InfoTime Declaration InfoTime : LTIME Property Value Type Description ErrorTime Declaration ErrorTime : LTIME Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Results.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Results.html",
    "title": "Struct AxoDataman_Results | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_Results Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_Results Properties Id Declaration Id : UINT Property Value Type Description Code Declaration Code : UINT Property Value Type Description Extended Declaration Extended : UINT Property Value Type Description Length Declaration Length : UINT Property Value Type Description Data Declaration Data : STRING[246] Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsControl.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsControl.html",
    "title": "Struct AxoDataman_ResultsControl | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_ResultsControl Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_ResultsControl Properties EnableResultBuffering Declaration EnableResultBuffering : BOOL Property Value Type Description ResultsAcknowledge Declaration ResultsAcknowledge : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsStatus.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsStatus.html",
    "title": "Struct AxoDataman_ResultsStatus | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_ResultsStatus Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_ResultsStatus Properties Decoding Declaration Decoding : BOOL Property Value Type Description DecodeComplete Declaration DecodeComplete : BOOL Property Value Type Description ResultsBufferOverrun Declaration ResultsBufferOverrun : BOOL Property Value Type Description ResultsAvailable Declaration ResultsAvailable : BOOL Property Value Type Description ErrorDetected Declaration ErrorDetected : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_SignalStates.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_SignalStates.html",
    "title": "Struct AxoDataman_SignalStates | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_SignalStates Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_SignalStates Properties TriggerEnable Declaration TriggerEnable : BOOL Property Value Type Description Trigger Declaration Trigger : BOOL Property Value Type Description EnableResultBuffering Declaration EnableResultBuffering : BOOL Property Value Type Description ResultsAcknowledge Declaration ResultsAcknowledge : BOOL Property Value Type Description TriggerReady Declaration TriggerReady : BOOL Property Value Type Description TriggerAcknowledge Declaration TriggerAcknowledge : BOOL Property Value Type Description Acquiring Declaration Acquiring : BOOL Property Value Type Description MissedAcquisition Declaration MissedAcquisition : BOOL Property Value Type Description TriggerID Declaration TriggerID : UINT Property Value Type Description Decoding Declaration Decoding : BOOL Property Value Type Description DecodeComplete Declaration DecodeComplete : BOOL Property Value Type Description ResultsBufferOverrun Declaration ResultsBufferOverrun : BOOL Property Value Type Description ResultsAvailable Declaration ResultsAvailable : BOOL Property Value Type Description ErrorDetected Declaration ErrorDetected : BOOL Property Value Type Description ResultID Declaration ResultID : UINT Property Value Type Description ResultCode Declaration ResultCode : UINT Property Value Type Description ResultExtended Declaration ResultExtended : UINT Property Value Type Description ResultLength Declaration ResultLength : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_SoftEventControl.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_SoftEventControl.html",
    "title": "Struct AxoDataman_SoftEventControl | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_SoftEventControl Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_SoftEventControl Properties TrainCode Declaration TrainCode : BOOL Property Value Type Description TrainMatchString Declaration TrainMatchString : BOOL Property Value Type Description TrainFocus Declaration TrainFocus : BOOL Property Value Type Description TrainBrightness Declaration TrainBrightness : BOOL Property Value Type Description Untrain Declaration Untrain : BOOL Property Value Type Description ExecuteDMCC Declaration ExecuteDMCC : BOOL Property Value Type Description Reserved06 Declaration Reserved06 : BOOL Property Value Type Description SetMatchString Declaration SetMatchString : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_SoftEventStatus.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_SoftEventStatus.html",
    "title": "Struct AxoDataman_SoftEventStatus | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_SoftEventStatus Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_SoftEventStatus Properties TrainCodeAcknowledge Declaration TrainCodeAcknowledge : BOOL Property Value Type Description TrainMatchStringAcknowledge Declaration TrainMatchStringAcknowledge : BOOL Property Value Type Description TrainFocusAcknowledge Declaration TrainFocusAcknowledge : BOOL Property Value Type Description TrainBrightnessAcknowledge Declaration TrainBrightnessAcknowledge : BOOL Property Value Type Description UntrainAcknowledge Declaration UntrainAcknowledge : BOOL Property Value Type Description ExecuteDMCCAcknowledge Declaration ExecuteDMCCAcknowledge : BOOL Property Value Type Description Reserved06 Declaration Reserved06 : BOOL Property Value Type Description SetMatchStringAcknowledge Declaration SetMatchStringAcknowledge : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status.html",
    "title": "Class AxoDataman_Status | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataman_Status Inheritance AxoComponent_Status AxoDataman_Status Inherited Members Action Error Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoDataman_Status Properties SignalStatus Declaration SignalStatus : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_SignalStates Property Value Type Description ResultDataSize Declaration ResultDataSize : AXOpen.Cognex.Vision.v_6_0_0_0.eAxoDataman_ResultDataSize Property Value Type Description UserDataSize Declaration UserDataSize : AXOpen.Cognex.Vision.v_6_0_0_0.eAxoDataman_UserDataSize Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_User.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_User.html",
    "title": "Struct AxoDataman_User | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoDataman_User Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoDataman_User Properties Option Declaration Option : UINT Property Value Type Description Length Declaration Length : UINT Property Value Type Description Data Declaration Data : ARRAY [0..249] OF BYTE Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman.html",
    "title": "Class AxoDataman | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataman Inheritance AxoComponent AxoObject AxoDataman Implements IAxoCodeReader IAxoComponent Inherited Members _isManuallyControllable Identity ActivateManualControl() IsManuallyControllable() CheckIfManualControlIsActivated() Open() Run() Close() Restore() ManualControl() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoDataman Properties _readTask Declaration _readTask : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDatamanRead Property Value Type Description Results Declaration Results : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Results Property Value Type Description _restoreTask Declaration _restoreTask : AXOpen.Core.AxoTask Property Value Type Description _clearResultDataTask Declaration _clearResultDataTask : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDatamanClearResultData Property Value Type Description Config Declaration Config : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Config Property Value Type Description Status Declaration Status : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status Property Value Type Description User Declaration User : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_User Property Value Type Description _AcquisitionControl Declaration _AcquisitionControl : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionControl Property Value Type Description _AcquisitionStatus Declaration _AcquisitionStatus : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionStatus Property Value Type Description _ResultsControl Declaration _ResultsControl : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsControl Property Value Type Description _ResultsStatus Declaration _ResultsStatus : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsStatus Property Value Type Description _SoftEventControl Declaration _SoftEventControl : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_SoftEventControl Property Value Type Description _SoftEventStatus Declaration _SoftEventStatus : AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_SoftEventStatus Property Value Type Description _taskDisabled Declaration _taskDisabled : BOOL Property Value Type Description Methods Restore Restores this instance . Declaration Protected AXOpen.Core.IAxoTask Restore() Returns Type Description IAxoTask ManualControl Custom logic for the manual control. Declaration Protected VOID ManualControl() Returns Type Description UpdateInputs Declaration Private BOOL UpdateInputs(in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO BYTE refResultsStatus,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData) Parameters Type Name Description REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO BYTE refResultsStatus REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData Returns Type Description BOOL UpdateOutputs Declaration Private BOOL UpdateOutputs(in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO BYTE refResultsControl,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description REF_TO BYTE refAcquisitionControl REF_TO BYTE refResultsControl REF_TO BYTE refSoftEventControl REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description BOOL IsValidReferences Declaration Private BOOL IsValidReferences(in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO BYTE refResultsControl,in plc.REF_TO BYTE refResultsStatus,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description REF_TO BYTE refAcquisitionControl REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO BYTE refResultsControl REF_TO BYTE refResultsStatus REF_TO BYTE refSoftEventControl REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description BOOL ContinuousReading Declaration Private VOID ContinuousReading(in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status refStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Results refResults,in plc.REF_TO ARRAY [*] OF BYTE refResultData) Parameters Type Name Description REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status refStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Results refResults REF_TO ARRAY [*] OF BYTE refResultData Returns Type Description Open Declaration Protected VOID Open() Returns Type Description Run Declaration Public VOID Run(in plc.AXOpen.Core.IAxoObject parent,in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO BYTE refResultsControl,in plc.REF_TO BYTE refResultsStatus,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description IAxoObject parent REF_TO BYTE refAcquisitionControl REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO BYTE refResultsControl REF_TO BYTE refResultsStatus REF_TO BYTE refSoftEventControl REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description Run Declaration Public VOID Run(in plc.AXOpen.Core.IAxoContext parent,in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO BYTE refResultsControl,in plc.REF_TO BYTE refResultsStatus,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description IAxoContext parent REF_TO BYTE refAcquisitionControl REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO BYTE refResultsControl REF_TO BYTE refResultsStatus REF_TO BYTE refSoftEventControl REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description Execute Declaration Private VOID Execute(in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO BYTE refResultsControl,in plc.REF_TO BYTE refResultsStatus,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description REF_TO BYTE refAcquisitionControl REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO BYTE refResultsControl REF_TO BYTE refResultsStatus REF_TO BYTE refSoftEventControl REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description Close Declaration Protected VOID Close() Returns Type Description ClearResultData Clears the result data. Declaration Public AXOpen.Core.IAxoTaskState ClearResultData() Returns Type Description IAxoTaskState Read Triggers the reading sequence and waits for results. Declaration Public AXOpen.Core.IAxoTaskState Read() Returns Type Description IAxoTaskState UpdateSignalStates Declaration Private VOID UpdateSignalStates() Returns Type Description Implements IAxoCodeReader IAxoComponent"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDatamanClearResultData.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDatamanClearResultData.html",
    "title": "Class AxoDatamanClearResultData | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDatamanClearResultData Inheritance AxoTask AxoObject AxoDatamanClearResultData Implements IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoDatamanClearResultData Properties _progress Declaration _progress : INT Property Value Type Description _infoTimer Declaration _infoTimer : UNDEFINED Property Value Type Description _errorTimer Declaration _errorTimer : UNDEFINED Property Value Type Description _infoTime Declaration _infoTime : LTIME Property Value Type Description _errorTime Declaration _errorTime : LTIME Property Value Type Description _Status Declaration _Status : REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status Property Value Type Description Methods Run Declaration Public VOID Run(in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionControl refAcquisitionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionStatus refAcquisitionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsControl refResultsControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsStatus refResultsStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Config refConfig,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status refStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Results refResults,in plc.REF_TO ARRAY [*] OF BYTE refResultData) Parameters Type Name Description REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionControl refAcquisitionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionStatus refAcquisitionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsControl refResultsControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsStatus refResultsStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Config refConfig REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status refStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Results refResults REF_TO ARRAY [*] OF BYTE refResultData Returns Type Description CallTimers Declaration Private VOID CallTimers(in plc.BOOL signal) Parameters Type Name Description BOOL signal Returns Type Description OnRestore Declaration Protected VOID OnRestore() Returns Type Description OnAbort Declaration Protected VOID OnAbort() Returns Type Description OnDone Declaration Protected VOID OnDone() Returns Type Description OnError Declaration Protected VOID OnError() Returns Type Description OnStart Declaration Protected VOID OnStart() Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDatamanRead.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoDatamanRead.html",
    "title": "Class AxoDatamanRead | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDatamanRead Inheritance AxoTask AxoObject AxoDatamanRead Implements IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoDatamanRead Properties _progress Declaration _progress : INT Property Value Type Description _infoTimer Declaration _infoTimer : UNDEFINED Property Value Type Description _errorTimer Declaration _errorTimer : UNDEFINED Property Value Type Description _infoTime Declaration _infoTime : LTIME Property Value Type Description _errorTime Declaration _errorTime : LTIME Property Value Type Description _Status Declaration _Status : REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status Property Value Type Description Methods Run Declaration Public VOID Run(in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionControl refAcquisitionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionStatus refAcquisitionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsControl refResultsControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsStatus refResultsStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Config refConfig,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status refStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Results refResults,in plc.REF_TO ARRAY [*] OF BYTE refResultData) Parameters Type Name Description REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionControl refAcquisitionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_AcquisitionStatus refAcquisitionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsControl refResultsControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_ResultsStatus refResultsStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Config refConfig REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Status refStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoDataman_Results refResults REF_TO ARRAY [*] OF BYTE refResultData Returns Type Description CallTimers Declaration Private VOID CallTimers(in plc.BOOL signal) Parameters Type Name Description BOOL signal Returns Type Description OnRestore Declaration Protected VOID OnRestore() Returns Type Description OnAbort Declaration Protected VOID OnAbort() Returns Type Description OnDone Declaration Protected VOID OnDone() Returns Type Description OnError Declaration Protected VOID OnError() Returns Type Description OnStart Declaration Protected VOID OnStart() Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl.html",
    "title": "Struct AxoInsight_AcquisitionControl | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_AcquisitionControl Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_AcquisitionControl Properties TriggerEnable Declaration TriggerEnable : BOOL Property Value Type Description Trigger Declaration Trigger : BOOL Property Value Type Description ClearExposureComplete Declaration ClearExposureComplete : BOOL Property Value Type Description SetOffline Declaration SetOffline : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus.html",
    "title": "Struct AxoInsight_AcquisitionStatus | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_AcquisitionStatus Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_AcquisitionStatus Properties TriggerReady Declaration TriggerReady : BOOL Property Value Type Description TriggerAcknowledge Declaration TriggerAcknowledge : BOOL Property Value Type Description ExposureComplete Declaration ExposureComplete : BOOL Property Value Type Description MissedAcquisition Declaration MissedAcquisition : BOOL Property Value Type Description OfflineReason0 Declaration OfflineReason0 : BOOL Property Value Type Description OfflineReason1 Declaration OfflineReason1 : BOOL Property Value Type Description OfflineReason2 Declaration OfflineReason2 : BOOL Property Value Type Description Online Declaration Online : BOOL Property Value Type Description AcquisitionID Declaration AcquisitionID : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl.html",
    "title": "Struct AxoInsight_CommandControl | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_CommandControl Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_CommandControl Properties Command Declaration Command : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandStatus.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandStatus.html",
    "title": "Struct AxoInsight_CommandStatus | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_CommandStatus Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_CommandStatus Properties CurrentJobID Declaration CurrentJobID : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config.html",
    "title": "Struct AxoInsight_Config | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_Config Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_Config Properties InfoTime Declaration InfoTime : LTIME Property Value Type Description ErrorTime Declaration ErrorTime : LTIME Property Value Type Description MaxJobNumber Declaration MaxJobNumber : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl.html",
    "title": "Struct AxoInsight_InspectionControl | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_InspectionControl Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_InspectionControl Properties EnableResultsBuffering Declaration EnableResultsBuffering : BOOL Property Value Type Description AcknowledgeInspectionResults Declaration AcknowledgeInspectionResults : BOOL Property Value Type Description ExtendedUserDataSet Declaration ExtendedUserDataSet : BOOL Property Value Type Description ExecuteCommand Declaration ExecuteCommand : BOOL Property Value Type Description ClearError Declaration ClearError : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus.html",
    "title": "Struct AxoInsight_InspectionStatus | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_InspectionStatus Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_InspectionStatus Properties SystemBusy Declaration SystemBusy : BOOL Property Value Type Description InspectionCompleted Declaration InspectionCompleted : BOOL Property Value Type Description ResultsBufferOverrun Declaration ResultsBufferOverrun : BOOL Property Value Type Description ResultsValid Declaration ResultsValid : BOOL Property Value Type Description CommandExecuting Declaration CommandExecuting : BOOL Property Value Type Description CommandComplete Declaration CommandComplete : BOOL Property Value Type Description CommandFailed Declaration CommandFailed : BOOL Property Value Type Description ExtendedUserDataSetAcknowledge Declaration ExtendedUserDataSetAcknowledge : BOOL Property Value Type Description OverallJobPassFail Declaration OverallJobPassFail : BOOL Property Value Type Description TestRunReady Declaration TestRunReady : BOOL Property Value Type Description Error Declaration Error : BOOL Property Value Type Description ErrorCode Declaration ErrorCode : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_ResultData.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_ResultData.html",
    "title": "Class AxoInsight_ResultData | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInsight_ResultData Inheritance AxoByteArray AxoInsight_ResultData Inherited Members DataChanged ToggleDataChangedFlag() Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoInsight_ResultData Properties Data Declaration Data : ARRAY [0..250] OF BYTE Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Results.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Results.html",
    "title": "Struct AxoInsight_Results | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_Results Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_Results Properties InspectionID Declaration InspectionID : UINT Property Value Type Description ResultCode Declaration ResultCode : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventControl.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventControl.html",
    "title": "Struct AxoInsight_SoftEventControl | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_SoftEventControl Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_SoftEventControl Properties TriggerSoftEvent Declaration TriggerSoftEvent : AXOpen.Cognex.Vision.v_6_0_0_0.AxoBoolArray8 Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventStatus.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventStatus.html",
    "title": "Struct AxoInsight_SoftEventStatus | System.Dynamic.ExpandoObject",
    "keywords": "Struct AxoInsight_SoftEventStatus Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax STRUCT AxoInsight_SoftEventStatus Properties TriggerSoftEventAcknowledge Declaration TriggerSoftEventAcknowledge : AXOpen.Cognex.Vision.v_6_0_0_0.AxoBoolArray8 Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status.html",
    "title": "Class AxoInsight_Status | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInsight_Status Inheritance AxoComponent_Status AxoInsight_Status Inherited Members Action Error Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoInsight_Status Properties CurrentJobName Declaration CurrentJobName : STRING Property Value Type Description CurrentJobNumber Declaration CurrentJobNumber : UINT Property Value Type Description ResultDataSize Declaration ResultDataSize : AXOpen.Cognex.Vision.v_6_0_0_0.eAxoInsight_ResultDataSize Property Value Type Description UserDataSize Declaration UserDataSize : AXOpen.Cognex.Vision.v_6_0_0_0.eAxoInsight_UserDataSize Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_UserData.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_UserData.html",
    "title": "Class AxoInsight_UserData | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInsight_UserData Inheritance AxoByteArray AxoInsight_UserData Inherited Members DataChanged ToggleDataChangedFlag() Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoInsight_UserData Properties Data Declaration Data : ARRAY [0..254] OF BYTE Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight.html",
    "title": "Class AxoInsight | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInsight Inheritance AxoComponent AxoObject AxoInsight Implements IAxoVisionSensor IAxoComponent Inherited Members _isManuallyControllable Identity ActivateManualControl() IsManuallyControllable() CheckIfManualControlIsActivated() Open() Run() Close() Restore() ManualControl() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoInsight Properties TriggerTask Declaration TriggerTask : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightTrigger Property Value Type Description InspectionResults Declaration InspectionResults : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_ResultData Property Value Type Description RestoreTask Declaration RestoreTask : AXOpen.Core.AxoTask Property Value Type Description ClearInspectionResultsTask Declaration ClearInspectionResultsTask : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightClearInspectionResults Property Value Type Description RequiredJobName Declaration RequiredJobName : STRING Property Value Type Description ChangeJobByNameTask Declaration ChangeJobByNameTask : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightChangeJobByName Property Value Type Description RequiredJobNumber Declaration RequiredJobNumber : UINT Property Value Type Description ChangeJobByNumberTask Declaration ChangeJobByNumberTask : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightChangeJobByNumber Property Value Type Description RequiredSoftEventNumber Declaration RequiredSoftEventNumber : UINT Property Value Type Description SoftEventTask Declaration SoftEventTask : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightSoftEvent Property Value Type Description Config Declaration Config : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config Property Value Type Description Status Declaration Status : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status Property Value Type Description Results Declaration Results : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Results Property Value Type Description AcquisitionControl Declaration AcquisitionControl : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl Property Value Type Description AcquisitionStatus Declaration AcquisitionStatus : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus Property Value Type Description InspectionControl Declaration InspectionControl : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl Property Value Type Description InspectionStatus Declaration InspectionStatus : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus Property Value Type Description CommandControl Declaration CommandControl : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl Property Value Type Description CommandStatus Declaration CommandStatus : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandStatus Property Value Type Description SoftEventControl Declaration SoftEventControl : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventControl Property Value Type Description SoftEventStatus Declaration SoftEventStatus : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventStatus Property Value Type Description User Declaration User : AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_UserData Property Value Type Description _taskDisabled Declaration _taskDisabled : BOOL Property Value Type Description Methods Restore Restores this instance . Declaration Protected AXOpen.Core.IAxoTask Restore() Returns Type Description IAxoTask ManualControl Custom logic for the manual control. Declaration Protected VOID ManualControl() Returns Type Description UpdateInputs Declaration Private BOOL UpdateInputs(in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO DWORD refInspectionStatus,in plc.REF_TO WORD refCommandStatus,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData) Parameters Type Name Description REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO DWORD refInspectionStatus REF_TO WORD refCommandStatus REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData Returns Type Description BOOL UpdateOutputs Declaration Private BOOL UpdateOutputs(in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO BYTE refInspectionControl,in plc.REF_TO WORD refCommandControl,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description REF_TO BYTE refAcquisitionControl REF_TO BYTE refInspectionControl REF_TO WORD refCommandControl REF_TO BYTE refSoftEventControl REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description BOOL IsValidReferences Declaration Private BOOL IsValidReferences(in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO BYTE refInspectionControl,in plc.REF_TO DWORD refInspectionStatus,in plc.REF_TO WORD refCommandControl,in plc.REF_TO WORD refCommandStatus,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description REF_TO BYTE refAcquisitionControl REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO BYTE refInspectionControl REF_TO DWORD refInspectionStatus REF_TO WORD refCommandControl REF_TO WORD refCommandStatus REF_TO BYTE refSoftEventControl REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description BOOL Open Declaration Protected VOID Open() Returns Type Description Run Declaration Public VOID Run(in plc.AXOpen.Core.IAxoObject parent,in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO BYTE refInspectionControl,in plc.REF_TO DWORD refInspectionStatus,in plc.REF_TO WORD refCommandControl,in plc.REF_TO WORD refCommandStatus,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description IAxoObject parent REF_TO BYTE refAcquisitionControl REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO BYTE refInspectionControl REF_TO DWORD refInspectionStatus REF_TO WORD refCommandControl REF_TO WORD refCommandStatus REF_TO BYTE refSoftEventControl REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description Run Declaration Public VOID Run(in plc.AXOpen.Core.IAxoContext parent,in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO BYTE refInspectionControl,in plc.REF_TO DWORD refInspectionStatus,in plc.REF_TO WORD refCommandControl,in plc.REF_TO WORD refCommandStatus,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description IAxoContext parent REF_TO BYTE refAcquisitionControl REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO BYTE refInspectionControl REF_TO DWORD refInspectionStatus REF_TO WORD refCommandControl REF_TO WORD refCommandStatus REF_TO BYTE refSoftEventControl REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description Execute Declaration Private VOID Execute(in plc.REF_TO BYTE refAcquisitionControl,in plc.REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus,in plc.REF_TO BYTE refInspectionControl,in plc.REF_TO DWORD refInspectionStatus,in plc.REF_TO WORD refCommandControl,in plc.REF_TO WORD refCommandStatus,in plc.REF_TO BYTE refSoftEventControl,in plc.REF_TO BYTE refSoftEventStatus,in plc.REF_TO ARRAY [*] OF BYTE refResultData,in plc.REF_TO ARRAY [*] OF BYTE refUserData) Parameters Type Name Description REF_TO BYTE refAcquisitionControl REF_TO ARRAY [0..2] OF BYTE refAcquisitionStatus REF_TO BYTE refInspectionControl REF_TO DWORD refInspectionStatus REF_TO WORD refCommandControl REF_TO WORD refCommandStatus REF_TO BYTE refSoftEventControl REF_TO BYTE refSoftEventStatus REF_TO ARRAY [*] OF BYTE refResultData REF_TO ARRAY [*] OF BYTE refUserData Returns Type Description Close Declaration Protected VOID Close() Returns Type Description ClearInspectionResults Clears the inspection results. Declaration Public AXOpen.Core.IAxoTaskState ClearInspectionResults() Returns Type Description IAxoTaskState Trigger Triggers the reading sequence and waits for results. Declaration Public AXOpen.Core.IAxoTaskState Trigger() Returns Type Description IAxoTaskState ChangeJob Changes the sensor job using job number. Declaration Public AXOpen.Core.IAxoTaskState ChangeJob(in plc.UINT Job) Parameters Type Name Description UINT Job Returns Type Description IAxoTaskState ChangeJob Changes the sensor job using job name. Declaration Public AXOpen.Core.IAxoTaskState ChangeJob(in plc.STRING Job) Parameters Type Name Description STRING Job Returns Type Description IAxoTaskState SoftEvent Triggers the soft event. Declaration Public AXOpen.Core.IAxoTaskState SoftEvent(in plc.UINT EventNumber) Parameters Type Name Description UINT EventNumber Returns Type Description IAxoTaskState Implements IAxoVisionSensor IAxoComponent"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightClearInspectionResults.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightClearInspectionResults.html",
    "title": "Class AxoInsightClearInspectionResults | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInsightClearInspectionResults Inheritance AxoTask AxoObject AxoInsightClearInspectionResults Implements IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoInsightClearInspectionResults Properties _progress Declaration _progress : INT Property Value Type Description _infoTimer Declaration _infoTimer : UNDEFINED Property Value Type Description _errorTimer Declaration _errorTimer : UNDEFINED Property Value Type Description _infoTime Declaration _infoTime : LTIME Property Value Type Description _errorTime Declaration _errorTime : LTIME Property Value Type Description _Status Declaration _Status : REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status Property Value Type Description Methods Run Declaration Public VOID Run(in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Results refResults,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_ResultData refInspectionResults) Parameters Type Name Description REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Results refResults REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_ResultData refInspectionResults Returns Type Description CallTimers Declaration Private VOID CallTimers(in plc.BOOL signal) Parameters Type Name Description BOOL signal Returns Type Description OnRestore Declaration Protected VOID OnRestore() Returns Type Description OnAbort Declaration Protected VOID OnAbort() Returns Type Description OnDone Declaration Protected VOID OnDone() Returns Type Description OnError Declaration Protected VOID OnError() Returns Type Description OnStart Declaration Protected VOID OnStart() Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightChangeJobByName.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightChangeJobByName.html",
    "title": "Class AxoInsightChangeJobByName | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInsightChangeJobByName Inheritance AxoTask AxoObject AxoInsightChangeJobByName Implements IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoInsightChangeJobByName Properties _progress Declaration _progress : INT Property Value Type Description _infoTimer Declaration _infoTimer : UNDEFINED Property Value Type Description _errorTimer Declaration _errorTimer : UNDEFINED Property Value Type Description _infoTime Declaration _infoTime : LTIME Property Value Type Description _errorTime Declaration _errorTime : LTIME Property Value Type Description _Status Declaration _Status : REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status Property Value Type Description _jobName Declaration _jobName : STRING Property Value Type Description Methods Run Declaration Public VOID Run(in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl refCommandControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_UserData refUser) Parameters Type Name Description REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl refCommandControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_UserData refUser Returns Type Description AppendSuffix Declaration Internal STRING AppendSuffix(in plc.STRING jobName) Parameters Type Name Description STRING jobName Returns Type Description STRING SetUserDataAsString Declaration Internal BOOL SetUserDataAsString(in plc.STRING inValue,in plc.UINT inPosition,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_UserData refUser,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus) Parameters Type Name Description STRING inValue UINT inPosition REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_UserData refUser REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus Returns Type Description BOOL CallTimers Declaration Internal VOID CallTimers(in plc.BOOL signal) Parameters Type Name Description BOOL signal Returns Type Description OnRestore Declaration Protected VOID OnRestore() Returns Type Description OnAbort Declaration Protected VOID OnAbort() Returns Type Description OnDone Declaration Protected VOID OnDone() Returns Type Description OnError Declaration Protected VOID OnError() Returns Type Description OnStart Declaration Protected VOID OnStart() Returns Type Description InvokeWithParameters Declaration Internal AXOpen.Core.IAxoTaskState InvokeWithParameters(in plc.STRING inJobName) Parameters Type Name Description STRING inJobName Returns Type Description IAxoTaskState Manual Declaration Public VOID Manual(in plc.STRING RequiredJobName) Parameters Type Name Description STRING RequiredJobName Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightChangeJobByNumber.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightChangeJobByNumber.html",
    "title": "Class AxoInsightChangeJobByNumber | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInsightChangeJobByNumber Inheritance AxoTask AxoObject AxoInsightChangeJobByNumber Implements IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoInsightChangeJobByNumber Properties _progress Declaration _progress : INT Property Value Type Description _infoTimer Declaration _infoTimer : UNDEFINED Property Value Type Description _errorTimer Declaration _errorTimer : UNDEFINED Property Value Type Description _infoTime Declaration _infoTime : LTIME Property Value Type Description _errorTime Declaration _errorTime : LTIME Property Value Type Description _Status Declaration _Status : REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status Property Value Type Description _jobNumber Declaration _jobNumber : UINT Property Value Type Description Methods Run Declaration Public VOID Run(in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl refCommandControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus) Parameters Type Name Description REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl refCommandControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus Returns Type Description CallTimers Declaration Private VOID CallTimers(in plc.BOOL signal) Parameters Type Name Description BOOL signal Returns Type Description OnRestore Declaration Protected VOID OnRestore() Returns Type Description OnAbort Declaration Protected VOID OnAbort() Returns Type Description OnDone Declaration Protected VOID OnDone() Returns Type Description OnError Declaration Protected VOID OnError() Returns Type Description OnStart Declaration Protected VOID OnStart() Returns Type Description InvokeWithParameters Declaration Internal AXOpen.Core.IAxoTaskState InvokeWithParameters(in plc.UINT inJobNumber) Parameters Type Name Description UINT inJobNumber Returns Type Description IAxoTaskState Manual Declaration Public VOID Manual(in plc.UINT RequiredJobNumber) Parameters Type Name Description UINT RequiredJobNumber Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightSoftEvent.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightSoftEvent.html",
    "title": "Class AxoInsightSoftEvent | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInsightSoftEvent Inheritance AxoTask AxoObject AxoInsightSoftEvent Implements IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoInsightSoftEvent Properties _progress Declaration _progress : INT Property Value Type Description _infoTimer Declaration _infoTimer : UNDEFINED Property Value Type Description _errorTimer Declaration _errorTimer : UNDEFINED Property Value Type Description _infoTime Declaration _infoTime : LTIME Property Value Type Description _errorTime Declaration _errorTime : LTIME Property Value Type Description _Status Declaration _Status : REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status Property Value Type Description _softEventNumber Declaration _softEventNumber : UINT Property Value Type Description Methods Run Declaration Public VOID Run(in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl refCommandControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventControl refTriggerSoftEvent,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventStatus refTriggerSoftEventAcknowledge) Parameters Type Name Description REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl refCommandControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventControl refTriggerSoftEvent REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_SoftEventStatus refTriggerSoftEventAcknowledge Returns Type Description CallTimers Declaration Private VOID CallTimers(in plc.BOOL signal) Parameters Type Name Description BOOL signal Returns Type Description OnRestore Declaration Protected VOID OnRestore() Returns Type Description OnAbort Declaration Protected VOID OnAbort() Returns Type Description OnDone Declaration Protected VOID OnDone() Returns Type Description OnError Declaration Protected VOID OnError() Returns Type Description OnStart Declaration Protected VOID OnStart() Returns Type Description InvokeWithParameters Declaration Internal AXOpen.Core.IAxoTaskState InvokeWithParameters(in plc.UINT inSoftEventNumber) Parameters Type Name Description UINT inSoftEventNumber Returns Type Description IAxoTaskState Manual Declaration Public VOID Manual(in plc.UINT RequiredSoftEventNumber) Parameters Type Name Description UINT RequiredSoftEventNumber Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightTrigger.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsightTrigger.html",
    "title": "Class AxoInsightTrigger | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInsightTrigger Inheritance AxoTask AxoObject AxoInsightTrigger Implements IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax CLASS AxoInsightTrigger Properties _progress Declaration _progress : INT Property Value Type Description _infoTimer Declaration _infoTimer : UNDEFINED Property Value Type Description _errorTimer Declaration _errorTimer : UNDEFINED Property Value Type Description _infoTime Declaration _infoTime : LTIME Property Value Type Description _errorTime Declaration _errorTime : LTIME Property Value Type Description _Status Declaration _Status : REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status Property Value Type Description Methods Run Declaration Public VOID Run(in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl refCommandControl,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Results refResults,in plc.REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_ResultData refInspectionResults,in plc.REF_TO ARRAY [*] OF BYTE refResultData) Parameters Type Name Description REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionControl refAcquisitionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_AcquisitionStatus refAcquisitionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionControl refInspectionControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_InspectionStatus refInspectionStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_CommandControl refCommandControl REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Config refConfig REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Status refStatus REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_Results refResults REF_TO AXOpen.Cognex.Vision.v_6_0_0_0.AxoInsight_ResultData refInspectionResults REF_TO ARRAY [*] OF BYTE refResultData Returns Type Description CallTimers Declaration Private VOID CallTimers(in plc.BOOL signal) Parameters Type Name Description BOOL signal Returns Type Description OnRestore Declaration Protected VOID OnRestore() Returns Type Description OnAbort Declaration Protected VOID OnAbort() Returns Type Description OnDone Declaration Protected VOID OnDone() Returns Type Description OnError Declaration Protected VOID OnError() Returns Type Description OnStart Declaration Protected VOID OnStart() Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.eAxoDataman_ResultDataSize.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.eAxoDataman_ResultDataSize.html",
    "title": "Enum eAxoDataman_ResultDataSize | System.Dynamic.ExpandoObject",
    "keywords": "Enum eAxoDataman_ResultDataSize Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax eAxoDataman_ResultDataSize : INT Fields Name Description RESULT_DATA_SIZE_INVALID := 0 RESULT_DATA_16B := 16 RESULT_DATA_32B := 32 RESULT_DATA_64B := 64 RESULT_DATA_128B := 128 RESULT_DATA_246B := 246"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.eAxoDataman_UserDataSize.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.eAxoDataman_UserDataSize.html",
    "title": "Enum eAxoDataman_UserDataSize | System.Dynamic.ExpandoObject",
    "keywords": "Enum eAxoDataman_UserDataSize Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax eAxoDataman_UserDataSize : INT Fields Name Description USER_DATA_SIZE_INVALID := 0 USER_DATA_16B := 16 USER_DATA_32B := 32 USER_DATA_64B := 64 USER_DATA_128B := 128 USER_DATA_250B := 250"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.eAxoInsight_ResultDataSize.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.eAxoInsight_ResultDataSize.html",
    "title": "Enum eAxoInsight_ResultDataSize | System.Dynamic.ExpandoObject",
    "keywords": "Enum eAxoInsight_ResultDataSize Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax eAxoInsight_ResultDataSize : INT Fields Name Description RESULT_DATA_SIZE_INVALID := 0 RESULT_DATA_16B := 16 RESULT_DATA_32B := 32 RESULT_DATA_64B := 64 RESULT_DATA_128B := 128 RESULT_DATA_250B := 250"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.eAxoInsight_UserDataSize.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.eAxoInsight_UserDataSize.html",
    "title": "Enum eAxoInsight_UserDataSize | System.Dynamic.ExpandoObject",
    "keywords": "Enum eAxoInsight_UserDataSize Namespace: plc.AXOpen.Cognex.Vision.v_6_0_0_0 Assembly: .dll Syntax eAxoInsight_UserDataSize : INT Fields Name Description USER_DATA_SIZE_INVALID := 0 USER_DATA_16B := 16 USER_DATA_32B := 32 USER_DATA_64B := 64 USER_DATA_128B := 128 USER_DATA_254B := 254"
  },
  "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.html": {
    "href": "apictrl/plc.AXOpen.Cognex.Vision.v_6_0_0_0.html",
    "title": "Namespace plc.AXOpen.Cognex.Vision.v_6_0_0_0 | System.Dynamic.ExpandoObject",
    "keywords": "Namespace plc.AXOpen.Cognex.Vision.v_6_0_0_0 Classes AxoDataman AxoInsight AxoDatamanClearResultData AxoDatamanRead AxoDataman_Status AxoInsightChangeJobByName AxoInsightChangeJobByNumber AxoInsightClearInspectionResults AxoInsightSoftEvent AxoInsightTrigger AxoBoolArray8 AxoInsight_ResultData AxoInsight_Status AxoInsight_UserData Structs AxoDataman_AcquisitionControl AxoDataman_AcquisitionStatus AxoDataman_Config AxoDataman_Results AxoDataman_ResultsControl AxoDataman_ResultsStatus AxoDataman_SignalStates AxoDataman_SoftEventControl AxoDataman_SoftEventStatus AxoDataman_User AxoInsight_AcquisitionControl AxoInsight_AcquisitionStatus AxoInsight_CommandControl AxoInsight_CommandStatus AxoInsight_Config AxoInsight_InspectionControl AxoInsight_InspectionStatus AxoInsight_Results AxoInsight_SoftEventControl AxoInsight_SoftEventStatus"
  },
  "apictrl/plc.AXOpen.Components.Abstractions.AxoComponent_Status.html": {
    "href": "apictrl/plc.AXOpen.Components.Abstractions.AxoComponent_Status.html",
    "title": "Class AxoComponent_Status | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoComponent_Status Inheritance AxoComponent_Status Namespace: plc.AXOpen.Components.Abstractions Assembly: .dll Syntax CLASS AxoComponent_Status Properties Action Declaration Action : AXOpen.Core.AxoTextList Property Value Type Description Error Declaration Error : AXOpen.Core.AxoTextList Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Components.Abstractions.html": {
    "href": "apictrl/plc.AXOpen.Components.Abstractions.html",
    "title": "Namespace plc.AXOpen.Components.Abstractions | System.Dynamic.ExpandoObject",
    "keywords": "Namespace plc.AXOpen.Components.Abstractions Classes AxoComponent_Status Interfaces IAxoCodeReader IAxoVisionSensor"
  },
  "apictrl/plc.AXOpen.Components.Abstractions.IAxoCodeReader.html": {
    "href": "apictrl/plc.AXOpen.Components.Abstractions.IAxoCodeReader.html",
    "title": "Interface IAxoCodeReader | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoCodeReader Namespace: plc.AXOpen.Components.Abstractions Assembly: .dll Syntax INTERFACE IAxoCodeReader Methods ClearResultData Declaration Public AXOpen.Core.IAxoTaskState ClearResultData() Returns Type Description IAxoTaskState Read Declaration Public AXOpen.Core.IAxoTaskState Read() Returns Type Description IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Components.Abstractions.IAxoVisionSensor.html": {
    "href": "apictrl/plc.AXOpen.Components.Abstractions.IAxoVisionSensor.html",
    "title": "Interface IAxoVisionSensor | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoVisionSensor Namespace: plc.AXOpen.Components.Abstractions Assembly: .dll Syntax INTERFACE IAxoVisionSensor Methods ClearInspectionResults Declaration Public AXOpen.Core.IAxoTaskState ClearInspectionResults() Returns Type Description IAxoTaskState Trigger Declaration Public AXOpen.Core.IAxoTaskState Trigger() Returns Type Description IAxoTaskState ChangeJob Declaration Public AXOpen.Core.IAxoTaskState ChangeJob(in plc.UINT Job) Parameters Type Name Description UINT Job Returns Type Description IAxoTaskState ChangeJob Declaration Public AXOpen.Core.IAxoTaskState ChangeJob(in plc.STRING Job) Parameters Type Name Description STRING Job Returns Type Description IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Core._NULL_CONTEXT.html": {
    "href": "apictrl/plc.AXOpen.Core._NULL_CONTEXT.html",
    "title": "Class _NULL_CONTEXT | System.Dynamic.ExpandoObject",
    "keywords": "Class _NULL_CONTEXT Provides an empty context for uninitialized objects. Inheritance _NULL_CONTEXT Implements IAxoContext Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS _NULL_CONTEXT Properties NULL_RTC Declaration NULL_RTC : AXOpen.Core._NULL_RTC Property Value Type Description NULL_LOGGER Declaration NULL_LOGGER : AXOpen.Core._NULL_LOGGER Property Value Type Description Methods CreateIdentity Declaration Public ULINT CreateIdentity() Returns Type Description ULINT OpenCycleCount Declaration Public ULINT OpenCycleCount() Returns Type Description ULINT GetRtc Declaration Public AXOpen.Rtc.IAxoRtc GetRtc() Returns Type Description IAxoRtc InjectRtc Declaration Public VOID InjectRtc(in plc.AXOpen.Rtc.IAxoRtc Rtc) Parameters Type Name Description IAxoRtc Rtc Returns Type Description GetLogger Declaration Public AXOpen.Logging.IAxoLogger GetLogger() Returns Type Description IAxoLogger InjectLogger Declaration Public VOID InjectLogger(in plc.AXOpen.Logging.IAxoLogger _logger) Parameters Type Name Description IAxoLogger _logger Returns Type Description Implements IAxoContext"
  },
  "apictrl/plc.AXOpen.Core._NULL_LOGGER.html": {
    "href": "apictrl/plc.AXOpen.Core._NULL_LOGGER.html",
    "title": "Class _NULL_LOGGER | System.Dynamic.ExpandoObject",
    "keywords": "Class _NULL_LOGGER Provides an empty logger object for uninitialized context logger. Inheritance _NULL_LOGGER Implements IAxoLogger Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS _NULL_LOGGER Methods Log Declaration Public VOID Log(in plc.STRING[80] _message,in plc.AXOpen.Logging.eLogLevel _level,in plc.AXOpen.Core.IAxoObject _sender) Parameters Type Name Description STRING[80] _message eLogLevel _level IAxoObject _sender Returns Type Description Log Declaration Public VOID Log(in plc.STRING[80] _message,in plc.AXOpen.Logging.eLogLevel _level) Parameters Type Name Description STRING[80] _message eLogLevel _level Returns Type Description SetMinimumLevel Declaration Public AXOpen.Logging.IAxoLoggerConfig SetMinimumLevel(in plc.AXOpen.Logging.eLogLevel _level) Parameters Type Name Description eLogLevel _level Returns Type Description IAxoLoggerConfig Implements IAxoLogger"
  },
  "apictrl/plc.AXOpen.Core._NULL_OBJECT.html": {
    "href": "apictrl/plc.AXOpen.Core._NULL_OBJECT.html",
    "title": "Class _NULL_OBJECT | System.Dynamic.ExpandoObject",
    "keywords": "Class _NULL_OBJECT Provides an empty object for uninitialized objects. Inheritance _NULL_OBJECT Implements IAxoObject Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS _NULL_OBJECT Properties NULL_CONTEXT Declaration NULL_CONTEXT : AXOpen.Core._NULL_CONTEXT Property Value Type Description Methods GetIdentity Declaration Public ULINT GetIdentity() Returns Type Description ULINT GetContext Declaration Public AXOpen.Core.IAxoContext GetContext() Returns Type Description IAxoContext Implements IAxoObject"
  },
  "apictrl/plc.AXOpen.Core._NULL_RTC.html": {
    "href": "apictrl/plc.AXOpen.Core._NULL_RTC.html",
    "title": "Class _NULL_RTC | System.Dynamic.ExpandoObject",
    "keywords": "Class _NULL_RTC Provides an empty RTC object for uninitialized RTC. Inheritance _NULL_RTC Implements IAxoRtc Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS _NULL_RTC Properties _null_time Declaration _null_time : LDATE_AND_TIME Property Value Type Description Methods NowUTC Declaration Public LDATE_AND_TIME NowUTC() Returns Type Description LDATE_AND_TIME Implements IAxoRtc"
  },
  "apictrl/plc.AXOpen.Core.AxoAlertDialog.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoAlertDialog.html",
    "title": "Class AxoAlertDialog | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoAlertDialog Inheritance AxoRemoteTask AxoTask AxoObject AxoAlertDialog Implements IAxoAlertDialogFormat IAxoTask IAxoTaskState Inherited Members DoneSignature IsInitialized HasRemoteException IsBeingCalledCounter TaskNotInitialized TaskHasRemoteException Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity Execute() GetStartSignature() SetDoneSignature() GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoAlertDialog Properties _dialogType Declaration _dialogType : AXOpen.Core.eDialogType Property Value Type Description _title Declaration _title : STRING Property Value Type Description _message Declaration _message : STRING Property Value Type Description _timeToBurn Declaration _timeToBurn : UINT Property Value Type Description _lastCall Declaration _lastCall : ULINT Property Value Type Description Methods Show Declaration Public AXOpen.Core.IAxoAlertDialogFormat Show(in plc.AXOpen.Core.IAxoObject _parent) Parameters Type Name Description IAxoObject _parent Returns Type Description IAxoAlertDialogFormat WithTitle Declaration Public AXOpen.Core.IAxoAlertDialogFormat WithTitle(in plc.STRING inTitle) Parameters Type Name Description STRING inTitle Returns Type Description IAxoAlertDialogFormat WithMessage Declaration Public AXOpen.Core.IAxoAlertDialogFormat WithMessage(in plc.STRING inMessage) Parameters Type Name Description STRING inMessage Returns Type Description IAxoAlertDialogFormat WithTimeToBurn Declaration Public AXOpen.Core.IAxoAlertDialogFormat WithTimeToBurn(in plc.UINT inSeconds) Parameters Type Name Description UINT inSeconds Returns Type Description IAxoAlertDialogFormat WithType Declaration Public AXOpen.Core.IAxoAlertDialogFormat WithType(in plc.AXOpen.Core.eDialogType inDialogType) Parameters Type Name Description eDialogType inDialogType Returns Type Description IAxoAlertDialogFormat IsShown Declaration Public BOOL IsShown() Returns Type Description BOOL Implements IAxoAlertDialogFormat IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Core.AxoBoolArray.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoBoolArray.html",
    "title": "Class AxoBoolArray | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoBoolArray Inheritance AxoBoolArray Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoBoolArray Properties DataChanged Declaration DataChanged : BOOL Property Value Type Description Methods ToggleDataChangedFlag Declaration Public VOID ToggleDataChangedFlag() Returns Type Description"
  },
  "apictrl/plc.AXOpen.Core.AxoByteArray.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoByteArray.html",
    "title": "Class AxoByteArray | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoByteArray Inheritance AxoByteArray Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoByteArray Properties DataChanged Declaration DataChanged : BOOL Property Value Type Description Methods ToggleDataChangedFlag Declaration Public VOID ToggleDataChangedFlag() Returns Type Description"
  },
  "apictrl/plc.AXOpen.Core.AxoComponent.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoComponent.html",
    "title": "Class AxoComponent | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoComponent Inheritance AxoObject AxoComponent Implements IAxoComponent Inherited Members Identity GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoComponent Properties _manualControlContextCycle Declaration _manualControlContextCycle : ULINT Property Value Type Description _isManuallyControllable Declaration _isManuallyControllable : BOOL Property Value Type Description Methods ActivateManualControl Executes the logic for manual-maintenance control. Declaration Public VOID ActivateManualControl() Returns Type Description IsManuallyControllable Gets whether the AxoComponent is manually controllable.To make the AxoComponent manually controllable, it is necessary to call the ActivateManualMode() method cyclically. Declaration Public BOOL IsManuallyControllable() Returns Type Description BOOL CheckIfManualControlIsActivated Declaration Private VOID CheckIfManualControlIsActivated() Returns Type Description Open Declaration Protected VOID Open() Returns Type Description Run Declaration Public VOID Run() Returns Type Description Close Declaration Protected VOID Close() Returns Type Description Restore Restores this instance. This method must be implemented in derived class. Declaration Protected AXOpen.Core.IAxoTask Restore() Returns Type Description IAxoTask ManualControl Custom logic for manual control of the AxoComponent.This method must be implemented in derived class. Declaration Protected VOID ManualControl() Returns Type Description Implements IAxoComponent"
  },
  "apictrl/plc.AXOpen.Core.AxoContext.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoContext.html",
    "title": "Class AxoContext | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoContext Provides base for contextualized entry of AXOpen application.This class is abstract and must be inherited. Inheritance AxoContext Implements IAxoContext Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoContext Properties _openCounter Declaration _openCounter : ULINT Property Value Type Description _closeCounter Declaration _closeCounter : ULINT Property Value Type Description _identityCounter Declaration _identityCounter : ULINT Property Value Type Description NULL_RTC Declaration NULL_RTC : AXOpen.Core._NULL_RTC Property Value Type Description _rtc Declaration _rtc : AXOpen.Rtc.IAxoRtc Property Value Type Description NULL_LOGGER Declaration NULL_LOGGER : AXOpen.Core._NULL_LOGGER Property Value Type Description _contextLogger Declaration _contextLogger : AXOpen.Logging.IAxoLogger Property Value Type Description Methods Open Declaration Private ULINT Open() Returns Type Description ULINT Close Declaration Private ULINT Close() Returns Type Description ULINT Run Runs the cycle of this context. This method must be called cyclically in a PLC task. Declaration Public VOID Run() Returns Type Description OpenCycleCount Gets the value of current context cycle counter. Declaration Public ULINT OpenCycleCount() Returns Type Description ULINT ClosedCycleCount Declaration Public ULINT ClosedCycleCount() Returns Type Description ULINT CreateIdentity Declaration Public ULINT CreateIdentity() Returns Type Description ULINT PeekIdentity Declaration Public ULINT PeekIdentity() Returns Type Description ULINT GetRtc Declaration Public AXOpen.Rtc.IAxoRtc GetRtc() Returns Type Description IAxoRtc InjectRtc Declaration Public VOID InjectRtc(in plc.AXOpen.Rtc.IAxoRtc Rtc) Parameters Type Name Description IAxoRtc Rtc Returns Type Description GetLogger Declaration Public AXOpen.Logging.IAxoLogger GetLogger() Returns Type Description IAxoLogger InjectLogger Declaration Public VOID InjectLogger(in plc.AXOpen.Logging.IAxoLogger _logger) Parameters Type Name Description IAxoLogger _logger Returns Type Description Main The entry point for the context. The call tree of the context start here and all the logic of given contextmust be placed here.This method must be overridden in derived class. Declaration Protected VOID Main() Returns Type Description Implements IAxoContext"
  },
  "apictrl/plc.AXOpen.Core.AxoCoordinatorStates.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoCoordinatorStates.html",
    "title": "Enum AxoCoordinatorStates | System.Dynamic.ExpandoObject",
    "keywords": "Enum AxoCoordinatorStates Namespace: plc.AXOpen.Core Assembly: .dll Syntax AxoCoordinatorStates : INT Fields Name Description Idle := 0 Configuring := 1 Running := 2"
  },
  "apictrl/plc.AXOpen.Core.AxoDialog.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoDialog.html",
    "title": "Class AxoDialog | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDialog AxoDialog class, which represents structure of base dialog. Inheritance AxoDialogBase AxoRemoteTask AxoTask AxoObject AxoDialog Implements IAxoDialogAnswer IAxoTask IAxoTaskState Inherited Members DoneSignature IsInitialized HasRemoteException IsBeingCalledCounter TaskNotInitialized TaskHasRemoteException Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity Execute() GetStartSignature() SetDoneSignature() GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoDialog Properties _text Declaration _text : STRING Property Value Type Description _caption Declaration _caption : STRING Property Value Type Description _hasOK Declaration _hasOK : BOOL Property Value Type Description _hasYes Declaration _hasYes : BOOL Property Value Type Description _hasNo Declaration _hasNo : BOOL Property Value Type Description _hasCancel Declaration _hasCancel : BOOL Property Value Type Description _answer Declaration _answer : AXOpen.Core.eDialogAnswer Property Value Type Description _dialogType Declaration _dialogType : AXOpen.Core.eDialogType Property Value Type Description _externalCloseReq Declaration _externalCloseReq : BOOL Property Value Type Description _closeSignal Declaration _closeSignal : BOOL Property Value Type Description _risingEdge Declaration _risingEdge : UNDEFINED Property Value Type Description _lastCall Declaration _lastCall : ULINT Property Value Type Description Methods Show Show method, which serves for initializing remote task and invoking dialog from PLC. Declaration Public AXOpen.Core.IAxoDialogFormat Show(in plc.AXOpen.Core.IAxoObject _parent) Parameters Type Name Description IAxoObject _parent Returns Type Description IAxoDialogFormat ShowWithExternalClose Show method with a possibility to close dialog externally by setting a signal.WARNING: This is experimental implementation of possibility to close dialogs externally. More testing need to be done. Declaration Private AXOpen.Core.IAxoDialogFormat ShowWithExternalClose(in plc.AXOpen.Core.IAxoObject _parent,in plc.BOOL inOkAnswerSignal,in plc.BOOL inYesAnswerSignal,in plc.BOOL inNoAnswerSignal,in plc.BOOL inCancelAnswerSignal) Parameters Type Name Description IAxoObject _parent BOOL inOkAnswerSignal BOOL inYesAnswerSignal BOOL inNoAnswerSignal BOOL inCancelAnswerSignal Returns Type Description IAxoDialogFormat WithCaption Declaration Public AXOpen.Core.IAxoDialogAnswer WithCaption(in plc.STRING inCaption) Parameters Type Name Description STRING inCaption Returns Type Description IAxoDialogAnswer WithOk Declaration Public AXOpen.Core.IAxoDialogAnswer WithOk() Returns Type Description IAxoDialogAnswer WithText Declaration Public AXOpen.Core.IAxoDialogAnswer WithText(in plc.STRING inText) Parameters Type Name Description STRING inText Returns Type Description IAxoDialogAnswer WithType Declaration Public AXOpen.Core.IAxoDialogAnswer WithType(in plc.AXOpen.Core.eDialogType inDialogType) Parameters Type Name Description eDialogType inDialogType Returns Type Description IAxoDialogAnswer WithYesNo Declaration Public AXOpen.Core.IAxoDialogAnswer WithYesNo() Returns Type Description IAxoDialogAnswer WithYesNoCancel Declaration Public AXOpen.Core.IAxoDialogAnswer WithYesNoCancel() Returns Type Description IAxoDialogAnswer Answer Declaration Public AXOpen.Core.eDialogAnswer Answer() Returns Type Description eDialogAnswer Implements IAxoDialogAnswer IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Core.AxoDialogBase.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoDialogBase.html",
    "title": "Class AxoDialogBase | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDialogBase Inheritance AxoRemoteTask AxoTask AxoObject AxoDialogBase Implements IAxoTask IAxoTaskState Inherited Members DoneSignature IsInitialized HasRemoteException IsBeingCalledCounter TaskNotInitialized TaskHasRemoteException Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity Execute() GetStartSignature() SetDoneSignature() GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoDialogBase Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Core.AxoMomentaryTask.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoMomentaryTask.html",
    "title": "Class AxoMomentaryTask | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoMomentaryTask Provides basic momentary on function.To get the actual state of the toggle task, '''IsSwitchedOn()''', '''IsSwitchedOff()''' AND '''GetState()''' methods are available. Inheritance AxoObject AxoMomentaryTask Implements IAxoMomentaryTask Inherited Members Identity GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoMomentaryTask Properties State Declaration State : BOOL Property Value Type Description RemoteSwitchOn Remote request to set the state of this task to '''TRUE'''. Declaration RemoteSwitchOn : BOOL Property Value Type Description IsDisabled Gets or sets whether this task is disabled for any manipulations. Declaration IsDisabled : BOOL Property Value Type Description _openCycleCount Declaration _openCycleCount : ULINT Property Value Type Description Methods GetState Gets the actual state of this task. Declaration Public BOOL GetState() Returns Type Description BOOL IsRunCalledInThisPlcCycle Declaration Private BOOL IsRunCalledInThisPlcCycle() Returns Type Description BOOL WasRunCalledInPreviousPlcCycle Declaration Private BOOL WasRunCalledInPreviousPlcCycle() Returns Type Description BOOL Run This method needs to be called cyclically. Declaration Public BOOL Run() Returns Type Description BOOL SetIsDisabled Sets the value of the IsDisabled variable Declaration Public VOID SetIsDisabled(in plc.BOOL Disabled) Parameters Type Name Description BOOL Disabled Returns Type Description GetIsDisabled Returns the value of the IsDisabled variable Declaration Public BOOL GetIsDisabled() Returns Type Description BOOL IsSwitchedOn Returns TRUE if task is switched on Declaration Public BOOL IsSwitchedOn() Returns Type Description BOOL IsSwitchedOff Returns TRUE if task is switched off Declaration Public BOOL IsSwitchedOff() Returns Type Description BOOL SwitchOff Declaration Private VOID SwitchOff() Returns Type Description SwitchOn Declaration Private VOID SwitchOn() Returns Type Description OnSwitchedOn Executes ones when momentary task changes its state from '''FALSE''' to '''TRUE'''. Declaration Protected VOID OnSwitchedOn() Returns Type Description OnSwitchedOff Executes ones when momentary task changes its state from '''TRUE''' to '''FALSE'''. Declaration Protected VOID OnSwitchedOff() Returns Type Description OnStateChanged Executes ones when momentary task changes its state. Declaration Protected VOID OnStateChanged() Returns Type Description SwitchedOn Executes while the task is in On state. Declaration Protected VOID SwitchedOn() Returns Type Description SwitchedOff Executes while the task is in Off state. Declaration Protected VOID SwitchedOff() Returns Type Description Implements IAxoMomentaryTask"
  },
  "apictrl/plc.AXOpen.Core.AxoObject.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoObject.html",
    "title": "Class AxoObject | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoObject Provides base class for all classes of AXOpen. Inheritance AxoObject Implements IAxoObject Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoObject Properties Identity Declaration Identity : ULINT Property Value Type Description _parent Declaration _parent : AXOpen.Core.IAxoObject Property Value Type Description _context Declaration _context : AXOpen.Core.IAxoContext Property Value Type Description NULL_CONTEXT Declaration NULL_CONTEXT : AXOpen.Core._NULL_CONTEXT Property Value Type Description NULL_OBJECT Declaration NULL_OBJECT : AXOpen.Core._NULL_OBJECT Property Value Type Description Methods GetIdentity Gets unique identity of this object in given context. Declaration Public ULINT GetIdentity() Returns Type Description ULINT GetContext Gets context in which this object was initialized. Declaration Public AXOpen.Core.IAxoContext GetContext() Returns Type Description IAxoContext GetParent Gets parent in which this object was initialized. Declaration Public AXOpen.Core.IAxoObject GetParent() Returns Type Description IAxoObject Initialize Initializes this object associating it given parent.This method should be called only once upon the program start.Any subsequent call are ignored. Declaration Public VOID Initialize(in plc.AXOpen.Core.IAxoObject parent) Parameters Type Name Description IAxoObject parent Returns Type Description Initialize Initializes this object associating it given context.This method should be called only once upon the program start.Any subsequent call are ignored. Declaration Public VOID Initialize(in plc.AXOpen.Core.IAxoContext context) Parameters Type Name Description IAxoContext context Returns Type Description Implements IAxoObject"
  },
  "apictrl/plc.AXOpen.Core.AxoRemoteTask.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoRemoteTask.html",
    "title": "Class AxoRemoteTask | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoRemoteTask Provides a mechanism to exectute a logic from the PLC in an .NET environment. > [!IMPORTANT]> The deferred execution in .NET envornment is not hard-real time nor deterministic. Inheritance AxoTask AxoObject AxoRemoteTask Implements IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoRemoteTask Properties DoneSignature Remote system's done signature.When StartSignature and DoneSignature equal the task is considered executed on the remote system. Declaration DoneSignature : ULINT Property Value Type Description IsInitialized Indicates whether this instance's remote procedure is initialized. Declaration IsInitialized : BOOL Property Value Type Description Remarks When the remote task is not initialized, but the execution is invoked, task enters error state. HasRemoteException Declaration HasRemoteException : BOOL Property Value Type Description IsBeingCalledCounter Declaration IsBeingCalledCounter : INT Property Value Type Description TaskNotInitialized Declaration TaskNotInitialized : AXOpen.Messaging.Static.AxoMessenger Property Value Type Description TaskHasRemoteException Declaration TaskHasRemoteException : AXOpen.Messaging.Static.AxoMessenger Property Value Type Description Methods Execute Declaration Public BOOL Execute() Returns Type Description BOOL GetStartSignature Declaration Internal ULINT GetStartSignature() Returns Type Description ULINT SetDoneSignature Declaration Internal VOID SetDoneSignature() Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Core.AxoSequencer.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoSequencer.html",
    "title": "Class AxoSequencer | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoSequencer Inheritance AxoTask AxoObject AxoSequencer Implements IAxoSequencer IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoSequencer Properties SteppingMode Declaration SteppingMode : AXOpen.Core.eAxoSteppingMode Property Value Type Description SequenceMode Declaration SequenceMode : AXOpen.Core.eAxoSequenceMode Property Value Type Description CurrentOrder Declaration CurrentOrder : ULINT Property Value Type Description StepForwardCommand Declaration StepForwardCommand : AXOpen.Core.AxoTask Property Value Type Description StepIn Declaration StepIn : AXOpen.Core.AxoTask Property Value Type Description StepBackwardCommand Declaration StepBackwardCommand : AXOpen.Core.AxoTask Property Value Type Description CurrentStep Declaration CurrentStep : AXOpen.Core.AxoStep Property Value Type Description _configurationFlowOrder Declaration _configurationFlowOrder : ULINT Property Value Type Description _numberOfConfiguredSteps Declaration _numberOfConfiguredSteps : ULINT Property Value Type Description _coordinatorState Declaration _coordinatorState : AXOpen.Core.AxoCoordinatorStates Property Value Type Description _step Declaration _step : AXOpen.Core.IAxoStep Property Value Type Description _openCycleCounter Declaration _openCycleCounter : ULINT Property Value Type Description _closeCycleCounter Declaration _closeCycleCounter : ULINT Property Value Type Description _refCurrentStep Declaration _refCurrentStep : REF_TO AXOpen.Core.AxoStep Property Value Type Description Methods Open Opens sequencers operations.This method must be called prior to any other calls of this instance ofsequencer. Declaration Public BOOL Open() Returns Type Description BOOL Execute Declaration Internal BOOL Execute(in plc.AXOpen.Core.IAxoStep step,in plc.BOOL Enable) Parameters Type Name Description IAxoStep step BOOL Enable Returns Type Description BOOL MoveNext Moves the execution to the next step. Declaration Public VOID MoveNext() Returns Type Description RequestStep Terminates the currently executed step and initiates the RequestedStep to be executed Declaration Public VOID RequestStep(in plc.AXOpen.Core.IAxoStep RequestedStep) Parameters Type Name Description IAxoStep RequestedStep Returns Type Description CompleteSequence Completes (finishes) the execution of this sequencer and set the coordination state to Idle.If the SequenceMode of the sequencer is set to RunOnce, terminates also execution of the sequencer itself. Declaration Public VOID CompleteSequence() Returns Type Description OnBeforeSequenceStart Executes once when the sequence starts. Declaration Protected VOID OnBeforeSequenceStart() Returns Type Description OnCompleteSequence Executes once when the sequence is completed. Declaration Protected VOID OnCompleteSequence() Returns Type Description GetCoordinatorState Gets the state of the coordinator Declaration Public AXOpen.Core.AxoCoordinatorStates GetCoordinatorState() Returns Type Description AxoCoordinatorStates DetermineOrder Declaration Protected ULINT DetermineOrder(in plc.AXOpen.Core.IAxoStep step) Parameters Type Name Description IAxoStep step Returns Type Description ULINT GetNumberOfConfiguredSteps Gets the number of the configured steps in the sequence. Declaration Public ULINT GetNumberOfConfiguredSteps() Returns Type Description ULINT InvalidContext Declaration Protected BOOL InvalidContext() Returns Type Description BOOL InvalidContext Declaration Protected BOOL InvalidContext(in plc.AXOpen.Core.IAxoStep step) Parameters Type Name Description IAxoStep step Returns Type Description BOOL DisableAllSteppingComands Declaration Protected VOID DisableAllSteppingComands() Returns Type Description AbortCurrentStep Declaration Protected VOID AbortCurrentStep() Returns Type Description OnRestore Declaration Protected VOID OnRestore() Returns Type Description AndThen Declaration Public VOID AndThen(in plc.AXOpen.Core.IAxoTask tsk) Parameters Type Name Description IAxoTask tsk Returns Type Description Close Declaration Protected VOID Close() Returns Type Description Implements IAxoSequencer IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Core.AxoSequencerContainer.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoSequencerContainer.html",
    "title": "Class AxoSequencerContainer | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoSequencerContainer Inheritance AxoSequencer AxoTask AxoObject AxoSequencerContainer Implements IAxoSequencer IAxoTask IAxoTaskState Inherited Members SteppingMode SequenceMode CurrentOrder StepForwardCommand StepIn StepBackwardCommand CurrentStep Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity Open() Execute(IAxoStep,BOOL) MoveNext() RequestStep(IAxoStep) CompleteSequence() OnBeforeSequenceStart() OnCompleteSequence() GetCoordinatorState() DetermineOrder(IAxoStep) GetNumberOfConfiguredSteps() InvalidContext() InvalidContext(IAxoStep) DisableAllSteppingComands() AbortCurrentStep() OnRestore() AndThen(IAxoTask) Close() GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoSequencerContainer Methods Run Declaration Public VOID Run(in plc.AXOpen.Core.IAxoContext context) Parameters Type Name Description IAxoContext context Returns Type Description Run Declaration Public VOID Run(in plc.AXOpen.Core.IAxoObject object) Parameters Type Name Description IAxoObject object Returns Type Description Main Declaration Protected VOID Main() Returns Type Description Implements IAxoSequencer IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Core.AxoStep.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoStep.html",
    "title": "Class AxoStep | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoStep Inheritance AxoTask AxoObject AxoStep Implements IAxoStep IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoStep Properties Order Declaration Order : ULINT Property Value Type Description StepDescription Declaration StepDescription : STRING[120] Property Value Type Description IsActive Declaration IsActive : BOOL Property Value Type Description IsEnabled Declaration IsEnabled : BOOL Property Value Type Description _openCycleCount Declaration _openCycleCount : ULINT Property Value Type Description _isCalledJustOnceInThisPlcCycle Declaration _isCalledJustOnceInThisPlcCycle : BOOL Property Value Type Description _multipleStepCallInThisPlcCycle Declaration _multipleStepCallInThisPlcCycle : BOOL Property Value Type Description _noStepCallInPreviousPlcCycle Declaration _noStepCallInPreviousPlcCycle : BOOL Property Value Type Description Methods GetStepOrder Returns the order of the execution. Declaration Public ULINT GetStepOrder() Returns Type Description ULINT SetStepOrder Sets the order of the execution, if conditions are met. Declaration Public VOID SetStepOrder(in plc.AXOpen.Core.IAxoCoordinator coord,in plc.ULINT StepOrder) Parameters Type Name Description IAxoCoordinator coord ULINT StepOrder Returns Type Description IsCalledJustOnceInThisPlcCycle Returns TRUE if the execution of the step is called only once in this PLC cycle. Declaration Public BOOL IsCalledJustOnceInThisPlcCycle() Returns Type Description BOOL Execute Returns TRUE if instance of THIS step is curently executing Declaration Public BOOL Execute(in plc.AXOpen.Core.IAxoCoordinator coord) Parameters Type Name Description IAxoCoordinator coord Returns Type Description BOOL Execute Returns TRUE if instance of THIS step is curently executing and the step is enabled Declaration Public BOOL Execute(in plc.AXOpen.Core.IAxoCoordinator coord,in plc.BOOL Enable) Parameters Type Name Description IAxoCoordinator coord BOOL Enable Returns Type Description BOOL Execute Returns TRUE if instance of THIS step is curently executing and the step is enabledand sets the description of the step Declaration Public BOOL Execute(in plc.AXOpen.Core.IAxoCoordinator coord,in plc.BOOL Enable,in plc.STRING[120] Description) Parameters Type Name Description IAxoCoordinator coord BOOL Enable STRING[120] Description Returns Type Description BOOL Execute Returns TRUE if instance of THIS step is curently executingand sets the description of the step Declaration Public BOOL Execute(in plc.AXOpen.Core.IAxoCoordinator coord,in plc.STRING[120] Description) Parameters Type Name Description IAxoCoordinator coord STRING[120] Description Returns Type Description BOOL CountCallsOfTheExecuteMethod Declaration Protected VOID CountCallsOfTheExecuteMethod() Returns Type Description ExecuteInternal Declaration Protected BOOL ExecuteInternal(in plc.AXOpen.Core.IAxoCoordinator coord,in plc.BOOL Enable) Parameters Type Name Description IAxoCoordinator coord BOOL Enable Returns Type Description BOOL SetIsActive Sets the value of the IsActive variable Declaration Public VOID SetIsActive(in plc.BOOL Active) Parameters Type Name Description BOOL Active Returns Type Description GetIsActive Returns the value of the IsActive variable Declaration Public BOOL GetIsActive() Returns Type Description BOOL SetIsEnabled Sets the value of the IsEnabled variable Declaration Public VOID SetIsEnabled(in plc.BOOL Enabled) Parameters Type Name Description BOOL Enabled Returns Type Description GetIsEnabled Returns the value of the IsEnabled variable Declaration Public BOOL GetIsEnabled() Returns Type Description BOOL Implements IAxoStep IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Core.AxoTask.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoTask.html",
    "title": "Class AxoTask | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoTask Inheritance AxoObject AxoTask Implements IAxoTask IAxoTaskState Inherited Members Identity GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoTask Properties Status Gets the state of this task. Declaration Status : AXOpen.Core.eAxoTaskState Property Value Type Description IsDisabled Gets or sets whether this task is disabled for execution. Declaration IsDisabled : BOOL Property Value Type Description RemoteInvoke Remote requests for invoke of this task.When 'TRUE' this task will be invoked. Declaration RemoteInvoke : BOOL Property Value Type Description RemoteRestore Remote requests for restore of this task.When 'TRUE' this task will be restored. Declaration RemoteRestore : BOOL Property Value Type Description RemoteAbort Remote requests for abort of this task.When 'TRUE' this task will be aborted. Declaration RemoteAbort : BOOL Property Value Type Description RemoteResume Remote requests for resume of this task.When 'TRUE' this task will be resumed. Declaration RemoteResume : BOOL Property Value Type Description StartSignature Contains contex cycle number when this task started. Declaration StartSignature : ULINT Property Value Type Description Duration Gets elapsed time of last task execution. Declaration Duration : LTIME Property Value Type Description StartTimeStamp Gets date and time when the task started. Declaration StartTimeStamp : LDATE_AND_TIME Property Value Type Description ErrorDetails Contains details about the error. Declaration ErrorDetails : STRING[254] Property Value Type Description _openCycleCountInvoke Declaration _openCycleCountInvoke : ULINT Property Value Type Description _openCycleCountExecute Declaration _openCycleCountExecute : ULINT Property Value Type Description _taskTimer Declaration _taskTimer : UNDEFINED Property Value Type Description Methods GetState Gets the actual state of this task. Declaration Public AXOpen.Core.eAxoTaskState GetState() Returns Type Description eAxoTaskState GetErrorDetails Declaration Public STRING[254] GetErrorDetails() Returns Type Description STRING[254] IsReady Gets true when the task is ready. Declaration Public BOOL IsReady() Returns Type Description BOOL IsDone Gets true when the task is done. Declaration Public BOOL IsDone() Returns Type Description BOOL IsBusy Gets true when the task is busy/executing. Declaration Public BOOL IsBusy() Returns Type Description BOOL IsAborted Gets true when the task is aborted. Declaration Public BOOL IsAborted() Returns Type Description BOOL HasError Gets true when the task has error. Declaration Public BOOL HasError() Returns Type Description BOOL IsNewInvokeCall Declaration Private BOOL IsNewInvokeCall() Returns Type Description BOOL IsInvokeCalledInThisPlcCycle Declaration Private BOOL IsInvokeCalledInThisPlcCycle() Returns Type Description BOOL WasInvokeCalledInPreviousPlcCycle Declaration Private BOOL WasInvokeCalledInPreviousPlcCycle() Returns Type Description BOOL IsNewExecuteCall Declaration Private BOOL IsNewExecuteCall() Returns Type Description BOOL IsExecuteCalledInThisPlcCycle Declaration Private BOOL IsExecuteCalledInThisPlcCycle() Returns Type Description BOOL WasExecuteCalledInPreviousPlcCycle Declaration Private BOOL WasExecuteCalledInPreviousPlcCycle() Returns Type Description BOOL UpdateState Declaration Private VOID UpdateState() Returns Type Description Invoke Invokes this task. Declaration Public AXOpen.Core.IAxoTaskState Invoke() Returns Type Description IAxoTaskState Restore Restores this task. Declaration Public AXOpen.Core.IAxoTaskState Restore() Returns Type Description IAxoTaskState DoneWhen Makes this task to transition in Done statewhen Condition argument is TRUE. Declaration Public VOID DoneWhen(in plc.BOOL Condition) Parameters Type Name Description BOOL Condition Returns Type Description Execute Returns TRUE if the task is Busy, otherwise false.This method needs to be called cyclically. Declaration Public BOOL Execute() Returns Type Description BOOL LogTask Declaration Private VOID LogTask(in plc.STRING[80] _message,in plc.AXOpen.Logging.eLogLevel _level,in plc.AXOpen.Core.IAxoObject _sender) Parameters Type Name Description STRING[80] _message eLogLevel _level IAxoObject _sender Returns Type Description ThrowWhen Makes this task enter into Error state, when HasErrorState argument is TRUEtask in error state stops its execution. Declaration Public VOID ThrowWhen(in plc.BOOL HasErrorState) Parameters Type Name Description BOOL HasErrorState Returns Type Description ThrowWhen Makes this task enter into Error state, when HasErrorState argument is TRUEtask in error state stops its execution. Declaration Public VOID ThrowWhen(in plc.BOOL HasErrorState,in plc.STRING[254] ErrorDescription) Parameters Type Name Description BOOL HasErrorState STRING[254] ErrorDescription Returns Type Description SetIsDisabled Sets the value of the IsDisabled variable Declaration Public VOID SetIsDisabled(in plc.BOOL Disabled) Parameters Type Name Description BOOL Disabled Returns Type Description GetIsDisabled Returns the value of the IsDisabled variable Declaration Public BOOL GetIsDisabled() Returns Type Description BOOL Abort Aborts the execution of the task if running and sets its state to aborted. Declaration Public VOID Abort() Returns Type Description Resume Resume the execution of the task if aborted and sets its state to busy. Declaration Public VOID Resume() Returns Type Description OnAbort Executes once when the task is aborted. Declaration Protected VOID OnAbort() Returns Type Description OnResume Executes once when the task is resumed. Declaration Protected VOID OnResume() Returns Type Description OnDone Executes once when the task reaches the Done state. Declaration Protected VOID OnDone() Returns Type Description OnError Executes once when the task reaches the Error state. Declaration Protected VOID OnError() Returns Type Description OnRestore Executes once when the task is restored. Declaration Protected VOID OnRestore() Returns Type Description OnStart Executes once when the task starts (at the moment of transition from the Kicking state into the Busy state). Declaration Protected VOID OnStart() Returns Type Description WhileError Executes repeatedly while the task is in Error state (and Execute() method is called). Declaration Protected VOID WhileError() Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Core.AxoTextList.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoTextList.html",
    "title": "Class AxoTextList | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoTextList Inheritance AxoTextList Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoTextList Properties Id Declaration Id : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Core.AxoToggleTask.html": {
    "href": "apictrl/plc.AXOpen.Core.AxoToggleTask.html",
    "title": "Class AxoToggleTask | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoToggleTask Provides basic toggling between two states. The states are triggered by calling the '''Toggle()''' method.To get the actual state of the toggle task, '''IsSwitchedOn()''', '''IsSwitchedOff()''' AND '''GetState()''' methods are available. Inheritance AxoObject AxoToggleTask Implements IAxoToggleTask Inherited Members Identity GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Core Assembly: .dll Syntax CLASS AxoToggleTask Properties State Declaration State : BOOL Property Value Type Description RemoteToggle Remote request to toggle the state of this task. Declaration RemoteToggle : BOOL Property Value Type Description IsDisabled Gets or sets whether this task is disabled for any manipulations. Declaration IsDisabled : BOOL Property Value Type Description _openCycleCount Declaration _openCycleCount : ULINT Property Value Type Description Methods GetState Gets the actual state of this task. Declaration Public BOOL GetState() Returns Type Description BOOL IsRunCalledInThisPlcCycle Declaration Private BOOL IsRunCalledInThisPlcCycle() Returns Type Description BOOL WasRunCalledInPreviousPlcCycle Declaration Private BOOL WasRunCalledInPreviousPlcCycle() Returns Type Description BOOL Run This method needs to be called cyclically. Declaration Public BOOL Run() Returns Type Description BOOL SetIsDisabled Sets the value of the IsDisabled variable Declaration Public VOID SetIsDisabled(in plc.BOOL Disabled) Parameters Type Name Description BOOL Disabled Returns Type Description GetIsDisabled Returns the value of the IsDisabled variable Declaration Public BOOL GetIsDisabled() Returns Type Description BOOL IsSwitchedOn Returns TRUE if task is switched on Declaration Public BOOL IsSwitchedOn() Returns Type Description BOOL IsSwitchedOff Returns TRUE if task is switched off Declaration Public BOOL IsSwitchedOff() Returns Type Description BOOL Toggle Use to toggle the state of the '''AxoToggleTask'''. Declaration Public BOOL Toggle() Returns Type Description BOOL SwitchOff Use to set the state of the '''AxoToggleTask''' to the value '''FALSE'''. Declaration Public BOOL SwitchOff() Returns Type Description BOOL SwitchOn Declaration Public BOOL SwitchOn() Returns Type Description BOOL OnSwitchedOn Executes ones when toggle task changes its state from '''FALSE''' to '''TRUE'''. Declaration Protected VOID OnSwitchedOn() Returns Type Description OnSwitchedOff Executes ones when toggle task changes its state from '''TRUE''' to '''FALSE'''. Declaration Protected VOID OnSwitchedOff() Returns Type Description OnStateChanged Executes ones when toggle task changes its state. Declaration Protected VOID OnStateChanged() Returns Type Description SwitchedOn Executes while the task is in On state. Declaration Protected VOID SwitchedOn() Returns Type Description SwitchedOff Executes while the task is in Off state. Declaration Protected VOID SwitchedOff() Returns Type Description Implements IAxoToggleTask"
  },
  "apictrl/plc.AXOpen.Core.eAxoSequenceMode.html": {
    "href": "apictrl/plc.AXOpen.Core.eAxoSequenceMode.html",
    "title": "Enum eAxoSequenceMode | System.Dynamic.ExpandoObject",
    "keywords": "Enum eAxoSequenceMode Namespace: plc.AXOpen.Core Assembly: .dll Syntax eAxoSequenceMode : INT Fields Name Description None := 0 RunOnce := 1 Cyclic := 2"
  },
  "apictrl/plc.AXOpen.Core.eAxoSteppingMode.html": {
    "href": "apictrl/plc.AXOpen.Core.eAxoSteppingMode.html",
    "title": "Enum eAxoSteppingMode | System.Dynamic.ExpandoObject",
    "keywords": "Enum eAxoSteppingMode Namespace: plc.AXOpen.Core Assembly: .dll Syntax eAxoSteppingMode : INT Fields Name Description None := 0 StepByStep := 1 Continous := 2"
  },
  "apictrl/plc.AXOpen.Core.eAxoTaskState.html": {
    "href": "apictrl/plc.AXOpen.Core.eAxoTaskState.html",
    "title": "Enum eAxoTaskState | System.Dynamic.ExpandoObject",
    "keywords": "Enum eAxoTaskState Namespace: plc.AXOpen.Core Assembly: .dll Syntax eAxoTaskState : INT Fields Name Description Disabled := 0 Ready := 1 Kicking := 2 Busy := 3 Done := 4 Aborted := 5 Error := 10"
  },
  "apictrl/plc.AXOpen.Core.eDialogAnswer.html": {
    "href": "apictrl/plc.AXOpen.Core.eDialogAnswer.html",
    "title": "Enum eDialogAnswer | System.Dynamic.ExpandoObject",
    "keywords": "Enum eDialogAnswer Namespace: plc.AXOpen.Core Assembly: .dll Syntax eDialogAnswer : INT Fields Name Description NoAnswer := 0 OK := 10 Yes := 20 No := 30 Cancel := 40"
  },
  "apictrl/plc.AXOpen.Core.eDialogType.html": {
    "href": "apictrl/plc.AXOpen.Core.eDialogType.html",
    "title": "Enum eDialogType | System.Dynamic.ExpandoObject",
    "keywords": "Enum eDialogType Namespace: plc.AXOpen.Core Assembly: .dll Syntax eDialogType : INT Fields Name Description Undefined := 0 Info := 10 Success := 20 Danger := 30 Warning := 40"
  },
  "apictrl/plc.AXOpen.Core.html": {
    "href": "apictrl/plc.AXOpen.Core.html",
    "title": "Namespace plc.AXOpen.Core | System.Dynamic.ExpandoObject",
    "keywords": "Namespace plc.AXOpen.Core Classes _NULL_CONTEXT Provides an empty context for uninitialized objects. _NULL_OBJECT Provides an empty object for uninitialized objects. _NULL_RTC Provides an empty RTC object for uninitialized RTC. _NULL_LOGGER Provides an empty logger object for uninitialized context logger. AxoAlertDialog AxoBoolArray AxoByteArray AxoComponent AxoContext Provides base for contextualized entry of AXOpen application.This class is abstract and must be inherited. AxoDialog AxoDialog class, which represents structure of base dialog. AxoDialogBase AxoMomentaryTask Provides basic momentary on function.To get the actual state of the toggle task, '''IsSwitchedOn()''', '''IsSwitchedOff()''' AND '''GetState()''' methods are available. AxoObject Provides base class for all classes of AXOpen. AxoRemoteTask Provides a mechanism to exectute a logic from the PLC in an .NET environment. > [!IMPORTANT]> The deferred execution in .NET envornment is not hard-real time nor deterministic. AxoTask AxoTextList AxoToggleTask Provides basic toggling between two states. The states are triggered by calling the '''Toggle()''' method.To get the actual state of the toggle task, '''IsSwitchedOn()''', '''IsSwitchedOff()''' AND '''GetState()''' methods are available. AxoSequencer AxoSequencerContainer AxoStep Interfaces IAxoAlertDialogFormat IAxoDialogAnswer IAxoDialogFormat IAxoComponent IAxoManuallyControllable IAxoContext IAxoCoordinator IAxoMomentaryTask IAxoObject IAxoTask IAxoTaskInt IAxoTaskState IAxoToggleTask IAxoSequencer IAxoStep"
  },
  "apictrl/plc.AXOpen.Core.IAxoAlertDialogFormat.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoAlertDialogFormat.html",
    "title": "Interface IAxoAlertDialogFormat | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoAlertDialogFormat Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoAlertDialogFormat Methods WithTitle Declaration Public AXOpen.Core.IAxoAlertDialogFormat WithTitle(in plc.STRING inTitle) Parameters Type Name Description STRING inTitle Returns Type Description IAxoAlertDialogFormat WithMessage Declaration Public AXOpen.Core.IAxoAlertDialogFormat WithMessage(in plc.STRING inMessage) Parameters Type Name Description STRING inMessage Returns Type Description IAxoAlertDialogFormat WithTimeToBurn Declaration Public AXOpen.Core.IAxoAlertDialogFormat WithTimeToBurn(in plc.UINT inSeconds) Parameters Type Name Description UINT inSeconds Returns Type Description IAxoAlertDialogFormat WithType Declaration Public AXOpen.Core.IAxoAlertDialogFormat WithType(in plc.AXOpen.Core.eDialogType inDialogType) Parameters Type Name Description eDialogType inDialogType Returns Type Description IAxoAlertDialogFormat IsShown Declaration Public BOOL IsShown() Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Core.IAxoComponent.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoComponent.html",
    "title": "Interface IAxoComponent | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoComponent Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoComponent"
  },
  "apictrl/plc.AXOpen.Core.IAxoContext.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoContext.html",
    "title": "Interface IAxoContext | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoContext Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoContext Methods CreateIdentity Declaration Public ULINT CreateIdentity() Returns Type Description ULINT OpenCycleCount Declaration Public ULINT OpenCycleCount() Returns Type Description ULINT GetRtc Declaration Public AXOpen.Rtc.IAxoRtc GetRtc() Returns Type Description IAxoRtc InjectRtc Declaration Public VOID InjectRtc(in plc.AXOpen.Rtc.IAxoRtc Rtc) Parameters Type Name Description IAxoRtc Rtc Returns Type Description GetLogger Declaration Public AXOpen.Logging.IAxoLogger GetLogger() Returns Type Description IAxoLogger InjectLogger Declaration Public VOID InjectLogger(in plc.AXOpen.Logging.IAxoLogger _logger) Parameters Type Name Description IAxoLogger _logger Returns Type Description"
  },
  "apictrl/plc.AXOpen.Core.IAxoCoordinator.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoCoordinator.html",
    "title": "Interface IAxoCoordinator | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoCoordinator Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoCoordinator Methods GetCoordinatorState Declaration Public AXOpen.Core.AxoCoordinatorStates GetCoordinatorState() Returns Type Description AxoCoordinatorStates MoveNext Declaration Public VOID MoveNext() Returns Type Description RequestStep Declaration Public VOID RequestStep(in plc.AXOpen.Core.IAxoStep RequestedStep) Parameters Type Name Description IAxoStep RequestedStep Returns Type Description"
  },
  "apictrl/plc.AXOpen.Core.IAxoDialogAnswer.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoDialogAnswer.html",
    "title": "Interface IAxoDialogAnswer | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoDialogAnswer Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoDialogAnswer Methods Answer Declaration Public AXOpen.Core.eDialogAnswer Answer() Returns Type Description eDialogAnswer"
  },
  "apictrl/plc.AXOpen.Core.IAxoDialogFormat.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoDialogFormat.html",
    "title": "Interface IAxoDialogFormat | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoDialogFormat Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoDialogFormat Methods WithCaption Declaration Public AXOpen.Core.IAxoDialogAnswer WithCaption(in plc.STRING inCaption) Parameters Type Name Description STRING inCaption Returns Type Description IAxoDialogAnswer WithOk Declaration Public AXOpen.Core.IAxoDialogAnswer WithOk() Returns Type Description IAxoDialogAnswer WithText Declaration Public AXOpen.Core.IAxoDialogAnswer WithText(in plc.STRING inText) Parameters Type Name Description STRING inText Returns Type Description IAxoDialogAnswer WithType Declaration Public AXOpen.Core.IAxoDialogAnswer WithType(in plc.AXOpen.Core.eDialogType inDialogType) Parameters Type Name Description eDialogType inDialogType Returns Type Description IAxoDialogAnswer WithYesNo Declaration Public AXOpen.Core.IAxoDialogAnswer WithYesNo() Returns Type Description IAxoDialogAnswer WithYesNoCancel Declaration Public AXOpen.Core.IAxoDialogAnswer WithYesNoCancel() Returns Type Description IAxoDialogAnswer"
  },
  "apictrl/plc.AXOpen.Core.IAxoManuallyControllable.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoManuallyControllable.html",
    "title": "Interface IAxoManuallyControllable | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoManuallyControllable Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoManuallyControllable Methods ActivateManualControl Declaration Public VOID ActivateManualControl() Returns Type Description IsManuallyControllable Declaration Public BOOL IsManuallyControllable() Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Core.IAxoMomentaryTask.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoMomentaryTask.html",
    "title": "Interface IAxoMomentaryTask | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoMomentaryTask Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoMomentaryTask Methods IsSwitchedOn Returns TRUE if task is switched on Declaration Public BOOL IsSwitchedOn() Returns Type Description BOOL IsSwitchedOff Returns TRUE if task is switched off Declaration Public BOOL IsSwitchedOff() Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Core.IAxoObject.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoObject.html",
    "title": "Interface IAxoObject | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoObject Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoObject Methods GetIdentity Declaration Public ULINT GetIdentity() Returns Type Description ULINT GetContext Declaration Public AXOpen.Core.IAxoContext GetContext() Returns Type Description IAxoContext"
  },
  "apictrl/plc.AXOpen.Core.IAxoSequencer.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoSequencer.html",
    "title": "Interface IAxoSequencer | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoSequencer Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoSequencer"
  },
  "apictrl/plc.AXOpen.Core.IAxoStep.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoStep.html",
    "title": "Interface IAxoStep | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoStep Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoStep Methods GetStepOrder Declaration Public ULINT GetStepOrder() Returns Type Description ULINT SetStepOrder Declaration Public VOID SetStepOrder(in plc.AXOpen.Core.IAxoCoordinator coord,in plc.ULINT StepOrder) Parameters Type Name Description IAxoCoordinator coord ULINT StepOrder Returns Type Description IsCalledJustOnceInThisPlcCycle Declaration Public BOOL IsCalledJustOnceInThisPlcCycle() Returns Type Description BOOL SetIsActive Declaration Public VOID SetIsActive(in plc.BOOL Active) Parameters Type Name Description BOOL Active Returns Type Description GetIsActive Declaration Public BOOL GetIsActive() Returns Type Description BOOL SetIsEnabled Declaration Public VOID SetIsEnabled(in plc.BOOL Enabled) Parameters Type Name Description BOOL Enabled Returns Type Description GetIsEnabled Declaration Public BOOL GetIsEnabled() Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Core.IAxoTask.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoTask.html",
    "title": "Interface IAxoTask | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoTask Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoTask Methods Execute Declaration Public BOOL Execute() Returns Type Description BOOL Invoke Declaration Public AXOpen.Core.IAxoTaskState Invoke() Returns Type Description IAxoTaskState Restore Declaration Public AXOpen.Core.IAxoTaskState Restore() Returns Type Description IAxoTaskState Abort Declaration Public VOID Abort() Returns Type Description Resume Declaration Public VOID Resume() Returns Type Description DoneWhen Declaration Public VOID DoneWhen(in plc.BOOL Condition) Parameters Type Name Description BOOL Condition Returns Type Description ThrowWhen Declaration Public VOID ThrowWhen(in plc.BOOL HasErrorState) Parameters Type Name Description BOOL HasErrorState Returns Type Description IsReady Declaration Public BOOL IsReady() Returns Type Description BOOL IsDone Declaration Public BOOL IsDone() Returns Type Description BOOL IsBusy Declaration Public BOOL IsBusy() Returns Type Description BOOL HasError Declaration Public BOOL HasError() Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Core.IAxoTaskInt.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoTaskInt.html",
    "title": "Interface IAxoTaskInt | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoTaskInt Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoTaskInt Methods SetIsDisabled Declaration Public VOID SetIsDisabled(in plc.BOOL Disabled) Parameters Type Name Description BOOL Disabled Returns Type Description GetIsDisabled Declaration Public BOOL GetIsDisabled() Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Core.IAxoTaskState.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoTaskState.html",
    "title": "Interface IAxoTaskState | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoTaskState Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoTaskState Methods IsDone Declaration Public BOOL IsDone() Returns Type Description BOOL IsBusy Declaration Public BOOL IsBusy() Returns Type Description BOOL IsAborted Declaration Public BOOL IsAborted() Returns Type Description BOOL HasError Declaration Public BOOL HasError() Returns Type Description BOOL GetErrorDetails Declaration Public STRING[254] GetErrorDetails() Returns Type Description STRING[254]"
  },
  "apictrl/plc.AXOpen.Core.IAxoToggleTask.html": {
    "href": "apictrl/plc.AXOpen.Core.IAxoToggleTask.html",
    "title": "Interface IAxoToggleTask | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoToggleTask Namespace: plc.AXOpen.Core Assembly: .dll Syntax INTERFACE IAxoToggleTask Methods Toggle Use to toggle the state of the '''AxoToggleTask'''. Declaration Public BOOL Toggle() Returns Type Description BOOL SwitchOff Use to set the state of the '''AxoToggleTask''' to the value '''FALSE'''. Declaration Public BOOL SwitchOff() Returns Type Description BOOL SwitchOn Use to set the state of the '''AxoToggleTask''' to the value '''TRUE'''. Declaration Public BOOL SwitchOn() Returns Type Description BOOL IsSwitchedOn Returns TRUE if task is switched on Declaration Public BOOL IsSwitchedOn() Returns Type Description BOOL IsSwitchedOff Returns TRUE if task is switched off Declaration Public BOOL IsSwitchedOff() Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Core.IsNullContext(IAxoContext).html": {
    "href": "apictrl/plc.AXOpen.Core.IsNullContext(IAxoContext).html",
    "title": "Delegate IsNullContext | System.Dynamic.ExpandoObject",
    "keywords": "Delegate IsNullContext Namespace: plc.AXOpen.Core Assembly: .dll Syntax Public BOOL IsNullContext(in plc.AXOpen.Core.IAxoContext Context) Parameters Type Name Description IAxoContext Context Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Data.AxoDataCrudTask.html": {
    "href": "apictrl/plc.AXOpen.Data.AxoDataCrudTask.html",
    "title": "Class AxoDataCrudTask | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataCrudTask Provides remote execution for CRUD operations.> [!NOTE]> This is an extension of AxoTasktask see the documentatio for details about implementation in .NET. Inheritance AxoDataExchangeTask AxoRemoteTask AxoTask AxoObject AxoDataCrudTask Implements IAxoEntityExistTaskState IAxoTask Inherited Members DataEntityIdentifier _exist DoneSignature IsInitialized HasRemoteException IsBeingCalledCounter TaskNotInitialized TaskHasRemoteException Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity Invoke(STRING[254]) Exist() Execute() GetStartSignature() SetDoneSignature() GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Data Assembly: .dll Syntax CLASS AxoDataCrudTask Properties CrudOperation Gets or sets the type of CRUD operation to be perfomed. Declaration CrudOperation : AXOpen.Data.eCrudOperation Property Value Type Description Methods Invoke Invokes this task. Declaration Public AXOpen.Core.IAxoTaskState Invoke(in plc.STRING[254] identifier,in plc.AXOpen.Data.eCrudOperation operation) Parameters Type Name Description STRING[254] identifier Data entity identifier eCrudOperation operation Operation to perfom. Returns Type Description IAxoTaskState Implements IAxoEntityExistTaskState IAxoTask"
  },
  "apictrl/plc.AXOpen.Data.AxoDataEntity.html": {
    "href": "apictrl/plc.AXOpen.Data.AxoDataEntity.html",
    "title": "Class AxoDataEntity | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataEntity Base class for any exchangable data in AxoDataExchange. Inheritance AxoDataEntity Implements IAxoDataEntity Namespace: plc.AXOpen.Data Assembly: .dll Syntax CLASS AxoDataEntity Properties DataEntityId Gets or sets data entity identifier. Declaration DataEntityId : STRING[254] Property Value Type Description Implements IAxoDataEntity"
  },
  "apictrl/plc.AXOpen.Data.AxoDataExchange.html": {
    "href": "apictrl/plc.AXOpen.Data.AxoDataExchange.html",
    "title": "Class AxoDataExchange | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataExchange Provides base class for any data exchange with an arbitrary remote repository.For configuration and set up see here Inheritance AxoDataExchangeBase AxoObject AxoDataExchange Implements IAxoDataExchange IAxoObject Inherited Members Identity GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Data Assembly: .dll Syntax CLASS AxoDataExchange Properties Operation Declaration Operation : AXOpen.Data.AxoDataCrudTask Property Value Type Description Methods Run Runs intialization and cyclical handling of this AxoDataExchange. Declaration Public VOID Run(in plc.AXOpen.Core.IAxoObject parent) Parameters Type Name Description IAxoObject parent Parent of this object Returns Type Description Run Runs intialization and cyclical handling of this AxoDataExchange. Declaration Public VOID Run(in plc.AXOpen.Core.IAxoContext context) Parameters Type Name Description IAxoContext context Root context of this object Returns Type Description Create Creates new entry into the remote repository from data entity of this AxoDataExchange. Declaration Public AXOpen.Core.IAxoTaskState Create(in plc.STRING[254] identifier) Parameters Type Name Description STRING[254] identifier Data identifier. Returns Type Description IAxoTaskState Read Reads data from remote repository and copies them into data entity of this AxoDataExchange. Declaration Public AXOpen.Core.IAxoTaskState Read(in plc.STRING[254] identifier) Parameters Type Name Description STRING[254] identifier Data identifier. Returns Type Description IAxoTaskState Update Updates data in remote repository from data entiry of this AxoDataExchange. Declaration Public AXOpen.Core.IAxoTaskState Update(in plc.STRING[254] identifier) Parameters Type Name Description STRING[254] identifier Data identifier. Returns Type Description IAxoTaskState Delete Deletes data entry with given ID from remote repository. Declaration Public AXOpen.Core.IAxoTaskState Delete(in plc.STRING[254] identifier) Parameters Type Name Description STRING[254] identifier Data identifier. Returns Type Description IAxoTaskState EntityExist Check if data entry exists with given ID in remote repository. Declaration Public AXOpen.Data.IAxoEntityExistTaskState EntityExist(in plc.STRING[254] identifier) Parameters Type Name Description STRING[254] identifier Data identifier. Returns Type Description IAxoEntityExistTaskState CreateOrUpdate Creates or Updates data in remote repository from data entiry of this AxoDataExchange. Declaration Public AXOpen.Core.IAxoTaskState CreateOrUpdate(in plc.STRING[254] identifier) Parameters Type Name Description STRING[254] identifier Data identifier. Returns Type Description IAxoTaskState Restore Restores all tasks associated with this object. Declaration Public VOID Restore() Returns Type Description Implements IAxoDataExchange IAxoObject"
  },
  "apictrl/plc.AXOpen.Data.AxoDataExchangeBase.html": {
    "href": "apictrl/plc.AXOpen.Data.AxoDataExchangeBase.html",
    "title": "Class AxoDataExchangeBase | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataExchangeBase Represents base class of data exchange.This class is used to provide abstract information about the type that can be used in rcc. Inheritance AxoObject AxoDataExchangeBase Implements IAxoObject Inherited Members Identity GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Data Assembly: .dll Syntax CLASS AxoDataExchangeBase Implements IAxoObject"
  },
  "apictrl/plc.AXOpen.Data.AxoDataExchangeTask.html": {
    "href": "apictrl/plc.AXOpen.Data.AxoDataExchangeTask.html",
    "title": "Class AxoDataExchangeTask | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataExchangeTask Extends AxoRemoteTask for data operation within AxoData Inheritance AxoRemoteTask AxoTask AxoObject AxoDataExchangeTask Implements IAxoEntityExistTaskState IAxoTask Inherited Members DoneSignature IsInitialized HasRemoteException IsBeingCalledCounter TaskNotInitialized TaskHasRemoteException Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity Execute() GetStartSignature() SetDoneSignature() GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Data Assembly: .dll Syntax CLASS AxoDataExchangeTask Properties DataEntityIdentifier Declaration DataEntityIdentifier : STRING[254] Property Value Type Description _exist Declaration _exist : BOOL Property Value Type Description Methods Invoke Declaration Public AXOpen.Core.IAxoTaskState Invoke(in plc.STRING[254] identifier) Parameters Type Name Description STRING[254] identifier Returns Type Description IAxoTaskState Exist Declaration Public BOOL Exist() Returns Type Description BOOL Implements IAxoEntityExistTaskState IAxoTask"
  },
  "apictrl/plc.AXOpen.Data.AxoDataFragmentExchange.html": {
    "href": "apictrl/plc.AXOpen.Data.AxoDataFragmentExchange.html",
    "title": "Class AxoDataFragmentExchange | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataFragmentExchange Provides base class for any composite/fragmetes data exchange combining one or more AxoDataExchange object.For configuration and set up see here Inheritance AxoDataExchangeBase AxoObject AxoDataFragmentExchange Implements IAxoDataExchange IAxoObject Inherited Members Identity GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Data Assembly: .dll Syntax CLASS AxoDataFragmentExchange Properties Operation Declaration Operation : AXOpen.Data.AxoDataCrudTask Property Value Type Description Methods Create Creates new entry into each associated remote repository from respective data entity. Declaration Public AXOpen.Core.IAxoTaskState Create(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState Read Reads data from each associated remote repository and copies it into respective data entities. Declaration Public AXOpen.Core.IAxoTaskState Read(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState Update Updates data in each associated remote repository from respective data entities. Declaration Public AXOpen.Core.IAxoTaskState Update(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState Delete Deletes data entry from each associated remote repository with given ID. Declaration Public AXOpen.Core.IAxoTaskState Delete(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState EntityExist Check if data entry exists in each associated remote repository with given ID. Declaration Public AXOpen.Data.IAxoEntityExistTaskState EntityExist(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoEntityExistTaskState CreateOrUpdate Creates or Updates data entry from each associated remote repository with given ID. Declaration Public AXOpen.Core.IAxoTaskState CreateOrUpdate(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState Restore Declaration Public VOID Restore() Returns Type Description Run Runs intialization and cyclical handling of this AxoDataExchange. Declaration Public VOID Run(in plc.AXOpen.Core.IAxoContext context) Parameters Type Name Description IAxoContext context Root context of this object Returns Type Description Run Runs intialization and cyclical handling of this AxoDataExchange. Declaration Public VOID Run(in plc.AXOpen.Core.IAxoObject parent) Parameters Type Name Description IAxoObject parent Parent of this object Returns Type Description Implements IAxoDataExchange IAxoObject"
  },
  "apictrl/plc.AXOpen.Data.eCrudOperation.html": {
    "href": "apictrl/plc.AXOpen.Data.eCrudOperation.html",
    "title": "Enum eCrudOperation | System.Dynamic.ExpandoObject",
    "keywords": "Enum eCrudOperation Namespace: plc.AXOpen.Data Assembly: .dll Syntax eCrudOperation Fields Name Description Create Read Update Delete CreateOrUpdate EntityExist"
  },
  "apictrl/plc.AXOpen.Data.html": {
    "href": "apictrl/plc.AXOpen.Data.html",
    "title": "Namespace plc.AXOpen.Data | System.Dynamic.ExpandoObject",
    "keywords": "Namespace plc.AXOpen.Data Classes AxoDataCrudTask Provides remote execution for CRUD operations.> [!NOTE]> This is an extension of AxoTasktask see the documentatio for details about implementation in .NET. AxoDataEntity Base class for any exchangable data in AxoDataExchange. AxoDataExchange Provides base class for any data exchange with an arbitrary remote repository.For configuration and set up see here AxoDataExchangeBase Represents base class of data exchange.This class is used to provide abstract information about the type that can be used in rcc. AxoDataExchangeTask Extends AxoRemoteTask for data operation within AxoData AxoDataFragmentExchange Provides base class for any composite/fragmetes data exchange combining one or more AxoDataExchange object.For configuration and set up see here Interfaces IAxoEntityExistTaskState IAxoDataEntity IAxoDataExchange Provides abastaction for data exchange. Enums eCrudOperation"
  },
  "apictrl/plc.AXOpen.Data.IAxoDataEntity.html": {
    "href": "apictrl/plc.AXOpen.Data.IAxoDataEntity.html",
    "title": "Interface IAxoDataEntity | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoDataEntity Namespace: plc.AXOpen.Data Assembly: .dll Syntax INTERFACE IAxoDataEntity"
  },
  "apictrl/plc.AXOpen.Data.IAxoDataExchange.html": {
    "href": "apictrl/plc.AXOpen.Data.IAxoDataExchange.html",
    "title": "Interface IAxoDataExchange | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoDataExchange Provides abastaction for data exchange. Namespace: plc.AXOpen.Data Assembly: .dll Syntax INTERFACE IAxoDataExchange Methods Create Declaration Public AXOpen.Core.IAxoTaskState Create(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState Read Declaration Public AXOpen.Core.IAxoTaskState Read(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState Update Declaration Public AXOpen.Core.IAxoTaskState Update(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState Delete Declaration Public AXOpen.Core.IAxoTaskState Delete(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState EntityExist Declaration Public AXOpen.Data.IAxoEntityExistTaskState EntityExist(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoEntityExistTaskState CreateOrUpdate Declaration Public AXOpen.Core.IAxoTaskState CreateOrUpdate(in plc.STRING[254] Identifier) Parameters Type Name Description STRING[254] Identifier Returns Type Description IAxoTaskState Restore Declaration Public VOID Restore() Returns Type Description Run Declaration Public VOID Run(in plc.AXOpen.Core.IAxoContext context) Parameters Type Name Description IAxoContext context Returns Type Description Run Declaration Public VOID Run(in plc.AXOpen.Core.IAxoObject parent) Parameters Type Name Description IAxoObject parent Returns Type Description"
  },
  "apictrl/plc.AXOpen.Data.IAxoEntityExistTaskState.html": {
    "href": "apictrl/plc.AXOpen.Data.IAxoEntityExistTaskState.html",
    "title": "Interface IAxoEntityExistTaskState | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoEntityExistTaskState Namespace: plc.AXOpen.Data Assembly: .dll Syntax INTERFACE IAxoEntityExistTaskState Methods Exist Declaration Public BOOL Exist() Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoAnalogueInspector.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoAnalogueInspector.html",
    "title": "Class AxoAnalogueInspector | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoAnalogueInspector Class representing inspection of value within an interval. Inheritance AxoInspector AxoObject AxoAnalogueInspector Implements IAxoAnalogueInspector IInspector IOnFail IAxoObject Inherited Members _axoInspectorDialog Identity CheckOverInspection() IsOverInspected() _WithCoordinator(IAxoCoordinator) OnFail() Dialog(IAxoStep,IAxoStep) RetryWithStep(IAxoStep) CarryOn() TerminateWithStep(IAxoStep) UpdateComprehensiveResult() RestoreInspectorTask() Busy() CommonData() Coordinator() Done() Result() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoAnalogueInspector Properties _data Declaration _data : AXOpen.Inspectors.AxoAnalogueInspectorData Property Value Type Description _lastOutValue Declaration _lastOutValue : LREAL Property Value Type Description Methods Inspect Inspection method, which contains main logic of inspection. Declaration Public AXOpen.Inspectors.IInspector Inspect(in plc.AXOpen.Core.IAxoObject _parent,in plc.LREAL Status) Parameters Type Name Description IAxoObject _parent LREAL Status Returns Type Description IInspector WithCoordinator Set coordinator to this instance Declaration Public AXOpen.Inspectors.IAxoAnalogueInspector WithCoordinator(in plc.AXOpen.Core.IAxoCoordinator inCoordinator) Parameters Type Name Description IAxoCoordinator inCoordinator Returns Type Description IAxoAnalogueInspector OnDone If inspection fails, set result to data Declaration Protected VOID OnDone() Returns Type Description Data Set coordinator to this instance Declaration Public REF_TO AXOpen.Inspectors.AxoAnalogueInspectorData Data() Returns Type Description REF_TO AXOpen.Inspectors.AxoAnalogueInspectorData Implements IAxoAnalogueInspector IInspector IOnFail IAxoObject"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoAnalogueInspectorData.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoAnalogueInspectorData.html",
    "title": "Class AxoAnalogueInspectorData | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoAnalogueInspectorData Data subjected to each analogue inspector instance. Inheritance AxoInspectorData AxoAnalogueInspectorData Inherited Members Timestamp PassTime FailTime Result IsExcluded IsByPassed NumberOfAllowedRetries RetryAttemptsCount Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoAnalogueInspectorData Properties RequiredMin Declaration RequiredMin : LREAL Property Value Type Description DetectedStatus Declaration DetectedStatus : LREAL Property Value Type Description RequiredMax Declaration RequiredMax : LREAL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoComprehensiveResult.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoComprehensiveResult.html",
    "title": "Class AxoComprehensiveResult | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoComprehensiveResult Inheritance AxoComprehensiveResult Implements IAxoComprehensiveResult Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoComprehensiveResult Properties Result Declaration Result : AXOpen.Inspectors.eOverallResult Property Value Type Description Failures Declaration Failures : STRING Property Value Type Description ErrorCodes Declaration ErrorCodes : STRING Property Value Type Description Methods GetResult Declaration Public AXOpen.Inspectors.eOverallResult GetResult() Returns Type Description eOverallResult GetFailures Declaration Public STRING GetFailures() Returns Type Description STRING GetErrorCodes Declaration Public STRING GetErrorCodes() Returns Type Description STRING SetResult Declaration Public VOID SetResult(in plc.AXOpen.Inspectors.eOverallResult inResult) Parameters Type Name Description eOverallResult inResult Returns Type Description SetFailures Declaration Public VOID SetFailures(in plc.STRING inFailures) Parameters Type Name Description STRING inFailures Returns Type Description SetErrorCodes Declaration Public VOID SetErrorCodes(in plc.STRING inErrorCodes) Parameters Type Name Description STRING inErrorCodes Returns Type Description Implements IAxoComprehensiveResult"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoDataInspector.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoDataInspector.html",
    "title": "Class AxoDataInspector | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataInspector Class representing inspection of string value with support of star notation. Inheritance AxoInspector AxoObject AxoDataInspector Implements IAxoDataInspector IInspector IOnFail IAxoObject Inherited Members _axoInspectorDialog Identity CheckOverInspection() IsOverInspected() _WithCoordinator(IAxoCoordinator) OnFail() Dialog(IAxoStep,IAxoStep) RetryWithStep(IAxoStep) CarryOn() TerminateWithStep(IAxoStep) UpdateComprehensiveResult() RestoreInspectorTask() Busy() CommonData() Coordinator() Done() Result() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoDataInspector Properties _data Declaration _data : AXOpen.Inspectors.AxoDataInspectorData Property Value Type Description _lastOutValue Declaration _lastOutValue : STRING Property Value Type Description Methods Inspect Inspection method, which contains main logic of inspection. Declaration Public AXOpen.Inspectors.IInspector Inspect(in plc.AXOpen.Core.IAxoObject _parent,in plc.STRING Status) Parameters Type Name Description IAxoObject _parent STRING Status Returns Type Description IInspector WithCoordinator Set coordinator to this instance Declaration Public AXOpen.Inspectors.IAxoDataInspector WithCoordinator(in plc.AXOpen.Core.IAxoCoordinator inCoordinator) Parameters Type Name Description IAxoCoordinator inCoordinator Returns Type Description IAxoDataInspector OnDone If inspection fails, set result to data Declaration Protected VOID OnDone() Returns Type Description IsCharNumber Check, if character is a number Declaration Protected BOOL IsCharNumber(in plc.CHAR inCharacter) Parameters Type Name Description CHAR inCharacter Returns Type Description BOOL Data Set coordinator to this instance Declaration Public REF_TO AXOpen.Inspectors.AxoDataInspectorData Data() Returns Type Description REF_TO AXOpen.Inspectors.AxoDataInspectorData Implements IAxoDataInspector IInspector IOnFail IAxoObject"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoDataInspectorData.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoDataInspectorData.html",
    "title": "Class AxoDataInspectorData | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDataInspectorData Data subjected to each data inspector instance. Inheritance AxoInspectorData AxoDataInspectorData Inherited Members Timestamp PassTime FailTime Result IsExcluded IsByPassed NumberOfAllowedRetries RetryAttemptsCount Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoDataInspectorData Properties RequiredStatus Declaration RequiredStatus : STRING Property Value Type Description DetectedStatus Declaration DetectedStatus : STRING Property Value Type Description StarNotationEnabled Declaration StarNotationEnabled : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoDigitalInspector.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoDigitalInspector.html",
    "title": "Class AxoDigitalInspector | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDigitalInspector Class representing inspection of bool value. Inheritance AxoInspector AxoObject AxoDigitalInspector Implements IAxoDigitalInspector IInspector IOnFail IAxoObject Inherited Members _axoInspectorDialog Identity CheckOverInspection() IsOverInspected() _WithCoordinator(IAxoCoordinator) OnFail() Dialog(IAxoStep,IAxoStep) RetryWithStep(IAxoStep) CarryOn() TerminateWithStep(IAxoStep) UpdateComprehensiveResult() RestoreInspectorTask() Busy() CommonData() Coordinator() Done() Result() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoDigitalInspector Properties _data Declaration _data : AXOpen.Inspectors.AxoDigitalInspectorData Property Value Type Description Methods Inspect Inspection method, which contains main logic of inspection. Declaration Public AXOpen.Inspectors.IInspector Inspect(in plc.AXOpen.Core.IAxoObject _parent,in plc.BOOL Status) Parameters Type Name Description IAxoObject _parent BOOL Status Returns Type Description IInspector OnDone If inspection fails, set result to data Declaration Protected VOID OnDone() Returns Type Description WithCoordinator Set coordinator to this instance Declaration Public AXOpen.Inspectors.IAxoDigitalInspector WithCoordinator(in plc.AXOpen.Core.IAxoCoordinator inCoordinator) Parameters Type Name Description IAxoCoordinator inCoordinator Returns Type Description IAxoDigitalInspector Data Set coordinator to this instance Declaration Public REF_TO AXOpen.Inspectors.AxoDigitalInspectorData Data() Returns Type Description REF_TO AXOpen.Inspectors.AxoDigitalInspectorData Implements IAxoDigitalInspector IInspector IOnFail IAxoObject"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoDigitalInspectorData.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoDigitalInspectorData.html",
    "title": "Class AxoDigitalInspectorData | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoDigitalInspectorData Data subjected to each digital inspector instance. Inheritance AxoInspectorData AxoDigitalInspectorData Inherited Members Timestamp PassTime FailTime Result IsExcluded IsByPassed NumberOfAllowedRetries RetryAttemptsCount Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoDigitalInspectorData Properties RequiredStatus Declaration RequiredStatus : BOOL Property Value Type Description DetectedStatus Declaration DetectedStatus : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoInspector.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoInspector.html",
    "title": "Class AxoInspector | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInspector AxoInspector base class with implemented evaluation methodsEvaluation methods need IAxoCoordinator instance Inheritance AxoObject AxoInspector Implements IInspector IOnFail IAxoObject Inherited Members Identity GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoInspector Properties _axoInspectorDialog Declaration _axoInspectorDialog : AXOpen.Inspectors.AxoInspectorDialog Property Value Type Description _inspectorTask Declaration _inspectorTask : AXOpen.Inspectors.AxoInspectorTask Property Value Type Description _coordinator Declaration _coordinator : AXOpen.Core.IAxoCoordinator Property Value Type Description _isOverInspected Declaration _isOverInspected : BOOL Property Value Type Description _busy Declaration _busy : BOOL Property Value Type Description _commonData Declaration _commonData : REF_TO AXOpen.Inspectors.AxoInspectorData Property Value Type Description _originalOverallResult Declaration _originalOverallResult : AXOpen.Inspectors.IAxoComprehensiveResult Property Value Type Description Methods CheckOverInspection Check, if data are overinspected (attempts of inspections is larger than maximum number of allowed retries) Declaration Public BOOL CheckOverInspection() Returns Type Description BOOL IsOverInspected Gets true when this inspection overruns max number of inspections. Declaration Protected BOOL IsOverInspected() Returns Type Description BOOL _WithCoordinator Set passed instance of iAxoCoordinator to this inspector.This method can be called only in derived classes. Declaration Protected AXOpen.Inspectors.IInspector _WithCoordinator(in plc.AXOpen.Core.IAxoCoordinator inCoordinator) Parameters Type Name Description IAxoCoordinator inCoordinator Returns Type Description IInspector OnFail Declaration Public AXOpen.Inspectors.IOnFail OnFail() Returns Type Description IOnFail Dialog Declaration Public BOOL Dialog(in plc.AXOpen.Core.IAxoStep inRetryStep,in plc.AXOpen.Core.IAxoStep inTerminateStep) Parameters Type Name Description IAxoStep inRetryStep IAxoStep inTerminateStep Returns Type Description BOOL RetryWithStep When inspection is done, retry provided step Declaration Public BOOL RetryWithStep(in plc.AXOpen.Core.IAxoStep inRetryStep) Parameters Type Name Description IAxoStep inRetryStep Returns Type Description BOOL CarryOn When inspection is done, continue to next step. Declaration Public BOOL CarryOn() Returns Type Description BOOL TerminateWithStep When inspection is done, terminate provided step Declaration Public BOOL TerminateWithStep(in plc.AXOpen.Core.IAxoStep inTerminateStep) Parameters Type Name Description IAxoStep inTerminateStep Returns Type Description BOOL UpdateComprehensiveResult Update commmon comprehensive result, which can be used across multiple inspectorsUpdates comprehensive result. The comprehensive result is set to Failed when any inspection fails or is inconclusive.Any bypassed or excluded inspections are not taken into account. Declaration Public AXOpen.Inspectors.IInspector UpdateComprehensiveResult() Returns Type Description IInspector RestoreInspectorTask Declaration Public BOOL RestoreInspectorTask() Returns Type Description BOOL Busy Declaration Public BOOL Busy() Returns Type Description BOOL CommonData Declaration Public REF_TO AXOpen.Inspectors.AxoInspectorData CommonData() Returns Type Description REF_TO AXOpen.Inspectors.AxoInspectorData Coordinator Declaration Public AXOpen.Core.IAxoCoordinator Coordinator() Returns Type Description IAxoCoordinator Done Declaration Public BOOL Done() Returns Type Description BOOL Result Declaration Public AXOpen.Inspectors.eInspectorResult Result() Returns Type Description eInspectorResult Implements IInspector IOnFail IAxoObject"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoInspectorData.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoInspectorData.html",
    "title": "Class AxoInspectorData | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInspectorData Data subjected to each inspector instance. Inheritance AxoInspectorData Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoInspectorData Properties Timestamp Declaration Timestamp : LDATE_AND_TIME Property Value Type Description PassTime Declaration PassTime : TIME Property Value Type Description FailTime Declaration FailTime : TIME Property Value Type Description Result Declaration Result : AXOpen.Inspectors.eInspectorResult Property Value Type Description IsExcluded Declaration IsExcluded : BOOL Property Value Type Description IsByPassed Declaration IsByPassed : BOOL Property Value Type Description NumberOfAllowedRetries Declaration NumberOfAllowedRetries : UINT Property Value Type Description RetryAttemptsCount Declaration RetryAttemptsCount : UINT Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoInspectorDialog.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoInspectorDialog.html",
    "title": "Class AxoInspectorDialog | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInspectorDialog AxoInspector base class with implemented evaluation methodsEvaluation methods need IAxoCoordinator instance Inheritance AxoDialogBase AxoRemoteTask AxoTask AxoObject AxoInspectorDialog Implements IAxoTask IAxoTaskState Inherited Members DoneSignature IsInitialized HasRemoteException IsBeingCalledCounter TaskNotInitialized TaskHasRemoteException Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity Execute() GetStartSignature() SetDoneSignature() GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoInspectorDialog Properties _isOverInspected Declaration _isOverInspected : BOOL Property Value Type Description _dialogueRetry Declaration _dialogueRetry : BOOL Property Value Type Description _dialogueTerminate Declaration _dialogueTerminate : BOOL Property Value Type Description _dialogueOverride Declaration _dialogueOverride : BOOL Property Value Type Description _lastCall Declaration _lastCall : ULINT Property Value Type Description _isActive Declaration _isActive : BOOL Property Value Type Description _dialogIsClosed Declaration _dialogIsClosed : BOOL Property Value Type Description _isAnswerProvided Declaration _isAnswerProvided : BOOL Property Value Type Description Methods Show Declaration Public VOID Show(in plc.REF_TO AXOpen.Inspectors.AxoInspector _parentInspectorRef,in plc.AXOpen.Core.IAxoStep inRetryStep,in plc.AXOpen.Core.IAxoStep inTerminateStep) Parameters Type Name Description REF_TO AXOpen.Inspectors.AxoInspector _parentInspectorRef IAxoStep inRetryStep IAxoStep inTerminateStep Returns Type Description Restore Declaration Public VOID Restore() Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Inspectors.AxoInspectorTask.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.AxoInspectorTask.html",
    "title": "Class AxoInspectorTask | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoInspectorTask Inheritance AxoTask AxoObject AxoInspectorTask Implements IAxoTask IAxoTaskState Inherited Members Status IsDisabled RemoteInvoke RemoteRestore RemoteAbort RemoteResume StartSignature Duration StartTimeStamp ErrorDetails Identity GetState() GetErrorDetails() IsReady() IsDone() IsBusy() IsAborted() HasError() IsNewInvokeCall() IsInvokeCalledInThisPlcCycle() WasInvokeCalledInPreviousPlcCycle() IsNewExecuteCall() IsExecuteCalledInThisPlcCycle() WasExecuteCalledInPreviousPlcCycle() UpdateState() Invoke() Restore() DoneWhen(BOOL) Execute() LogTask(STRING[80],eLogLevel,IAxoObject) ThrowWhen(BOOL) ThrowWhen(BOOL,STRING[254]) SetIsDisabled(BOOL) GetIsDisabled() Abort() Resume() OnAbort() OnResume() OnDone() OnError() OnRestore() OnStart() WhileError() GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax CLASS AxoInspectorTask Properties _onDoneFlag Declaration _onDoneFlag : BOOL Property Value Type Description _inspectionData Declaration _inspectionData : REF_TO AXOpen.Inspectors.AxoInspectorData Property Value Type Description _passTimer Declaration _passTimer : UNDEFINED Property Value Type Description _failTimer Declaration _failTimer : UNDEFINED Property Value Type Description Methods InspectionData Declaration Public REF_TO AXOpen.Inspectors.AxoInspectorData InspectionData() Returns Type Description REF_TO AXOpen.Inspectors.AxoInspectorData SetInspectionData Declaration Internal REF_TO AXOpen.Inspectors.AxoInspectorData SetInspectionData(in plc.REF_TO AXOpen.Inspectors.AxoInspectorData inInspectionData) Parameters Type Name Description REF_TO AXOpen.Inspectors.AxoInspectorData inInspectionData Returns Type Description REF_TO AXOpen.Inspectors.AxoInspectorData OnDoneFlag Declaration Public BOOL OnDoneFlag() Returns Type Description BOOL Execute Execute inspection task. Declaration Public BOOL Execute() Returns Type Description BOOL OnStart Executes once when inspection starts. Declaration Protected VOID OnStart() Returns Type Description Restore Declaration Public VOID Restore() Returns Type Description OnDone When inspection Task is done, evaluate inspection result and write to inspection data. Declaration Protected VOID OnDone() Returns Type Description Implements IAxoTask IAxoTaskState"
  },
  "apictrl/plc.AXOpen.Inspectors.eInspectorResult.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.eInspectorResult.html",
    "title": "Enum eInspectorResult | System.Dynamic.ExpandoObject",
    "keywords": "Enum eInspectorResult Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax eInspectorResult : INT Fields Name Description NoAction := 0 Running := 10 Passed := 20 Failed := 30 Inconclusive := 35 Excluded := 40 Bypassed := 50"
  },
  "apictrl/plc.AXOpen.Inspectors.eOverallResult.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.eOverallResult.html",
    "title": "Enum eOverallResult | System.Dynamic.ExpandoObject",
    "keywords": "Enum eOverallResult Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax eOverallResult : INT Fields Name Description NoAction := 0 InProgress := 10 Passed := 20 Failed := 30"
  },
  "apictrl/plc.AXOpen.Inspectors.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.html",
    "title": "Namespace plc.AXOpen.Inspectors | System.Dynamic.ExpandoObject",
    "keywords": "Namespace plc.AXOpen.Inspectors Classes AxoComprehensiveResult AxoInspector AxoInspector base class with implemented evaluation methodsEvaluation methods need IAxoCoordinator instance AxoInspectorData Data subjected to each inspector instance. AxoInspectorDialog AxoInspector base class with implemented evaluation methodsEvaluation methods need IAxoCoordinator instance AxoInspectorTask AxoAnalogueInspector Class representing inspection of value within an interval. AxoAnalogueInspectorData Data subjected to each analogue inspector instance. AxoDataInspector Class representing inspection of string value with support of star notation. AxoDataInspectorData Data subjected to each data inspector instance. AxoDigitalInspector Class representing inspection of bool value. AxoDigitalInspectorData Data subjected to each digital inspector instance. Interfaces IAxoAnalogueInspector IAxoDataInspector IAxoDigitalInspector IAxoComprehensiveResult IInspector IOnFail"
  },
  "apictrl/plc.AXOpen.Inspectors.IAxoAnalogueInspector.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.IAxoAnalogueInspector.html",
    "title": "Interface IAxoAnalogueInspector | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoAnalogueInspector Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax INTERFACE IAxoAnalogueInspector Methods Inspect Declaration Public AXOpen.Inspectors.IInspector Inspect(in plc.AXOpen.Core.IAxoObject _parent,in plc.LREAL Status) Parameters Type Name Description IAxoObject _parent LREAL Status Returns Type Description IInspector"
  },
  "apictrl/plc.AXOpen.Inspectors.IAxoComprehensiveResult.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.IAxoComprehensiveResult.html",
    "title": "Interface IAxoComprehensiveResult | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoComprehensiveResult Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax INTERFACE IAxoComprehensiveResult Methods GetResult Declaration Public AXOpen.Inspectors.eOverallResult GetResult() Returns Type Description eOverallResult GetFailures Declaration Public STRING GetFailures() Returns Type Description STRING GetErrorCodes Declaration Public STRING GetErrorCodes() Returns Type Description STRING SetResult Declaration Public VOID SetResult(in plc.AXOpen.Inspectors.eOverallResult inResult) Parameters Type Name Description eOverallResult inResult Returns Type Description SetFailures Declaration Public VOID SetFailures(in plc.STRING inFailures) Parameters Type Name Description STRING inFailures Returns Type Description SetErrorCodes Declaration Public VOID SetErrorCodes(in plc.STRING inErrorCodes) Parameters Type Name Description STRING inErrorCodes Returns Type Description"
  },
  "apictrl/plc.AXOpen.Inspectors.IAxoDataInspector.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.IAxoDataInspector.html",
    "title": "Interface IAxoDataInspector | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoDataInspector Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax INTERFACE IAxoDataInspector Methods Inspect Declaration Public AXOpen.Inspectors.IInspector Inspect(in plc.AXOpen.Core.IAxoObject _parent,in plc.STRING Status) Parameters Type Name Description IAxoObject _parent STRING Status Returns Type Description IInspector"
  },
  "apictrl/plc.AXOpen.Inspectors.IAxoDigitalInspector.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.IAxoDigitalInspector.html",
    "title": "Interface IAxoDigitalInspector | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoDigitalInspector Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax INTERFACE IAxoDigitalInspector Methods Inspect Declaration Public AXOpen.Inspectors.IInspector Inspect(in plc.AXOpen.Core.IAxoObject _parent,in plc.BOOL Status) Parameters Type Name Description IAxoObject _parent BOOL Status Returns Type Description IInspector"
  },
  "apictrl/plc.AXOpen.Inspectors.IInspector.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.IInspector.html",
    "title": "Interface IInspector | System.Dynamic.ExpandoObject",
    "keywords": "Interface IInspector Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax INTERFACE IInspector Methods Busy Declaration Public BOOL Busy() Returns Type Description BOOL CommonData Declaration Public REF_TO AXOpen.Inspectors.AxoInspectorData CommonData() Returns Type Description REF_TO AXOpen.Inspectors.AxoInspectorData Coordinator Declaration Public AXOpen.Core.IAxoCoordinator Coordinator() Returns Type Description IAxoCoordinator Done Declaration Public BOOL Done() Returns Type Description BOOL CheckOverInspection Declaration Public BOOL CheckOverInspection() Returns Type Description BOOL Result Declaration Public AXOpen.Inspectors.eInspectorResult Result() Returns Type Description eInspectorResult Dialog Declaration Public BOOL Dialog(in plc.AXOpen.Core.IAxoStep inRetryStep,in plc.AXOpen.Core.IAxoStep inTerminateStep) Parameters Type Name Description IAxoStep inRetryStep IAxoStep inTerminateStep Returns Type Description BOOL RestoreInspectorTask Declaration Public BOOL RestoreInspectorTask() Returns Type Description BOOL OnFail Declaration Public AXOpen.Inspectors.IOnFail OnFail() Returns Type Description IOnFail UpdateComprehensiveResult Declaration Public AXOpen.Inspectors.IInspector UpdateComprehensiveResult() Returns Type Description IInspector"
  },
  "apictrl/plc.AXOpen.Inspectors.IOnFail.html": {
    "href": "apictrl/plc.AXOpen.Inspectors.IOnFail.html",
    "title": "Interface IOnFail | System.Dynamic.ExpandoObject",
    "keywords": "Interface IOnFail Namespace: plc.AXOpen.Inspectors Assembly: .dll Syntax INTERFACE IOnFail Methods CarryOn Declaration Public BOOL CarryOn() Returns Type Description BOOL RetryWithStep Declaration Public BOOL RetryWithStep(in plc.AXOpen.Core.IAxoStep inRetryStep) Parameters Type Name Description IAxoStep inRetryStep Returns Type Description BOOL Dialog Declaration Public BOOL Dialog(in plc.AXOpen.Core.IAxoStep inRetryStep,in plc.AXOpen.Core.IAxoStep inTerminateStep) Parameters Type Name Description IAxoStep inRetryStep IAxoStep inTerminateStep Returns Type Description BOOL TerminateWithStep Declaration Public BOOL TerminateWithStep(in plc.AXOpen.Core.IAxoStep inTerminateStep) Parameters Type Name Description IAxoStep inTerminateStep Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Logging.AxoLogEntry.html": {
    "href": "apictrl/plc.AXOpen.Logging.AxoLogEntry.html",
    "title": "Class AxoLogEntry | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoLogEntry AxoLogEntry class represents a single log entry. Inheritance AxoLogEntry Namespace: plc.AXOpen.Logging Assembly: .dll Syntax CLASS AxoLogEntry Properties Message The message of the log entry. The maximum length of the message is 80 characters. Declaration Message : STRING[80] Property Value Type Description Level The severity level of the log entry. Declaration Level : AXOpen.Logging.eLogLevel Property Value Type Description Sender The identifier of the sender of the log entry. Declaration Sender : ULINT Property Value Type Description ToDequeue Indicates whether the log entry is ready to be dequeued. Declaration ToDequeue : BOOL Property Value Type Description"
  },
  "apictrl/plc.AXOpen.Logging.AxoLogger.html": {
    "href": "apictrl/plc.AXOpen.Logging.AxoLogger.html",
    "title": "Class AxoLogger | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoLogger AxoLogger class for logging purposes.This class implements IAxoLogger and IAxoLoggerConfig interfaces. Inheritance AxoLogger Implements IAxoLogger Namespace: plc.AXOpen.Logging Assembly: .dll Syntax CLASS AxoLogger Properties Carret The current position in the log entries array. Declaration Carret : INT Property Value Type Description MinimumLevel The minimum logging level to be captured by this logger. Declaration MinimumLevel : AXOpen.Logging.eLogLevel Property Value Type Description LogEntries The array containing log entries. Declaration LogEntries : ARRAY [0..100] OF AXOpen.Logging.AxoLogEntry Property Value Type Description Methods Log Log method that captures a message, logging level, and the sender of the log. Declaration Public VOID Log(in plc.STRING[80] _message,in plc.AXOpen.Logging.eLogLevel _level,in plc.AXOpen.Core.IAxoObject _sender) Parameters Type Name Description STRING[80] _message The message to be logged. eLogLevel _level The severity level of the log. IAxoObject _sender The object that sends the log. Returns Type Description Log Log method that captures a message and logging level. Declaration Public VOID Log(in plc.STRING[80] _message,in plc.AXOpen.Logging.eLogLevel _level) Parameters Type Name Description STRING[80] _message The message to be logged. eLogLevel _level The severity level of the log. Returns Type Description SetMinimumLevel Sets the minimum logging level to be captured by this logger. Declaration Public AXOpen.Logging.IAxoLoggerConfig SetMinimumLevel(in plc.AXOpen.Logging.eLogLevel _level) Parameters Type Name Description eLogLevel _level The minimum log level. Returns Type Description IAxoLoggerConfig Returns the instance of the logger. Implements IAxoLogger"
  },
  "apictrl/plc.AXOpen.Logging.eLogLevel.html": {
    "href": "apictrl/plc.AXOpen.Logging.eLogLevel.html",
    "title": "Enum eLogLevel | System.Dynamic.ExpandoObject",
    "keywords": "Enum eLogLevel Namespace: plc.AXOpen.Logging Assembly: .dll Syntax eLogLevel : INT Fields Name Description NoCat := 0 No category is assigned to the log level. Verbose := 1 Verbose level log is usually only enabled for debugging. Traffic is typically very high. Debug := 2 Debug level log is used for internal system events that are not necessarily observable from the outside. Information := 3 Information level log is used to track the general flow of the application. These logs should have long-term value. Warning := 4 Warning level log is used for abnormal or unexpected events in the application flow, which does not necessarily cause the application to stop. Error := 5 Error level log is used for errors and exceptions that cannot be handled. These result in a premature termination. Fatal := 6 Fatal level log is used to indicate a catastrophic failure that requires immediate attention."
  },
  "apictrl/plc.AXOpen.Logging.html": {
    "href": "apictrl/plc.AXOpen.Logging.html",
    "title": "Namespace plc.AXOpen.Logging | System.Dynamic.ExpandoObject",
    "keywords": "Namespace plc.AXOpen.Logging Classes AxoLogEntry AxoLogEntry class represents a single log entry. AxoLogger AxoLogger class for logging purposes.This class implements IAxoLogger and IAxoLoggerConfig interfaces. Interfaces IAxoLogger Defines the IAxoLogger interfaceThis interface extends IAxoLoggerConfig IAxoLoggerConfig Defines the IAxoLoggerConfig interface"
  },
  "apictrl/plc.AXOpen.Logging.IAxoLogger.html": {
    "href": "apictrl/plc.AXOpen.Logging.IAxoLogger.html",
    "title": "Interface IAxoLogger | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoLogger Defines the IAxoLogger interfaceThis interface extends IAxoLoggerConfig Namespace: plc.AXOpen.Logging Assembly: .dll Syntax INTERFACE IAxoLogger Methods Log Defines the Log methodThis method takes a message, a log level, and a sender as input Declaration Public VOID Log(in plc.STRING[80] _message,in plc.AXOpen.Logging.eLogLevel _level,in plc.AXOpen.Core.IAxoObject _sender) Parameters Type Name Description STRING[80] _message eLogLevel _level IAxoObject _sender Returns Type Description Log Defines another Log methodThis method takes a message and a log level as input Declaration Public VOID Log(in plc.STRING[80] _message,in plc.AXOpen.Logging.eLogLevel _level) Parameters Type Name Description STRING[80] _message eLogLevel _level Returns Type Description"
  },
  "apictrl/plc.AXOpen.Logging.IAxoLoggerConfig.html": {
    "href": "apictrl/plc.AXOpen.Logging.IAxoLoggerConfig.html",
    "title": "Interface IAxoLoggerConfig | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoLoggerConfig Defines the IAxoLoggerConfig interface Namespace: plc.AXOpen.Logging Assembly: .dll Syntax INTERFACE IAxoLoggerConfig Methods SetMinimumLevel Defines the SetMinimumLevel methodThis method takes a log level as input and returns an instance of IAxoLoggerConfig Declaration Public AXOpen.Logging.IAxoLoggerConfig SetMinimumLevel(in plc.AXOpen.Logging.eLogLevel _level) Parameters Type Name Description eLogLevel _level Returns Type Description IAxoLoggerConfig"
  },
  "apictrl/plc.AXOpen.Messaging.eAxoMessageCategory.html": {
    "href": "apictrl/plc.AXOpen.Messaging.eAxoMessageCategory.html",
    "title": "Enum eAxoMessageCategory | System.Dynamic.ExpandoObject",
    "keywords": "Enum eAxoMessageCategory Message categories.ATTENTION: Values must be multiply of 100 Namespace: plc.AXOpen.Messaging Assembly: .dll Syntax eAxoMessageCategory : INT Fields Name Description All := 0 Trace := 100 Trace message to be used for tracing purpose.Use when you need to track detailed information about internal states of the program for detailed visibility.This is lowest level of category that can be used in production, for detailed observation of PLC program. Debug := 200 Debug message to be used for debugging purpose only.Use when you need to report debug information for you as programmer. Info := 300 Info message.Use when you want to deliver information to the user, that has only informative character and does not adversely affect a process. TimedOut := 400 Time-out message.Use this category when you want to report a timed-out information, that may eventually succed. Notification := 500 Notification message.Use this category when you want to report a notification that may be of interest to the user, but does not adversly affect a process. Warning := 600 Warning message.Use this category when you want to report to the user an information about a possible problem, that may adversly affect a process.Information in this cateogory aims to help the user to identify a problem, the cause of such problem does not necessarily stops the process. Error := 700 Error message.Use this categoty when there is a failure that cannot be immediately recovered and an intervention is needed. This is typically a situation when a device failsto deliver expected result.Do not use this category to report information about failed process like measurement or detection. ProgrammingError := 900 Programming issue.Use this category to inform about a possible programming error, defect in settings or missing information at a level of programming or system or process settings. Critical := 1000 Critical error.Use this category when a critical error occured, that is not recoverable by the means of software (reset/restore) but device still operates under such conditions; a detailed inspection and an expert action is required. Fatal := 1100 Fatal error.Use this category when a fatal error occured, that is not recoverable by the means of software (reset/restore) and a detailed inspection is required, the device is not able to continue without special intervention, Catastrophic := 1200 Catastrophic error.Use this category when there is a situation when the device cannot continue operations due to irrecoverable failure. None := 32000"
  },
  "apictrl/plc.AXOpen.Messaging.Static.AxoMessenger.html": {
    "href": "apictrl/plc.AXOpen.Messaging.Static.AxoMessenger.html",
    "title": "Class AxoMessenger | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoMessenger Inheritance AxoObject AxoMessenger Implements IAxoMessageProperties IAxoObject Inherited Members Identity GetIdentity() GetContext() GetParent() Initialize(IAxoObject) Initialize(IAxoContext) Namespace: plc.AXOpen.Messaging.Static Assembly: .dll Syntax CLASS AxoMessenger Properties IsActive Declaration IsActive : BOOL Property Value Type Description Category Declaration Category : AXOpen.Messaging.eAxoMessageCategory Property Value Type Description MessageCode Declaration MessageCode : ULINT Property Value Type Description Risen Declaration Risen : LDATE_AND_TIME Property Value Type Description Fallen Declaration Fallen : LDATE_AND_TIME Property Value Type Description WaitingForAcknowledge Declaration WaitingForAcknowledge : BOOL Property Value Type Description AcknowledgementRequired Declaration AcknowledgementRequired : BOOL Property Value Type Description AcknowledgeRequest Declaration AcknowledgeRequest : BOOL Property Value Type Description AcknowledgedBeforeFallen Declaration AcknowledgedBeforeFallen : BOOL Property Value Type Description Acknowledged Declaration Acknowledged : LDATE_AND_TIME Property Value Type Description ActiveContextCount Declaration ActiveContextCount : ULINT Property Value Type Description Context Declaration Context : AXOpen.Core.IAxoContext Property Value Type Description Methods Serve Declaration Public VOID Serve(in plc.AXOpen.Core.IAxoContext _context) Parameters Type Name Description IAxoContext _context Returns Type Description Serve Declaration Public VOID Serve(in plc.AXOpen.Core.IAxoObject _object) Parameters Type Name Description IAxoObject _object Returns Type Description Activate Declaration Public AXOpen.Messaging.Static.IAxoMessageProperties Activate(in plc.AXOpen.Messaging.eAxoMessageCategory _category) Parameters Type Name Description eAxoMessageCategory _category Returns Type Description IAxoMessageProperties ToLogLevel Declaration Private AXOpen.Logging.eLogLevel ToLogLevel(in plc.AXOpen.Messaging.eAxoMessageCategory _messageCategory) Parameters Type Name Description eAxoMessageCategory _messageCategory Returns Type Description eLogLevel ActivateOnCondition Declaration Public AXOpen.Messaging.Static.IAxoMessageProperties ActivateOnCondition(in plc.BOOL _condition,in plc.AXOpen.Messaging.eAxoMessageCategory _category) Parameters Type Name Description BOOL _condition eAxoMessageCategory _category Returns Type Description IAxoMessageProperties Acknowledge Declaration Public VOID Acknowledge() Returns Type Description Deactivate Declaration Private VOID Deactivate() Returns Type Description RequireAcknowledgement Declaration Public AXOpen.Messaging.Static.IAxoMessageProperties RequireAcknowledgement() Returns Type Description IAxoMessageProperties DoNotRequireAcknowledgement Declaration Public AXOpen.Messaging.Static.IAxoMessageProperties DoNotRequireAcknowledgement() Returns Type Description IAxoMessageProperties IsAcknowledgementRequired Declaration Public BOOL IsAcknowledgementRequired() Returns Type Description BOOL Implements IAxoMessageProperties IAxoObject"
  },
  "apictrl/plc.AXOpen.Messaging.Static.html": {
    "href": "apictrl/plc.AXOpen.Messaging.Static.html",
    "title": "Namespace plc.AXOpen.Messaging.Static | System.Dynamic.ExpandoObject",
    "keywords": "Namespace plc.AXOpen.Messaging.Static Classes AxoMessenger Interfaces IAxoMessageProperties"
  },
  "apictrl/plc.AXOpen.Messaging.Static.IAxoMessageProperties.html": {
    "href": "apictrl/plc.AXOpen.Messaging.Static.IAxoMessageProperties.html",
    "title": "Interface IAxoMessageProperties | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoMessageProperties Namespace: plc.AXOpen.Messaging.Static Assembly: .dll Syntax INTERFACE IAxoMessageProperties Methods RequireAcknowledgement Declaration Public AXOpen.Messaging.Static.IAxoMessageProperties RequireAcknowledgement() Returns Type Description IAxoMessageProperties DoNotRequireAcknowledgement Declaration Public AXOpen.Messaging.Static.IAxoMessageProperties DoNotRequireAcknowledgement() Returns Type Description IAxoMessageProperties IsAcknowledgementRequired Declaration Public BOOL IsAcknowledgementRequired() Returns Type Description BOOL"
  },
  "apictrl/plc.AXOpen.Rtc.html": {
    "href": "apictrl/plc.AXOpen.Rtc.html",
    "title": "Namespace plc.AXOpen.Rtc | System.Dynamic.ExpandoObject",
    "keywords": "Namespace plc.AXOpen.Rtc Interfaces IAxoRtc"
  },
  "apictrl/plc.AXOpen.Rtc.IAxoRtc.html": {
    "href": "apictrl/plc.AXOpen.Rtc.IAxoRtc.html",
    "title": "Interface IAxoRtc | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoRtc Namespace: plc.AXOpen.Rtc Assembly: .dll Syntax INTERFACE IAxoRtc Methods NowUTC Declaration Public LDATE_AND_TIME NowUTC() Returns Type Description LDATE_AND_TIME"
  },
  "apictrl/plc.AXOpen.Utils.AxoStringBuilder.html": {
    "href": "apictrl/plc.AXOpen.Utils.AxoStringBuilder.html",
    "title": "Class AxoStringBuilder | System.Dynamic.ExpandoObject",
    "keywords": "Class AxoStringBuilder Allows to concat strings using fluent interface. It's similar to C# StringBuilder classUsage as follows : ErrorString := _stringBuilder.Clear().Append('Error number: ').Append(ErrorNumber).Append('. Message: ').Append(ErrorMessage).Append('.').AsString(); Inspired by Gerhard Barteling blogpost at https://www.plccoder.com/fluent-code/ Inheritance AxoStringBuilder Implements IAxoStringBuilder Namespace: plc.AXOpen.Utils Assembly: .dll Syntax CLASS AxoStringBuilder Properties _workString Declaration _workString : STRING[254] Property Value Type Description Methods Clear Declaration Public AXOpen.Utils.IAxoStringBuilder Clear() Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.BOOL Data) Parameters Type Name Description BOOL Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.BYTE Data) Parameters Type Name Description BYTE Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.WORD Data) Parameters Type Name Description WORD Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.DWORD Data) Parameters Type Name Description DWORD Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LWORD Data) Parameters Type Name Description LWORD Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.SINT Data) Parameters Type Name Description SINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.INT Data) Parameters Type Name Description INT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.DINT Data) Parameters Type Name Description DINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LINT Data) Parameters Type Name Description LINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.USINT Data) Parameters Type Name Description USINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.UINT Data) Parameters Type Name Description UINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.UDINT Data) Parameters Type Name Description UDINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.ULINT Data) Parameters Type Name Description ULINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.REAL Data) Parameters Type Name Description REAL Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LREAL Data) Parameters Type Name Description LREAL Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.TIME Data) Parameters Type Name Description TIME Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LTIME Data) Parameters Type Name Description LTIME Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.DATE Data) Parameters Type Name Description DATE Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LDATE Data) Parameters Type Name Description LDATE Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.TIME_OF_DAY Data) Parameters Type Name Description TIME_OF_DAY Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LTIME_OF_DAY Data) Parameters Type Name Description LTIME_OF_DAY Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.DATE_AND_TIME Data) Parameters Type Name Description DATE_AND_TIME Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LDATE_AND_TIME Data) Parameters Type Name Description LDATE_AND_TIME Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.CHAR Data) Parameters Type Name Description CHAR Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.STRING[254] Data) Parameters Type Name Description STRING[254] Data Returns Type Description IAxoStringBuilder AsString Declaration Public STRING[254] AsString() Returns Type Description STRING[254] AsString160 Declaration Public STRING[160] AsString160() Returns Type Description STRING[160] Implements IAxoStringBuilder"
  },
  "apictrl/plc.AXOpen.Utils.html": {
    "href": "apictrl/plc.AXOpen.Utils.html",
    "title": "Namespace plc.AXOpen.Utils | System.Dynamic.ExpandoObject",
    "keywords": "Namespace plc.AXOpen.Utils Classes AxoStringBuilder Allows to concat strings using fluent interface. It's similar to C# StringBuilder classUsage as follows : ErrorString := _stringBuilder.Clear().Append('Error number: ').Append(ErrorNumber).Append('. Message: ').Append(ErrorMessage).Append('.').AsString(); Inspired by Gerhard Barteling blogpost at https://www.plccoder.com/fluent-code/ Interfaces IAxoStringBuilder Allows to concat strings using fluent interface. It's similar to C# StringBuilder classUsage as follows : ErrorString := _stringBuilder.Clear().Append('Error number: ').Append(ErrorNumber).Append('. Message: ').Append(ErrorMessage).Append('.').AsString(); Inspired by Gerhard Barteling blogpost at https://www.plccoder.com/fluent-code/"
  },
  "apictrl/plc.AXOpen.Utils.IAxoStringBuilder.html": {
    "href": "apictrl/plc.AXOpen.Utils.IAxoStringBuilder.html",
    "title": "Interface IAxoStringBuilder | System.Dynamic.ExpandoObject",
    "keywords": "Interface IAxoStringBuilder Allows to concat strings using fluent interface. It's similar to C# StringBuilder classUsage as follows : ErrorString := _stringBuilder.Clear().Append('Error number: ').Append(ErrorNumber).Append('. Message: ').Append(ErrorMessage).Append('.').AsString(); Inspired by Gerhard Barteling blogpost at https://www.plccoder.com/fluent-code/ Namespace: plc.AXOpen.Utils Assembly: .dll Syntax INTERFACE IAxoStringBuilder Methods Clear Declaration Public AXOpen.Utils.IAxoStringBuilder Clear() Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.BOOL Data) Parameters Type Name Description BOOL Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.BYTE Data) Parameters Type Name Description BYTE Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.WORD Data) Parameters Type Name Description WORD Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.DWORD Data) Parameters Type Name Description DWORD Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LWORD Data) Parameters Type Name Description LWORD Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.SINT Data) Parameters Type Name Description SINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.INT Data) Parameters Type Name Description INT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.DINT Data) Parameters Type Name Description DINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LINT Data) Parameters Type Name Description LINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.USINT Data) Parameters Type Name Description USINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.UINT Data) Parameters Type Name Description UINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.UDINT Data) Parameters Type Name Description UDINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.ULINT Data) Parameters Type Name Description ULINT Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.REAL Data) Parameters Type Name Description REAL Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LREAL Data) Parameters Type Name Description LREAL Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.TIME Data) Parameters Type Name Description TIME Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LTIME Data) Parameters Type Name Description LTIME Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.DATE Data) Parameters Type Name Description DATE Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LDATE Data) Parameters Type Name Description LDATE Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.TIME_OF_DAY Data) Parameters Type Name Description TIME_OF_DAY Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LTIME_OF_DAY Data) Parameters Type Name Description LTIME_OF_DAY Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.DATE_AND_TIME Data) Parameters Type Name Description DATE_AND_TIME Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.LDATE_AND_TIME Data) Parameters Type Name Description LDATE_AND_TIME Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.CHAR Data) Parameters Type Name Description CHAR Data Returns Type Description IAxoStringBuilder Append Declaration Public AXOpen.Utils.IAxoStringBuilder Append(in plc.STRING[254] Data) Parameters Type Name Description STRING[254] Data Returns Type Description IAxoStringBuilder"
  },
  "articles/clientIdentification/README.html": {
    "href": "articles/clientIdentification/README.html",
    "title": "Client Identification | System.Dynamic.ExpandoObject",
    "keywords": "Client Identification Thanks to having AXOpen.Security implemented, we are able to identify users using our application. The same user can be logged in on multiple clients at the same time and it is desirable to be able to have an account of which clients belong to which user. This article explains how this can be achieved and how we can send messages to specific clients in Blazor. This app is built on SignalR, an open-source library that simplifies adding real-time web functionality to apps. Prerequisities: Microsoft.AspNetCore.SignalR.Client NuGet package SignalR hub Creating a hub To create a new SignalR hub, we need to create a class that inherits from the Hub class located in the Microsoft.AspNetCore.SignalR namespace. It is responsible for handling messages from clients and connection management. A simple demo of a SignalR hub can be found in ConnectionHub.cs. The ConnectionHub class has a number of methods that can be overridden and methods specified by the user. E.g.: OnConnectedAsync() - called when a new client connects to the hub OnDisconnectedAsync() - called when a client disconnects from the hub SendMessage() - custom method that can be called by the client Hub set up in Blazor To use the hub across all components in Blazor we need to create a service that will provide the Hub connection. See HubConnectionProvider.cs. The service is registered in the Program.cs file in the service configuration: builder.Services.AddSignalR(); builder.Services.AddScoped<HubConnectionProvider>(); Also in Program.cs we need to map the hub to a specific endpoint in the middleware pipeline: app.MapHub<ConnectionHub>(\"/connectionHub\"); In App.razor we can then inject the HubConnectionProvider service and use it to create a connection to the hub: @inject HubConnectionProvider HubConnectionProvider @code { protected override async Task OnInitializedAsync() { HubConnectionProvider.HubConnection = new HubConnectionBuilder() .WithUrl(NavigationManager.ToAbsoluteUri(\"/connectionHub\")) .Build(); await HubConnectionProvider.HubConnection.StartAsync(); } } Communication with the hub To use the hub we need to first inject the HubConnectionProvider service into the component we want to use the hub in. To listen for messages from the hub we need to register a handler (a method that will be called when a message is received) using the On method. In Index.razor.cs e.g.: HubConnectionProvider.HubConnection.On<string, string>(\"ReceiveMessage\", (sender, message) => { // do something }); This will register a handler that will be called when a message with the name ReceiveMessage is received. The handler will be called with two parameters - sender and message. The types of the parameters need to be specified in the On method. This ReceiveMessage is called from the ConnectionHub in a SendMessage method: public async Task SendMessage(string receiver, string message) { ... // sends message to all clients regardless of the receiver await Clients.All.SendAsync(\"ReceiveMessage\", sender, message); } To trigger the SendMessage method from the client we can use the InvokeAsync method in a code behind of a component: await HubConnectionProvider.HubConnection.SendAsync(\"SendMessage\", receiver, message); Sequence diagram of the communication between the clients and the hub: sequenceDiagram participant Client 1 participant Client 2 participant Client 3 participant Hub loop Communication Client 3->>Hub: HubConnection.SendAsync(\"SendMessage\", receiver, message) Note over Hub: SendMessage(string receiver, string message)<br/>is called Hub-->>Client 1: Clients.All.SendAsync(\"ReceiveMessage\", sender, message); Hub-->>Client 2: Clients.All.SendAsync(\"ReceiveMessage\", sender, message); Hub-->>Client 3: Clients.All.SendAsync(\"ReceiveMessage\", sender, message); Note over Client 2: HubConnection.On(\"ReceiveMessage\")<br/>listener is triggered on all clients end How to identify clients To be able to access currently logged in user in ConnectionHub we need to obtain the .AspNetCore.Identity.Application cookie used for identification. This is done in the Host.cshtml file: var cookie = HttpContext.Request.Cookies[\".AspNetCore.Identity.Application\"]; The cookie is then passed to the App.razor component as a parameter. In the code behind of the App.razor component, a cookie object is created and added to the HubConnection as a cookie container under options.Cookies: var cookieContainer = new CookieContainer(); var cookie = new Cookie() { Name = \".AspNetCore.Identity.Application\", Domain = NavigationManager.ToAbsoluteUri(\"/\").Host, Value = IdentityCookie }; cookieContainer.Add(cookie); HubConnectionProvider.HubConnection = new HubConnectionBuilder() .WithUrl(NavigationManager.ToAbsoluteUri(\"/connectionHub\"), options => { options.Cookies = cookieContainer; }) .Build(); By providing the cookie to the HubConnection we are now able to access the currently logged in user in the ConnectionHub: string name = Context.User.Identity.Name; // name of the currently logged in user Mapping client connection ids to user names To by able to send messages to only those clients on which the specific user we want to send the message to is logged in, we need to map the client connection ids to the client's logged in user. The ConnectionHub contains a static variable _connections of type ConnectionMapping<string> that maps the client connection ids to the user names. The ConnectionMapping class is a simple dictionary that allows multiple values to be mapped to a single key. The ConnectionMapping class is defined in ConnectionMapping.cs. When a new client connects to the hub, the OnConnectedAsync() method is called. Each connection has a unique id which we can add to the _connections dictionary along with the user name of the currently logged in user: string name = Context.User.Identity.Name; if (name != null) { _connections.Add(name, Context.ConnectionId); } As it is implemented currently, when a user on a client is not logged in, the connection is not added to the mapping. When a client disconnects from the hub, the OnDisconnectedAsync() method is called. We can then remove the connection id from the _connections dictionary: string name = Context.User.Identity.Name; if (name != null) { _connections.Remove(name, Context.ConnectionId); } Sending messages to specific clients To send a message to those clients on which the specific user is logged in, we need to obtain the connection ids of those clients. This is done by getting the values from the _connections dictionary using the user name as a key: var receiverConnections = _connections.GetConnections(receiver); if (!receiverConnections.IsNullOrEmpty()) { await Clients.Clients(receiverConnections.ToList()).SendAsync(\"ReceiveMessage\", name, message); } To send a message to all clients, we can use the Clients.All.SendAsync() method. if we want to send a message only to the caller (the client that called a SendAsync to the hub), we can use the Clients.Caller.SendAsync() method."
  },
  "articles/components/AXOPENCOGNEVISION/AXOPENCOGNEVISION_V_6_0_0_0.html": {
    "href": "articles/components/AXOPENCOGNEVISION/AXOPENCOGNEVISION_V_6_0_0_0.html",
    "title": "AXOpenCognexVision | System.Dynamic.ExpandoObject",
    "keywords": "AXOpenCognexVision The AXOpenCognexVision library controls and operates the vision devices from the manufacturer Cognex. AxoDataman AxoDataman provides the essential control and operation of all code-reader of the Dataman family. Implementation The AxoDataman is designed to be used as a member of the AxoContext or AxoObject. Therefore its instance must be initialized with the proper AxoContext or AxoObject before any use. Also, the hardware signals must be assigned first before calling any method of this instance. To accomplish this, call the Run method cyclically with the proper variables (i.e. inside the Main method of the relevant AxoContext) as in the example below: Example of the initialization and hardware signal assignement MyDataman1.Run( parent := THIS, refAcquisitionControl := REF(PlcOutputs^._10a1_Acquisition_Control_1), refAcquisitionStatus := REF(PlcInputs^._10a1_Acquisition_Status_1), refResultsControl := REF(PlcOutputs^._10a1_Results_Control_1), refResultsStatus := REF(PlcInputs^._10a1_Results_Status_1), refSoftEventControl := REF(PlcOutputs^._10a1_Soft_Event_Control_1), refSoftEventStatus := REF(PlcInputs^._10a1_Soft_Event_Control_1), refResultData := REF(PlcInputs^._10a1_Result_Data_128_bytes_1), refUserData := REF(PlcOutputs^._10a1_User_Data_128_bytes_1)); There are three public methods to operate the AxoDataman: Restore - restores the state of the AxoDataman to the initial state and resets all the internal variables. ClearResultData - resets the data read and confirms the data received from the device. Example of using ClearResultData method IF MyDataman1.ClearResultData().IsDone() THEN //Data inside MyDataman1.Results.Data is cleared ; END_IF; Read - triggers the reading sequence and waits for results. Example of using Read method IF MyDataman1.Read().IsDone() THEN //Process the result data myString := MyDataman1.Results.Data; END_IF;"
  },
  "articles/components/AXOPENCOGNEVISION/README.html": {
    "href": "articles/components/AXOPENCOGNEVISION/README.html",
    "title": "AXOpenCognexVision | System.Dynamic.ExpandoObject",
    "keywords": "AXOpenCognexVision The AXOpenCognexVision library controls and operates the vision devices from the manufacturer Cognex. VERSIONS AXOpenCognexVision The AXOpenCognexVision library controls and operates the vision devices from the manufacturer Cognex. AxoDataman AxoDataman provides the essential control and operation of all code-reader of the Dataman family. Implementation The AxoDataman is designed to be used as a member of the AxoContext or AxoObject. Therefore its instance must be initialized with the proper AxoContext or AxoObject before any use. Also, the hardware signals must be assigned first before calling any method of this instance. To accomplish this, call the Run method cyclically with the proper variables (i.e. inside the Main method of the relevant AxoContext) as in the example below: Example of the initialization and hardware signal assignement MyDataman1.Run( parent := THIS, refAcquisitionControl := REF(PlcOutputs^._10a1_Acquisition_Control_1), refAcquisitionStatus := REF(PlcInputs^._10a1_Acquisition_Status_1), refResultsControl := REF(PlcOutputs^._10a1_Results_Control_1), refResultsStatus := REF(PlcInputs^._10a1_Results_Status_1), refSoftEventControl := REF(PlcOutputs^._10a1_Soft_Event_Control_1), refSoftEventStatus := REF(PlcInputs^._10a1_Soft_Event_Control_1), refResultData := REF(PlcInputs^._10a1_Result_Data_128_bytes_1), refUserData := REF(PlcOutputs^._10a1_User_Data_128_bytes_1)); There are three public methods to operate the AxoDataman: Restore - restores the state of the AxoDataman to the initial state and resets all the internal variables. ClearResultData - resets the data read and confirms the data received from the device. Example of using ClearResultData method IF MyDataman1.ClearResultData().IsDone() THEN //Data inside MyDataman1.Results.Data is cleared ; END_IF; Read - triggers the reading sequence and waits for results. Example of using Read method IF MyDataman1.Read().IsDone() THEN //Process the result data myString := MyDataman1.Results.Data; END_IF;"
  },
  "articles/components/AXOPENELEMENTS/AXOAI.html": {
    "href": "articles/components/AXOPENELEMENTS/AXOAI.html",
    "title": "AXOpenElements.AxoAi | System.Dynamic.ExpandoObject",
    "keywords": "AXOpenElements.AxoAi AxoAi is used for checking values of analogue inputs. AxoAi scales input signal based on values in AxoAiConfig class. AxoAiConfig contains: // Configuration class for analog input CLASS AxoAiConfig VAR PUBLIC // Lowest possible value of the raw input. RawLow : DINT; // Highest possible value of the raw input. RawHigh : DINT; // Lowest threshold of scaled value. // `RealLow` and `RealHigh` should represent the real range of an continuous input. RealLow : REAL; // Highest threshold range of scaled value. // `RealLow` and `RealHigh` should represent the real range of an continuous input. RealHigh : REAL; // Allows simple adjustment of the calculated value multiplying the value by factor of `Gain`. Gain : REAL := REAL#1.0; // Allows simple adjustment of the calculated value by adding `Offset` value. Offset : REAL := REAL#0.0; END_VAR END_CLASS Example //define variables _testAi : AXOpen.Elements.AxoAi; _testAiInput : DINT := DINT#10; // set manual control _testAi.ActivateManualControl(); // run logic _testAi.Run(THIS, _testAiInput);"
  },
  "articles/components/AXOPENELEMENTS/AXOAO.html": {
    "href": "articles/components/AXOPENELEMENTS/AXOAO.html",
    "title": "AXOpenElements.AxoAo | System.Dynamic.ExpandoObject",
    "keywords": "AXOpenElements.AxoAo AxoAo is used for setting analogue values. AxoAo un-scales input signal based on SetPoint and values in AxoAoConfig class. /// <summary> /// Configuration class for analog output /// </summary> CLASS AxoAoConfig VAR PUBLIC // Lowest possible value of the raw input. RawLow : DINT; // Highest possible value of the raw input. RawHigh : DINT; // Lowest threshold of scaled value. // `RealLow` and `RealHigh` should represent the real range of an continuous input. RealLow : REAL; // Highest threshold range of scaled value. // `RealLow` and `RealHigh` should represent the real range of an continuous input. RealHigh : REAL; // Allows simple adjustment of the calculated value multiplying the value by factor of `Gain`. Gain : REAL := REAL#1.0; // Allows simple adjustment of the calculated value by adding `Offset` value. Offset : REAL := REAL#0.0; END_VAR END_CLASS Example //define variables _testAo : AXOpen.Elements.AxoAo; _testAoOutput : DINT; // set manual control _testAo.ActivateManualControl(); // run logic _testAo.Run(THIS, _testAoOutput);"
  },
  "articles/components/AXOPENELEMENTS/AXODI.html": {
    "href": "articles/components/AXOPENELEMENTS/AXODI.html",
    "title": "AXOpenElements.AxoDi | System.Dynamic.ExpandoObject",
    "keywords": "AXOpenElements.AxoDi AxoDi is used for checking values of digital inputs. Example //define variables _testDi : AXOpen.Elements.AxoDi; _testsignal : BOOL; // set manual control _testDo.ActivateManualControl(); // run logic _testDo.Run(THIS, _testInOutSignal);"
  },
  "articles/components/AXOPENELEMENTS/AXODO.html": {
    "href": "articles/components/AXOPENELEMENTS/AXODO.html",
    "title": "AXOpenElements.AxoDo | System.Dynamic.ExpandoObject",
    "keywords": "AXOpenElements.AxoDo AxoDo is used for setting values of digital inputs. Example //define variables _testDo : AXOpen.Elements.AxoDo; _testInOutSignal : BOOL; // set manual control _testDo.ActivateManualControl(); // run logic _testDo.Run(THIS, _testInOutSignal);"
  },
  "articles/components/AXOPENELEMENTS/README.html": {
    "href": "articles/components/AXOPENELEMENTS/README.html",
    "title": "AXOpenElements | System.Dynamic.ExpandoObject",
    "keywords": "AXOpenElements The AXOpenElements library provides ability to work with analog a digital I/O signals. VERSIONS AXOpenElements.AxoDi AxoDi is used for checking values of digital inputs. Example //define variables _testDi : AXOpen.Elements.AxoDi; _testsignal : BOOL; // set manual control _testDo.ActivateManualControl(); // run logic _testDo.Run(THIS, _testInOutSignal); AXOpenElements.AxoDo AxoDo is used for setting values of digital inputs. Example //define variables _testDo : AXOpen.Elements.AxoDo; _testInOutSignal : BOOL; // set manual control _testDo.ActivateManualControl(); // run logic _testDo.Run(THIS, _testInOutSignal); AXOpenElements.AxoAi AxoAi is used for checking values of analogue inputs. AxoAi scales input signal based on values in AxoAiConfig class. AxoAiConfig contains: // Configuration class for analog input CLASS AxoAiConfig VAR PUBLIC // Lowest possible value of the raw input. RawLow : DINT; // Highest possible value of the raw input. RawHigh : DINT; // Lowest threshold of scaled value. // `RealLow` and `RealHigh` should represent the real range of an continuous input. RealLow : REAL; // Highest threshold range of scaled value. // `RealLow` and `RealHigh` should represent the real range of an continuous input. RealHigh : REAL; // Allows simple adjustment of the calculated value multiplying the value by factor of `Gain`. Gain : REAL := REAL#1.0; // Allows simple adjustment of the calculated value by adding `Offset` value. Offset : REAL := REAL#0.0; END_VAR END_CLASS Example //define variables _testAi : AXOpen.Elements.AxoAi; _testAiInput : DINT := DINT#10; // set manual control _testAi.ActivateManualControl(); // run logic _testAi.Run(THIS, _testAiInput); AXOpenElements.AxoAo AxoAo is used for setting analogue values. AxoAo un-scales input signal based on SetPoint and values in AxoAoConfig class. /// <summary> /// Configuration class for analog output /// </summary> CLASS AxoAoConfig VAR PUBLIC // Lowest possible value of the raw input. RawLow : DINT; // Highest possible value of the raw input. RawHigh : DINT; // Lowest threshold of scaled value. // `RealLow` and `RealHigh` should represent the real range of an continuous input. RealLow : REAL; // Highest threshold range of scaled value. // `RealLow` and `RealHigh` should represent the real range of an continuous input. RealHigh : REAL; // Allows simple adjustment of the calculated value multiplying the value by factor of `Gain`. Gain : REAL := REAL#1.0; // Allows simple adjustment of the calculated value by adding `Offset` value. Offset : REAL := REAL#0.0; END_VAR END_CLASS Example //define variables _testAo : AXOpen.Elements.AxoAo; _testAoOutput : DINT; // set manual control _testAo.ActivateManualControl(); // run logic _testAo.Run(THIS, _testAoOutput);"
  },
  "articles/components/README.html": {
    "href": "articles/components/README.html",
    "title": "General rules and conventions | System.Dynamic.ExpandoObject",
    "keywords": "#AXOpen.Components AXOpen.Components is a group of libraries providing control of the individual types of devices grouped by the manufacturer and the function group. General rules and conventions WORK IN PORGRESS Components REVISION DATE NOTES 0.0 June 2023 Initial release 0.1 August 2023 Initial release 0.2 August 2023 Documentation requirements and others This document describes the format and practices for writing components in TcOpen. These are universal rules to observe. Each rule knows exception when there is a reasonable argument behind it. General rules Component must inherit from AXOpen.Core.AxoComponent Components methods and properties should not be marked FINAL (sealed) Component should implement appropriate INTERFACE for a public contract; this is the interface that the consumers of the library will use to interact with the component. It represents the public contract that must not change during the lifetime of the particular major version of the library/framework. See semantic versioning. Component members must explicitly state access modifier for methods and properties (PUBLIC, INTERNAL, PROTECTED, or PRIVATE) Component should properly hide implementation details by marking methods preferably PROTECTED. Consider using the PRIVATE access modifier to prevent any access to that member if you deem it necessary. Be aware, though, that private members cannot be overridden by a derived class. If there are any testing methods in the same library with the component, these must be marked INTERNAL. Each action of the component should be implemented using the AxoTask class. There is no exception to this rule, even for the actions that require a single cycle to complete. Task's Invoke should be placed into a method with an appropriate name (MoveAbsolute, MoveHome, Measure). Cyclic call Each component implements the logic required to run cyclically in the Run method of the CLASS. Components methods The methods that perform actions MUST return AXOpen.IAxoTaskStatus (typically AXOpen.Core.AxoTask). This rule applies even to the logic that requires a single-cycle execution. Library placement Library must be placed in src folder of the repository. The containing folder should be named components.[manufacturer].[function_group] (e.g. components.cognex.vision). Abstractions Each component should implement basic contract interface defined in the AxoAbstractions library (e.g. AxoAbbRobot should implenent IAxoRobot, AxoCognexReader should impement IAxoReader) I/O variables Components must not contain I/O (%I*, %Q*) variables directly (no AT directive). I/O variables naming The AxOpen does not use Hungarian prefixes, with few exceptions. IN/OUT and REF_TO method argument parameters are one of those exceptions where it is required to use prefixes ino and ref respectively. Structure Config Config structure can contain arbitrary data relative to the configuration of the component (timeouts, parameters, etc.). Config type must be STRUCT. Config data class must be named in the following format {ComponentName}Config (e.g. AxoCylinderConfig) Config class must be accessible via GetConfig method that returns REF_TO {ComponentName}Config. The backing field of the Config property must be named Config (it must be public to allow access from higher level application) Config class can contain multiple nested and complex classes when it is necessary to organize better the information. Nested classes must be CLASS and must be named in the following format {ComponentName}Config{Specifier} where specifier is descriptive name of the nested information. Wherever possible the data must be initialized to default values (e.g., timeouts, speeds etc.). The default settings should not prevent the component from functioning unless there is a specific requirement to provide parameters relative to the component model or a particular hardware configuration (drive model, gearing ratio, etc.). Each data member of the Config structure must be documented in the code, with an example. Whenever possible, a link to more detailed documentation must also be provided in the in-code documentation. Method SetConfig should be implemented when it is expected an external provision of configuration at runtime. Status Status class can contain arbitrary data relative to the state of the component. Status type must be CLASS. Status data structure must be named in the following format {ComponentName}Status (e.g. AxoCylinderStatus) Status structure must be accessible via GetStatus method that returns RET_TO {ComponentName}Status. - The backing field of the Status must be named Status (it must be public to allow access from higher level application). Status class can contain multiple nested and complex classes when it is necessary to organize the information. Nested structures must be CLASSEs and must be named in the following format {ComponentName}State{Specifier} where specifier is descriptive name of the nested information. Each data member of the Status structure must be documented in the code, with an example. Whenever possible, a link to more detailed documentation must also be provided in the in-code documentation. Tasks Operations are run by tasks (AxoTask). Member variable of the task must have the following format {OperationName}Task. Each task must be exposed via a method in the following format {OperationName} that will return IAxoTaskStatus. Executing logic of a task is run from the Run method of components class. States States are properties or methods that retrieve information about arbitrary states that do not require multiple cycles to return the result (sensor's signal state). All state-related members must be placed into States folder of the component. Component requirements Each component must inherit from AXOpen.Core.AxoComponent, which is an abstract block that requires concrete implementation of following memebers: Restore() method that restores the component into intial state and ManualControl() method that provided additional logic for manual control. Restore() must contain logic that will bring the component's internal states into the initial state. Restore method does not mean getting the component into physical ground position/state; it serves purely the purpose of having the component ready for operations from the programatic perspective. ManualControl() method is required to be implemented. It can contain arbitrary logic that will be executed while the component is in a serviceable state. Each component must implement Run method that will provide cyclic execution of tasks, I/O update, data transformation for given component. Run method is not formally required by AxoComponent and it can take arguments necessary for the cylic update and execution. For variaous scenarions component can implement different Run methods taking advantage of method overload. Components naming conventions The components for particular components are placed into appropriate library. Library name reflects the name of the manufacturer and the class of the product. POUs that belongs to a specific component reflect the product name and products' version information. UNIT NAME PATTERN EXAMPLE (fully qualified name) Library (namespace) AXOpen.{Manufacturer}.[{Group}] AXOpen.ABB.Robotics CLASS v_{ModelVersion}.Axo{Model} AXOpen.ABB.Robotics.v_1_0_0.AxoOmnicore CLASS Config v_{ModelVersion}.Axo{Model}_Config AXOpen.ABB.Robotics.v_1_0_0.AxoOmnicore_Config CLASS Status v_{ModelVersion}.Axo{Model}_Status AXOpen.ABB.Robotics.v_1_0_0.AxoOmnicore_Status other v_{ModelVersion}.Axo{Model}_{DescriptiveName} AXOpen.ABB.Robotics.v_1_0_0.AxoOmnicore_Aux Testing requirements Each public and protected controller's method must be unit-tested using axunit. When reasonable use integration testing using prober library to test the interaction between controller and .NET twin. Documentation requirements Public classes Public and protected members (methods, fields) must have in code documentation. See Documentation comments for more details and docfx markup. Public methods than implement actions and initialization must have application examples (should be referenced from the actuall app code). PLC Application examples should be placed in app/src/Documentation/ of the library folder, the code should be compilable and functional to the extent it is possible with ommited hardware. NET twin examples should be places in app/ix-blazor and app/ix folder. For details how to reference code snippet see here. AXOpenCognexVision The AXOpenCognexVision library controls and operates the vision devices from the manufacturer Cognex. VERSIONS AXOpenCognexVision The AXOpenCognexVision library controls and operates the vision devices from the manufacturer Cognex. AxoDataman AxoDataman provides the essential control and operation of all code-reader of the Dataman family. Implementation The AxoDataman is designed to be used as a member of the AxoContext or AxoObject. Therefore its instance must be initialized with the proper AxoContext or AxoObject before any use. Also, the hardware signals must be assigned first before calling any method of this instance. To accomplish this, call the Run method cyclically with the proper variables (i.e. inside the Main method of the relevant AxoContext) as in the example below: Example of the initialization and hardware signal assignement MyDataman1.Run( parent := THIS, refAcquisitionControl := REF(PlcOutputs^._10a1_Acquisition_Control_1), refAcquisitionStatus := REF(PlcInputs^._10a1_Acquisition_Status_1), refResultsControl := REF(PlcOutputs^._10a1_Results_Control_1), refResultsStatus := REF(PlcInputs^._10a1_Results_Status_1), refSoftEventControl := REF(PlcOutputs^._10a1_Soft_Event_Control_1), refSoftEventStatus := REF(PlcInputs^._10a1_Soft_Event_Control_1), refResultData := REF(PlcInputs^._10a1_Result_Data_128_bytes_1), refUserData := REF(PlcOutputs^._10a1_User_Data_128_bytes_1)); There are three public methods to operate the AxoDataman: Restore - restores the state of the AxoDataman to the initial state and resets all the internal variables. ClearResultData - resets the data read and confirms the data received from the device. Example of using ClearResultData method IF MyDataman1.ClearResultData().IsDone() THEN //Data inside MyDataman1.Results.Data is cleared ; END_IF; Read - triggers the reading sequence and waits for results. Example of using Read method IF MyDataman1.Read().IsDone() THEN //Process the result data myString := MyDataman1.Results.Data; END_IF;"
  },
  "articles/configuration/README.html": {
    "href": "articles/configuration/README.html",
    "title": "How to configure Blazor server for Siemens panel | System.Dynamic.ExpandoObject",
    "keywords": "How to configure Blazor server for Siemens panel To configure Blazor Server, you need to follow these two steps: 1. Change the default IP Address To modify the IP address of the website, you have two options: In Program.cs Inside the Program.cs file, add the following lines to specify the URLs: builder.WebHost.UseUrls(\"http://10.10.10.198:5262;https://10.10.10.198:7292\"); or builder.WebHost.UseUrls(\"http://*:5262;https://*:7292\"); In launchSettings.json Open the launchSettings.json file and modify the 'applicationUrl' under the profiles section. For example: \"applicationUrl\": \"http://10.10.10.198:5262;https://10.10.10.198:7292\" Please note that the IP address corresponds to the IP address of your network adapter. 2. Add rules to the firewall Follow these steps to add rules for the desired ports in the Windows Defender Firewall: Go to Control Panel > Windows Defender Firewall > Advanced Settings In the Inbound Rules section, add the rules for the ports you wish to use. If you are using Eset, you should perform the following steps: Navigate to Eset > Setup > Network > Click on settings next to Firewall > Configure. Check the option `Also evaluate rules from Windows Firewall`` or add the rule directly in Eset. If you using Eset you need to: Eset > Setup > Network > click on settings next to Firewall > Configure Warning If you intend to use HTTPS with a self-signed SSL certificate, make sure to adjust the DeveloperSettings.BypassSSLCertificate attribute in Program.cs to true, before start your application. Here's an example of how to do it: DeveloperSettings.BypassSSLCertificate = false;"
  },
  "articles/core/AXOALERTDIALOG.html": {
    "href": "articles/core/AXOALERTDIALOG.html",
    "title": "AlertDialog | System.Dynamic.ExpandoObject",
    "keywords": "AlertDialog The AlertDialog class provides a notification mechanism in application in form of toasts. In-app usage Alerts dialogs can be simply called anywhere from application by injecting IAlertDialogService and calling AddAlertDialog(type, title, message, time) method. Note IAlertDialogService is a scoped service, therefore alerts are unique to each client and are not synchronized. Make sure your Blazor application references axopen_core_blazor project and AxoCore services are added to builder in Program.cs file. builder.Services.AddAxoCoreServices(); Add AxoAlertToast instance to MainLayout.razor file. @using AXOpen.Core.Blazor.AxoAlertDialog <div class=\"page\"> <main> <TopRow /> <article class=\"content px-4\"> @Body </article> </main> <NavMenu /> <AxoAlertToast/> </div> Inject IAlertDialogService into you Blazor component @inject IAlertDialogService _alerts Invoke notification toast from your Blazor view _alertDialogService.AddAlertDialog(type, title, message, time); Where: type: eAlertDialogType enum representing visualization type: Undefined Info Success Danger Warning title: Refers to the header of alert message: Corresponds to the message time: Specifies the duration in seconds for which the alert will be displayed Invoking alerts from PLC Alerts can be invoked from PLC similarly like AxoDialog, however there is no need for user interaction. VAR PUBLIC _alertDialog : AXOpen.Core.AxoAlertDialog; END_VAR //... IF(_alertDialog.Show(THIS) .WithTitle('Plc alert') .WithType(eDialogType#Success) .WithMessage('This is alert invoked from plc!') .WithTimeToBurn(UINT#5).IsShown() = true) THEN //when task is done, move next THIS.MoveNext(); END_IF; Note Alerts invoked from PLC are synchronized across clients. Make sure your Blazor application references axopen_core_blazor project and AxoCore services are added to builder in Program.cs file. Make sure your MainLayout.razor file contains instance of <AxoAlertToast/> component. Add AxoAlertDialogLocator with provided list of observed objects to your view. You can add it either to: MainLayout.razor file, where in consequence alerts will be displayed and synchronized across whole application. Your own razor file, where alerts will be synchronized across multiple clients but only displayed within that specific razor page. Note Make sure, that exist only one instance of AxoAlertDialogLocator either in MainLayout.razor or in your own page. <AxoAlertDialogLocator ObservedObjects=\"new[] {Entry.Plc.Context.PneumaticManipulator}\"/>"
  },
  "articles/core/AXOCOMPONENT.html": {
    "href": "articles/core/AXOCOMPONENT.html",
    "title": "AxoComponent | System.Dynamic.ExpandoObject",
    "keywords": "AxoComponent AxoComponent is an abstract class extending the AxoObject, and it is the base building block for the \"hardware-related devices\" like a pneumatic piston, servo drive, robot, etc., so as for the, let's say, \"virtual devices\" like counter, database, etc. AxoComponent is designed to group all possible methods, tasks, settings, and status information into one consistent class. As the AxoComponent is an abstract class, it cannot be instantiated and must be extended. In the extended class, two methods are mandatory. Restore() - inside this method, the logic for resetting the AxoComponent or restoring it from any state to its initial state should be placed. ManualControl() - inside this method, the logic for manual operations with the component should be placed. To be able to control the AxoComponent instance manually, the method ActivateManualControl() of this instance needs to be called cyclically. The base class contains two additional method to deal with the manual control of the AxoComponent. ActivateManualControl() - when this method is called cyclically, the AxoComponent changes its behavior to manually controllable and ensure the call of the ManualControl() method in the derived class. IsManuallyControllable() -returns TRUE when the AxoComponent is manually controllable. Layout attributes ComponentHeader and ComponentDetails The visual view of the extended AxoComponent on the UI side could be done both ways. Manually with complete control over the design or by using the auto-rendering mechanism of the RenderableContentControl (TODO add a link to docu of the RenderableContentControl) element, which is, in most cases, more than perfect. To take full advantage of the auto-rendering mechanism, the base class has implemented the additional layout attributes ComponentHeader and ComponentDetails(TabName). The auto-rendered view is divided into two parts: the fAxoed one and the expandable one. All AxoComponent members with the ComponentHeader layout attribute defined will be displayed in the fixed part. All members with the ComponentDetails(TabName) layout attribute defined will be displayed in the expandable part inside the TabControl with \"TabName\". All members are added in the order in which they are defined, taking into account their layout attributes like Container(Layout.Wrap) or Container(Layout.Stack). How to implement AxoComponent Example of the implementation very simple AxoComponent with members placed only inside the Header. {#ix-attr:[Container(Layout.Stack)]} {#ix-set:AttributeName = \"AxoComponent with header only example\"} CLASS PUBLIC AxoComponentHeaderOnlyExample EXTENDS AXOpen.Core.AxoComponent METHOD PROTECTED OVERRIDE Restore: IAxoTask // Some logic for Restore could be placed here. For Example: valueReal := REAL#1.0; valueDint := DINT#0; END_METHOD METHOD PROTECTED OVERRIDE ManualControl // Some logic for manual control could be placed here. ; END_METHOD // Main method of the `AxoComponent` that must be // called inside the `AxoContext` cyclically. METHOD PUBLIC Run // Declaration of the input and output variables. // In the case of \"hardware-related\" `AxoComponent`, // these would be the variables linked to the hardware. VAR_INPUT inReal : REAL; inDint : DINT; END_VAR VAR_OUTPUT outReal : REAL; outDint : DINT; END_VAR // This must be called first. SUPER.Open(); // Place the custom logic here. valueReal := valueReal * inReal; valueDint := valueDint + inDint; outReal := valueReal; outDint := valueDint; END_METHOD VAR PUBLIC {#ix-attr:[Container(Layout.Wrap)]} {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Real product value\"} valueReal : REAL := REAL#1.0; {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Dint sum value\"} valueDint : DINT:= DINT#0; END_VAR END_CLASS How to use AxoComponent The instance of the extended AxoComponent must be defined inside the AxoContext. CLASS ComponentHeaderOnlyExampleContext EXTENDS AxoContext VAR PUBLIC {#ix-set:AttributeName = \"Very simple component example with header only defined\"} MyComponentWithHeaderOnly : AxoComponentHeaderOnlyExample; {#ix-set:AttributeName = \"<#Activate manual control#>\"} ActivateManualControl : BOOL; inHwReal : REAL := REAL#1.0001; inHwDint : DINT := DINT#1; outHwReal : REAL; outHwDint : DINT; END_VAR METHOD PROTECTED OVERRIDE Main // The `Initialize()` method must be called before any other method. MyComponentWithHeaderOnly.Initialize(THIS); // Example of the activation of the manual control. IF ActivateManualControl THEN MyComponentWithHeaderOnly.ActivateManualControl(); END_IF; // Calling the main method `Run` with respective input and output variables. MyComponentWithHeaderOnly.Run(inReal := inHwReal, inDint := inHwDint, outReal => outHwReal, outDint => outHwDint); END_METHOD END_CLASS Inside the Main() method of the related AxoContext following rules must be applied. The Initialize() method of the extended instance of the AxoComponent must be called first. The Run() method with the respective input and output variables must be called afterwards. How to visualize AxoComponent On the UI side use the RenderableContentControl and set its Context according the placement of the instance of the AxoComponent. <RenderableContentControl Context=\"@Entry.Plc.myComponentHeaderOnlyExample.MyComponentWithHeaderOnly\" Presentation=\"Command\" /> The rendered result should then looks as follows: In case of more complex AxoComponent the most important members should be placed in the fixed part (Header) and the rest of the members should be placed inside the expandable part (Details). The members inside the expandable part should be organize inside the tabs. More complex AxoComponent Example of the implementation more complex AxoComponent with members placed also in several tabs inside the expandable part (Details). {#ix-attr:[Container(Layout.Stack)]} {#ix-set:AttributeName = \"AxoComponent example name\"} CLASS PUBLIC AxoComponentExample EXTENDS AXOpen.Core.AxoComponent METHOD PROTECTED OVERRIDE Restore: IAxoTask ; END_METHOD METHOD PROTECTED OVERRIDE ManualControl ; END_METHOD METHOD PUBLIC Run VAR_INPUT inReal : REAL; inDint : DINT; END_VAR VAR_OUTPUT outReal : REAL; outDint : DINT; END_VAR // This must be called first. SUPER.Open(); // Place the custom logic here. Status.SomeStatusValue1 := Status.SomeStatusValue1 * inReal; Status.SomeStatusValue2 := Status.SomeStatusValue2 + inDint; outReal := Status.SomeStatusValue1; outDint := Status.SomeStatusValue2; END_METHOD VAR PUBLIC // Complete structure as a part of the component header. // All structure members are going to be displayed in the component header. {#ix-attr:[Container(Layout.Wrap)]} {#ix-attr:[ComponentHeader()]} Header : Header_ComponentExample; // Two separate tasks as a part of the component header. // These tasks are going to be added to the previous members of the component header. {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Header task 1\"} HeaderTask1 : AxoTask; // Complete structure as a part of the component details tab `Tasks`. // All structure members are going to be added to the previous members of the component details tab `Tasks`. {#ix-set:AttributeName = \"Tasks\"} {#ix-attr:[Container(Layout.Stack)]} Tasks : Tasks_ComponentExample; // Single task as a part of the component details tab `Tasks`. // This task is going to be displayed in the component details tab `Tasks` {#ix-attr:[ComponentDetails(\"Tasks\")]} {#ix-attr:[Container(Layout.Stack)]} {#ix-set:AttributeName = \"Detail task in Tasks tab\"} DetailTaskInTasksTab : AxoTask; // Additional separate task as a part of the component header. // This task is going to be added to the previous members of the component header. {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Header task 2\"} HeaderTask2 : AxoTask; // Complete structure as a part of the component details tab `Status` as the attribute [ComponentDetails(\"Status\")] // is defined on the class Status_ComponentExample. // All structure members are going to be added to the previous members of the component details tab `Status`. {#ix-set:AttributeName = \"Status class\"} Status :Status_ComponentExample; // Single variable as a part of the component details tab `Status`. // This variable is going to be added to the previous members of the component details tab `Status`. {#ix-attr:[ComponentDetails(\"Status\")]} {#ix-attr:[Container(Layout.Stack)]} {#ix-set:AttributeName = \"Status string\"} Status2 : string; // Additional separate task as a part of the component header. // This task is going to be added to the previous members of the component header. {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Header task 3\"} HeaderTask3 : AxoTask; // Complete structure as a part of the component details tab `Settings` as the attribute [ComponentDetails(\"Settings\")] // is defined on the class Settings_ComponentExample. // All structure members are going to be added to the previous members of the component details tab `Settings`. {#ix-set:AttributeName = \"Settings\"} Settings : Settings_ComponentExample; // Complete structure as a part of the component details tab `Diagnostics` as the attribute [ComponentDetails(\"Diagnostics\")] // is defined on the class Diagnostics_ComponentExample. git // All structure members are going to be added to the previous members of the component details tab `Diagnostics`. {#ix-set:AttributeName = \"Diagnostics\"} Diagnostics : Diagnostics_ComponentExample; // Complete structure as a part of the component details tab `Help` as the attribute [ComponentDetails(\"Help\")] // is defined on the class Help_ComponentExample. // All structure members are going to be added to the previous members of the component details tab `Help`. {#ix-set:AttributeName = \"Help\"} Help : Help_ComponentExample; END_VAR END_CLASS For the complex types of the AxoComponent it is also recomended to organize partial groups of the members into the classes as it is in this example. CLASS PUBLIC Header_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Start\"} Start : AxoTask; {#ix-set:AttributeName = \"Stop\"} Stop : AxoTask; {#ix-set:AttributeName = \"Status\"} Status : STRING:='Some status description'; END_VAR END_CLASS {#ix-attr:[Container(Layout.Stack)]} {#ix-attr:[ComponentDetails(\"Tasks\")]} CLASS PUBLIC Tasks_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some status value 1\"} SomeStatusValue1 : REAL := REAL#45.3; {#ix-set:AttributeName = \"Some advanced component task 1\"} SomeAdvancedComponentTask1 : AxoTask; {#ix-set:AttributeName = \"Some advanced component task 2\"} SomeAdvancedComponentTask2 : AxoTask; {#ix-set:AttributeName = \"Some advanced component task 3\"} SomeAdvancedComponentTask3 : AxoTask; {#ix-set:AttributeName = \"Some advanced component task 4\"} SomeAdvancedComponentTask4 : AxoTask; {#ix-set:AttributeName = \"Some advanced component task 5\"} SomeAdvancedComponentTask5 : AxoTask; END_VAR END_CLASS {#ix-attr:[Container(Layout.Stack)]} {#ix-attr:[ComponentDetails(\"Status\")]} CLASS PUBLIC Status_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some status value 1\"} SomeStatusValue1 : REAL := REAL#45.3; {#ix-set:AttributeName = \"Some status value 2\"} SomeStatusValue2 : DINT := DINT#46587; {#ix-set:AttributeName = \"Some status value 3\"} SomeStatusValue3 : STRING := 'some description'; END_VAR END_CLASS {#ix-attr:[ComponentDetails(\"Settings\")]} {#ix-attr:[Container(Layout.Stack)]} CLASS PUBLIC Settings_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some setting value 1\"} SomeSettingValue1 : REAL := REAL#45.3; {#ix-set:AttributeName = \"Some setting value 2\"} SomeSettingValue2 : DINT := DINT#46587; {#ix-set:AttributeName = \"Some setting value 3\"} SomeSettingValue3 : STRING := 'some setting'; END_VAR END_CLASS {#ix-attr:[ComponentDetails(\"Diagnostics\")]} {#ix-attr:[Container(Layout.Stack)]} CLASS PUBLIC Diagnostics_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some diagnostic message\"} SomeDiagnosticMessage : STRING := 'TODO: Some diagnostic message needs to be placed here'; END_VAR END_CLASS {#ix-attr:[ComponentDetails(\"Help\")]} {#ix-attr:[Container(Layout.Stack)]} CLASS PUBLIC Help_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some help\"} SomeHelp : STRING := 'TODO: Provide some help'; END_VAR END_CLASS Instantiate and call the AxoComponent instance. CLASS ComponentExampleContext EXTENDS AxoContext VAR PUBLIC {#ix-set:AttributeName = \"Component example name\"} MyComponent : AxoComponentExample; {#ix-set:AttributeName = \"<#Activate manual control#>\"} ActivateManualControl : BOOL; inHwReal : REAL := REAL#1.0001; inHwDint : DINT := DINT#1; outHwReal : REAL; outHwDint : DINT; END_VAR METHOD PROTECTED OVERRIDE Main // The `Initialize()` method must be called before any other method. MyComponent.Initialize(THIS); // Example of the activation of the manual control. IF ActivateManualControl THEN MyComponent.ActivateManualControl(); END_IF; // Calling the main method `Run` with respective input and output variables. MyComponent.Run(inReal := inHwReal, inDint := inHwDint, outReal => outHwReal, outDint => outHwDint); END_METHOD END_CLASS UI side of the AxoComponent. <RenderableContentControl Context=\"@Entry.Plc.myComponentExample.MyComponent\" Presentation=\"Command\" /> and the rendered result: Alarm Level AxoComponent provides visual indicators to represent different alarm levels. Below is an explanation of each alarm level and its corresponding visual indicator. 1. No Alarms Description: No active alarms or messages are present. Icon: There's no visual indicator for this state. 2. Unacknowledged Description: There are messages that are waiting for acknowledgment. 3. Active Info Description: Active informational messages are present. 4. Active Warnings Description: Active warning messages are present. 5. Active Errors Description: Active error messages are present."
  },
  "articles/core/AXOCONTEXT.html": {
    "href": "articles/core/AXOCONTEXT.html",
    "title": "AxoContext | System.Dynamic.ExpandoObject",
    "keywords": "AxoContext AxoContext encapsulates entire application or application units. Any solution may contain one or more contexts, however the each should be considered to be an isolated island and any direct inter-context access to members must be avoided. Note Each AxoContext must belong to a single PLC task.Multiple AxoContexts can be however running on the same task. classDiagram class Context{ +Main()* +Run() } In its basic implementation AxoContext has relatively simple interface. Main is the method where we place all calls of our sub-routines. In other words the Run is the root of the call tree of our program. Run method runs the AxoContext. It must be called cyclically within a program unit that is attached to a cyclic task. Why do we need AxoContext AxoContext provides counters, object identification and other information about the execution of the program. These information is then used by the objects contained at different levels of the AxoContext. How AxoContext works When you call Run method on an instance of a AxoContext, it will ensure opening AxoContext, running Main method (root of all your program calls) and AxoContext closing. flowchart LR classDef run fill:#80FF00,stroke:#0080FF,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold classDef main fill:#ff8000,stroke:#0080ff,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold id1(Open):::run-->id2(#Main*):::main-->id3(Close):::run-->id1 How to use AxoContext Base class for the AxoContext is AXOpen.Core.AxoContext. The entry point of call execution of the AxoContext is Main method. Notice that the AxoContext class is abstract and cannot be instantiated if not extended. Main method must be overridden in derived class notice the use of override keyword and also that the method is protected which means the it is visible only from within the AxoContext and derived classes. How to extend AxoContext class CLASS PUBLIC AxoContextExample EXTENDS AXOpen.Core.AxoContext METHOD PROTECTED OVERRIDE Main // Here goes all your logic for given AxoContext. ; END_METHOD END_CLASS Cyclical call of the AxoContext logic (Main method) is ensured when AxoContext Run method is called. Run method is public therefore accessible and visible to any part of the program that whishes to call it. How to start AxoContext's execution PROGRAM ProgramExample VAR MyContext : AxoContextExample; END_VAR MyContext.Run(); END_PROGRAM"
  },
  "articles/core/AXODIALOG.html": {
    "href": "articles/core/AXODIALOG.html",
    "title": "AxoDialogs | System.Dynamic.ExpandoObject",
    "keywords": "AxoDialogs AxoDialogs provide capability to interact with the user by rising dialogs directly from the PLC program. Example VAR PUBLIC _dialog : AXOpen.Core.AxoDialog; END_VAR //---------------------------------------------- IF(_dialog.Show(THIS) .WithOk() .WithType(eDialogType#Success) .WithCaption('What`s next?') .WithText('To continue click OK?').Answer() = eDialogAnswer#OK) THEN //if answer is ok, move next in sequence THIS.MoveNext(); END_IF; Getting started Make sure your Blazor application references axopen_core_blazor project and AxoCore services are added to builder in Program.cs file. Also, map dialoghub which is needed for dialog synchronization using SignalR technology. builder.Services.AddAxoCoreServices(); //... app.MapHub<DialogHub>(\"/dialoghub\"); Go to your page, where you wish to have dialogs and include AxoDialogLocator component at the end of that page. Provide list of ObservedObjects, on which you want to observe dialogs. You can also provide DialogId, which serves for synchronization of dialogs between multiple clients. If DialogId is not provided, the current URI is used as an id. Important Make sure, that each page has only one instance of AxoDialogLocator and that provided DialogId is unique across the application! If you wish to observe multiple objects, add them into ObservedObjects list. <AxoDialogLocator DialogId=\"custation001\" ObservedObjects=\"new[] {Entry.Plc.Context.PneumaticManipulator}\"/> Now, when dialog is invoked in PLC, it will show on all clients and pages, where AxoDialogLocator is present with corresponding observed objects. The answers are synchronized across multiple clients. AxoDialog types AxoDialogs contains currently 3 types of predefined dialogs: Okay dialog YesNo dialog YesNoCancel dialog Also, the visual type of corresponding dialog can be adjusted with eDialogType enum, which is defined as follows: eDialogType : INT ( Undefined := 0, Info := 10, Success := 20, Danger := 30, Warning := 40 ); Answer synchronization on multiple clients Answers of dialogs are synchronized across multiple clients with the SignalR technology. Closing a dialog with external signal External signals can be provided to dialog instance within a ShowWithExternalClose method, which can be then used to close dialog externally (for example from other page of application, or by pressing a hardware button...). 4 different signals can be monitored in ShowWithExternalClose method: inOkAnswerSignal inYesAnswerSignal inNoAnswerSignal inCancelAnswerSignal Below is an example of closing dialog with _externalCloseOkSignal bool variable, which is set in other part of application: VAR PUBLIC _dialog : AXOpen.Core.AxoDialog; _externalCloseOkSignal : BOOL; _dialogAnswer : eDialogAnswer; END_VAR //---------------------------------------------- _dialogAnswer := _dialog.ShowWithExternalClose(THIS, _externalCloseOkSignal) .WithOK() .WithType(eDialogType#Info) .WithCaption('Hello world!') .WithText('You can also close me externally!').Answer(); IF(_dialog3Answer = eDialogAnswer#Ok) THEN // if answer is provided, move next THIS.MoveNext(); END_IF; Creation of own modal dialog PLC side Create own PLC instance of dialog, which extends AxoDialogBase. Define dialog structure and corresponding show method, which will initialize and invoke remote task needed for dialog creation. Blazor side Define Blazor view of modal dialog, which is then generated by RenderableContentControl according to presentation pipeline. For example, when Dialog plc type is MyCustomModal, the view must by named MyCustomModalDialogView, because implementation is using Dialog presentation type. The Blazor view must inherits from @AxoDialogBaseView<MyCustomModal>, where correct generic type of dialog from PLC must be passed. The opening/closing of dialog is managed in base class by virtual methods, which can be overridden if needed. It is recommended to use provided ModalDialog Blazor component, which can be customized by user needs and is fully compatible with closing/opening synchronization approach provided in base class. Otherwise, the open/close virtual methods from base class must be overridden and accordingly adapted. Example implementation of basic dialog can be found in AxoDialogDialogView.razor."
  },
  "articles/core/AXOMOMENTARYTASK.html": {
    "href": "articles/core/AXOMOMENTARYTASK.html",
    "title": "AxoMomentaryTask | System.Dynamic.ExpandoObject",
    "keywords": "AxoMomentaryTask AxoMomentaryTask provides basic momentary function. It is mainly designed for some manual operations from the UI side. AxoMomentaryTask needs to be initialized to set the proper AxoContext. AxoMomentaryTask initialization within a AxoContext CLASS AxoMomentaryTaskDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:AttributeName = \"<#Momentary task example#>\"} {#ix-set:AttributeStateOnDesc = \"<#Currently On#>\"} {#ix-set:AttributeStateOffDesc = \"<#Currently Off#>\"} _myMomentaryTask : AxoMomentaryTask; END_VAR METHOD PUBLIC Initialize // Initialization of the context needs to be called first // It does not need to be called cyclically, just once _myMomentaryTask.Initialize(THIS); END_METHOD END_CLASS To check the state of the task there are two methods: IsSwitchOn() - returns TRUE if the state of the task is TRUE. IsSwitchOff() - returns TRUE if the state of the task is FALSE. Example of using IsSwitchOn() method: IF _myMomentaryTask.IsSwitchedOn() THEN ; // do something END_IF; Example of using IsSwitchOff() method: IF _myMomentaryTask.IsSwitchedOff() THEN ; // do something END_IF; Moreover, there are five more \"event-like\" methods that are called when a specific event occurs (see the chart below). To implement any of the already mentioned \"event-like\" methods the new class that extends from the AxoMomentaryTask needs to be created. The required method with PROTECTED OVERRIDE access modifier needs to be created as well, and the custom logic needs to be placed in. These methods are: OnSwitchedOn() - executes once when the task changes its state from FALSE to TRUE. OnSwitchedOff() - executes once when the task changes its state from TRUE to FALSE. OnStateChanged() - executes once when the task changes its state. SwitchedOn() - executes repeatedly while the task is in TRUE state. SwitchedOff() - executes repeatedly while the task is in FALSE state. Example of implementing \"event-like\" methods: CLASS MyMomentaryTaskExample Extends AxoMomentaryTask VAR OnSwitchedOnCounter : ULINT; OnSwitchedOffCounter : ULINT; OnStateChangedCounter : ULINT; SwitchOnExecutionCounter : ULINT; SwitchOffExecutionCounter : ULINT; END_VAR METHOD PROTECTED OVERRIDE OnSwitchedOn OnSwitchedOnCounter := OnSwitchedOnCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnSwitchedOff OnSwitchedOffCounter := OnSwitchedOffCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnStateChanged OnStateChangedCounter := OnStateChangedCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE SwitchedOn SwitchOnExecutionCounter := SwitchOnExecutionCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE SwitchedOff SwitchOffExecutionCounter := SwitchOffExecutionCounter + ULINT#1; END_METHOD END_CLASS How to visualize AxoMomentaryTask On the UI side there are several possibilities how to visualize the AxoMomentaryTask. You use the AxoMomentaryTaskView and set its Component according the placement of the instance of the AxoMomentaryTask. Based on the value of Disable the control element could be controllable: <AxoMomentaryTaskView Component=\"@Entry.Plc.AxoMomentaryTaskDocu._myMomentaryTask\" Disable=\"false\" /> or display only: <AxoMomentaryTaskView Component=\"@Entry.Plc.AxoMomentaryTaskDocu._myMomentaryTask\" Disable=\"true\" /> The next possibility is to use the RenderableContentControl and set its Context according the placement of the instance of the AxoMomentaryTask. Again as before the element could be controlable when the value of the Presentation is Command: <RenderableContentControl Context=\"@Entry.Plc.AxoMomentaryTaskDocu._myMomentaryTask\" Presentation=\"Command\" /> or display only when the value of the Presentation is Status <RenderableContentControl Context=\"@Entry.Plc.AxoMomentaryTaskDocu._myMomentaryTask\" Presentation=\"Status\" /> The displayed result should looks like:"
  },
  "articles/core/AXOOBJECT.html": {
    "href": "articles/core/AXOOBJECT.html",
    "title": "AxoObject | System.Dynamic.ExpandoObject",
    "keywords": "AxoObject AxoObject is the base class for any other classes of AXOpen.Core. It provides access to the parent AxoObject and the AxoContext in which it was initialized. classDiagram class Object{ +Initialize(IAxoContext context) +Initialize(IAxoObject parent) } AxoObject initialization within a AxoContext CLASS PUBLIC MyContext EXTENDS AXOpen.Core.AxoContext VAR _myObject : AxoObject; END_VAR METHOD PROTECTED OVERRIDE Main _myObject.Initialize(THIS); END_METHOD END_CLASS AxoObject initialization within another AxoObject CLASS PUBLIC MyParentObject EXTENDS AxoContext VAR _myChildObject : AxoObject; END_VAR METHOD PROTECTED OVERRIDE Main _myChildObject.Initialize(THIS); END_METHOD END_CLASS"
  },
  "articles/core/AXOREMOTETASK.html": {
    "href": "articles/core/AXOREMOTETASK.html",
    "title": "AxoRemoteTask | System.Dynamic.ExpandoObject",
    "keywords": "AxoRemoteTask AxoRemoteTask provides task execution, where the execution of the task is deferred to .NET environment. AxoRemoteTask derives from AxoTask. AxoRemoteTask needs to be initialized to set the proper AxoContext. Important The deferred execution in .NET environment is not hard-real time nor deterministic. You would typically use the AxoRemoteTask when it would be hard to achieve a goal in the PLC, but you can delegate the access to the non-hard-real and nondeterministic environment. Examples of such use would be database access, complex calculations, and email sending. AxoTask initialization within a AxoContext _remoteTask.Initialize(THIS); // THIS = IAxoContext There are two key methods for managing the AxoRemoteTask: Invoke() fires the execution of the AxoRemoteTask (can be called fire&forget or cyclically) Execute() method must be called cyclically. In contrast to AxoTask the method does not execute any logic. You will need to call the Execute method cyclically which will deffer the logic execution in .NET environment. There are the following differences in behavior of DoneWhen and ThrowWhen methods: DoneWhen(Done_Condition) - Unlike AxoTask Done condition is handled internally. It does not have an effect. ThrowWhen(Error_Condition) - Unlike AxoTask Exception emission is handled internally. It does not have an effect. For termination of the execution of the AxoRemoteTask there are the following methods: Abort() - terminates the execution of the AxoRemoteTask and enters the Ready state if the AxoRemoteTask is in the Busy state; otherwise does nothing. To reset the AxoRemoteTask from any state at any moment, there is the following method: Restore() acts as a reset of the AxoRemoteTask (sets the state into Ready from any state of the AxoRemoteTask). The AxoRemoteTask executes upon the Invoke method call. Invoke fires the execution of Execute logic upon the first call, and Invoke does not need cyclical calling. _remoteTask.Invoke('hello'); Invoke() method returns IAxoTaskState with the following members: IsBusy indicates the execution started and is running. IsDone indicates the execution completed with success. HasError indicates the execution terminated with a failure. IsAborted indicates that the execution of the AxoRemoteTask has been aborted. It should continue by calling the method Resume(). Task initialization in .NET Entry.Plc.AxoRemoteTasks._remoteTask.Initialize(() => Console.WriteLine($\"Remote task executed PLC sent this string: '{Entry.Plc.AxoRemoteTasks._remoteTask.Message.GetAsync().Result}'\")); In this example, when the PLC invokes this task it will write a message into console. You can use arbitrary code in place of the labmda expression. Executing from PLC Invoking the AxoRemoteTask and waiting for its completion at the same place. IF(_remoteTask.Invoke('hello').IsDone()) THEN _doneCounter := _doneCounter + 1; END_IF; Invoking the AxoRemoteTask and waiting for its completion at the different places. // Fire & Forget _remoteTask.Invoke('hello'); // Wait for done somwhere else IF(_remoteTask.IsDone()) THEN _doneCounter := _doneCounter + 1; END_IF; Checking if the AxoRemoteTask is executing. IF(_remoteTask.IsBusy()) THEN ;// Do something after task started END_IF; Check for the AxoRemoteTask's error state. IF(_remoteTask.HasError()) THEN ;// Do something when an exception occurs on remote task. END_IF;"
  },
  "articles/core/AXOSEQUENCER.html": {
    "href": "articles/core/AXOSEQUENCER.html",
    "title": "AxoSequencer | System.Dynamic.ExpandoObject",
    "keywords": "AxoSequencer AxoSequencer is an AxoCordinator class provides triggering the AxoStep-s inside the sequence in the order they are written. AxoSequencer extends from AxoTask so it also has to be initialized by calling its Initialize() method and started using its Invoke() method. AxoSequencer contains following methods: Open(): this method must be called cyclically before any logic. All the logic of the sequencers must be placed inside the if condition. It provides some configuration mechanism that ensures that the steps are going to be executed in the order, they are written. During the very first call of the sequence, no step is executed as the AxoSequencer is in the configuring state. From the second context cycle after the AxoSequencer has been invoked the AxoSequencer change its state to running and starts the execution from the first step upto the last one. When AxoSequencer is in running state, order of the step cannot be changed. MoveNext(): Terminates the currently executed step and moves the AxoSequencer's pointer to the next step in order of execution. RequestStep(): Terminates the currently executed step and set the AxoSequencer's pointer to the order of the RequestedStep. When the order of the RequestedStep is higher than the order of the currently finished step (the requested step is \"after\" the current one) the requested step is started in the same context cycle. When the order of the RequestedStep is lower than the order of the currently finished step (the requested step is \"before\" the current one) the requested step is started in the next context cycle. CompleteSequence(): Terminates the currently executed step, completes (finishes) the execution of this AxoSequencer and set the coordination state to Idle. If the SequenceMode of the AxoSequencer is set to Cyclic, following Open() method call in the next context cycle switch it again into the configuring state, reasign the order of the individual steps (even if the orders have been changed) and subsequently set AxoSequencer back into the running state. If the SequenceMode of the AxoSequencer is set to RunOnce, terminates also execution of the AxoSequencer itself. `GetCoordinatorState()': Returns the current state of the AxoSequencer. Idle Configuring: assigning the orders to the steps, no step is executed. Running: orders to the steps are already assigned, step is executed. SetSteppingMode(): Sets the stepping mode of the AxoSequencer. Following values are possible. None: StepByStep: if this mode is choosen, each step needs to be started by the invocation of the StepIn commmand. Continous: if this mode is choosen (default), each step is started automaticcaly after the previous one has been completed. GetSteppingMode(): Gets the current stepping mode of the AxoSequencer. SetSequenceMode(): Sets the sequence mode of the AxoSequencer. Following values are possible. None: RunOnce: if this mode is choosen, after calling the method CompleteSequence() the execution of the sequence is terminated. Cyclic: if this mode is choosen (default), after calling the method CompleteSequence() the execution of the sequence is \"reordered\" and started from beginning. GetSequenceMode(): Gets the current sequence mode of the AxoSequencer. GetNumberOfConfiguredSteps(): Gets the number of the configured steps in the sequence. Example of using AxoSequencer Example of the declaration of the AxoSequencer and AxoStep CLASS AxoSequencerDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC _mySequencer : AXOpen.Core.AxoSequencer; _step_1 : AxoStep; _step_2 : AxoStep; _step_3 : AxoStep; _myCounter : ULINT; END_VAR END_CLASS Initialization Initialization of the context needs to be called first. It does not need to be called cyclically, just once. METHOD PUBLIC Initialize _mySequencer.Initialize(THIS); _step_1.Initialize(THIS); _step_2.Initialize(THIS); _step_3.Initialize(THIS); END_METHOD Open The Open() method must be called cyclically before any logic. All the logic of the sequencers must be placed inside the if condition, as follows. THIS.Initialize(); IF _mySequencer.Open() THEN //All sequence logic needs to be placed inside the condition _myCounter := _myCounter + ULINT#1; IF _step_1.Execute(_mySequencer) THEN IF (_myCounter > ULINT#50) THEN _mySequencer.MoveNext(); END_IF; END_IF; IF _step_2.Execute(_mySequencer) THEN IF (_myCounter > ULINT#100) THEN _mySequencer.MoveNext(); END_IF; END_IF; IF _step_3.Execute(_mySequencer) THEN IF (_myCounter > ULINT#150) THEN _myCounter := ULINT#0; _mySequencer.CompleteSequence(); END_IF; END_IF; END_IF; Step Example of the most simple use of the Execute() method of the AxoStep class, only with the AxoCoordinator defined. IF _step_1.Execute(_mySequencer) THEN _myCounter := _myCounter + ULINT#1; // do something IF (_myCounter MOD ULINT#5) = ULINT#0 THEN // continue to the next step of the sequence _mySequencer.MoveNext(); END_IF; END_IF; Example of use of the Execute() method of the AxoStep class with the Enable condition. This step is going to be executed just in the first run of the sequence, as during the second one, the Enable parameter will have the value of FALSE. IF _step_2.Execute(coord := _mySequencer, Enable := _myCounter <= ULINT#20) THEN _myCounter := _myCounter + ULINT#1; IF _myCounter = ULINT#20 THEN // Jumping to step 1. As it is jumping backwards, the execution of step 1 // is going to be started in the next context cycle. _mySequencer.RequestStep(_step_1); END_IF; END_IF; Example of use of the Execute() method of the AxoStep class with all three parameters defined. IF _step_3.Execute(coord := _mySequencer, Enable := TRUE, Description := 'This is a description of the step 3' ) THEN _myCounter := _myCounter + ULINT#1; IF (_myCounter MOD ULINT#7) = ULINT#0 THEN // Finalize the sequence and initiate the execution from the first step. _mySequencer.CompleteSequence(); END_IF; END_IF;"
  },
  "articles/core/AXOSEQUENCERCONTAINER.html": {
    "href": "articles/core/AXOSEQUENCERCONTAINER.html",
    "title": "AxoSequencerContainer | System.Dynamic.ExpandoObject",
    "keywords": "AxoSequencerContainer AxoSequencerContainer is an AxoCordinator class that extends from AxoSequencer. The main difference is that this class is abstract so it is not possible to instantiate it directly. The user-defined class that extends from AxoSequencerContainer needs to be created and then instantiated. In the extended class MAIN() method needs to be created and all sequencer logic needs to be placed there. Then the sequencer is called via Run(IAxoObject) or Run(IAxoContext) methods, that ensure initialization of the sequencer with AxoObject or with AxoContext. Moreover the Run() method also ensures calling the Open() method, so it is not neccessary to call it explicitelly in comparison with AxoSequencer. Example of using AxoSequencerContainer Example of the declaration of the user-defined class that extends from AxoSequencerContainer CLASS AxoSequencerContainerDocuExample EXTENDS AXOpen.Core.AxoSequencerContainer VAR PUBLIC _step_1 : AxoStep; _step_2 : AxoStep; _step_3 : AxoStep; _myCounter : ULINT; END_VAR END_CLASS Example of implementation MAIN method inside the user-defined class that extends from AxoSequencerContainer All the custom logic of the sequencer needs to be placed here. METHOD PROTECTED OVERRIDE MAIN _step_1.Initialize(THIS); _step_2.Initialize(THIS); _step_3.Initialize(THIS); _myCounter := _myCounter + ULINT#1; IF(_step_1.Execute(THIS)) THEN IF(_myCounter >= ULINT#100 ) THEN _myCounter := ULINT#0; THIS.MoveNext(); END_IF; END_IF; IF(_step_2.Execute(THIS)) THEN IF(_myCounter >= ULINT#100) THEN _myCounter := ULINT#0; THIS.MoveNext(); END_IF; END_IF; IF(_step_3.Execute(THIS)) THEN IF(_myCounter >= ULINT#100) THEN _myCounter := ULINT#0; _step_3.ThrowWhen(TRUE); THIS.CompleteSequence(); END_IF; END_IF; END_METHOD Example of declaration of the instance of the user-defined class that extends from AxoSequencerContainer VAR PUBLIC _mySequencerContainer : AxoSequencerContainerDocuExample; END_VAR Example of calling of the instance of the user-defined class that extends from AxoSequencerContainer _mySequencerContainer.Run(THIS);"
  },
  "articles/core/AXOSTEP.html": {
    "href": "articles/core/AXOSTEP.html",
    "title": "AxoStep | System.Dynamic.ExpandoObject",
    "keywords": "AxoStep AxoStep is an extension class of the AxoTask and provides the basics for the coordinated controlled execution of the task in the desired order based on the coordination mechanism used. AxoStep contains the Execute() method so as its base class overloaded and extended by following parameters: coord (mandatory): instance of the coordination controlling the execution of the AxoStep. Enable (optional): if this value is FALSE, AxoStep body is not executed and the current order of the execution is incremented. Description (optional): AxoStep description text describing the action the AxoStep is providing. AxoStep class contains following public members: Order: Order of the AxoStep in the coordination. This value can be set by calling the method SetStepOrder() and read by the method GetStepOrder(). StepDescription: AxoStep description text describing the action the AxoStep is providing. This value can be set by calling the Execute() method with Description parameter. IsActive: if TRUE, the AxoStep is currently executing, or is in the order of the execution, otherwise FALSE. This value can be set by calling the method SetIsActive() and read by the method GetIsActive(). IsEnabled: if FALSE, AxoStep body is not executed and the current order of the execution is incremented. This value can be set by calling the method SetIsEnabled() or calling the Execute() method with Enable parameter and read by the method GetIsEnabled()."
  },
  "articles/core/AXOTASK.html": {
    "href": "articles/core/AXOTASK.html",
    "title": "AxoTask | System.Dynamic.ExpandoObject",
    "keywords": "AxoTask AxoTask provides basic task execution. AxoTask needs to be initialized to set the proper AxoContext. AxoTask initialization within a AxoContext CLASS AxoTaskDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:AttributeName = \"<#Task name#>\"} _myTask : AxoTask; _myCounter : ULINT; END_VAR METHOD PUBLIC Initialize // Initialization of the context needs to be called first // It does not need to be called cyclically, just once _myTask.Initialize(THIS); END_METHOD END_CLASS There are two key methods for managing the AxoTask: Invoke() fires the execution of the AxoTask (can be called fire&forget or cyclically) Execute() method must be called cyclically. The method returns TRUE when the AxoTask is required to run until enters Done state or terminates in error. For termination of the execution of the AxoTask there are following methods: DoneWhen(Done_Condition) - terminates the execution of the AxoTask and enters the Done state when the Done_Condition is TRUE. ThrowWhen(Error_Condition) - terminates the execution of the AxoTask and enters the Error state when the Error_Condition is TRUE. Abort() - terminates the execution of the AxoTask and enters the Ready state if the AxoTask is in the Busy state, otherwise does nothing. To reset the AxoTask from any state in any moment there is following method: Restore() acts as reset of the AxoTask (sets the state into Ready state from any state of the AxoTask). Moreover, there are seven more \"event-like\" methods that are called when a specific event occurs (see the chart below). flowchart TD classDef states fill:#80FF00,stroke:#0080FF,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold classDef actions fill:#ff8000,stroke:#0080ff,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold classDef events fill:#80FF00,stroke:#0080ff,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold s1((Ready)):::states s2((Kicking)):::states s3((Busy)):::states s4((Done)):::states s5((Error)):::states s6((Aborted)):::states a1(\"Invoke()#128258;\"):::actions a2(\"Execute()#128260;\"):::actions a3(\"DoneWhen(TRUE)#128258;\"):::actions a4(\"ThrowWhen(TRUE)#128258;\"):::actions a5(\"NOT Invoke() call for at<br>least two Context cycles#128260;\"):::actions a6(\"Restore()#128258;\"):::actions a7(\"Abort()#128258;\"):::actions a8(\"Resume()#128258;\"):::actions e1{{\"OnStart()#128258;\"}}:::events e2{{\"OnError()#128258;\"}}:::events e3{{\"WhileError()#128260;\"}}:::events e4{{\"OnDone()#128258;\"}}:::events e5{{\"OnAbort()#128258;\"}}:::events e6{{\"OnRestore()#128258;\"}}:::events subgraph legend[\" \"] direction LR s((State)):::states ac(\"Action #128260;:called<br>cyclically\"):::actions as(\"Action #128258;:single<br>or cyclical call \"):::actions ec{{\"Event #128260;:called<br>cyclically\"}}:::events es{{\"Event #128258;:triggered<br>once \"}}:::events end subgraph chart[\" \"] direction TB s1 s1-->a1 a1-->s2 s2-->a2 s3-->a3 s3-->a7 a7-->e5 a7-->s6 s6-->a8 a8-->s3 a3-->s4 s4---->a5 a5-->a1 a2--->s3 s3--->a4 a4-->s5 s5-->a6 a6-->e6 a2-->e1 a4-->e2 a4-->e3 a3-->e4 a6-->s1 end Example of using AxoTask: CLASS AxoTaskDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:AttributeName = \"<#Task name#>\"} _myTask : AxoTask; _myCounter : ULINT; END_VAR METHOD PUBLIC Initialize // Initialization of the context needs to be called first // It does not need to be called cyclically, just once _myTask.Initialize(THIS); END_METHOD METHOD PROTECTED OVERRIDE Main _myTask.Initialize(THIS); // Cyclicall call of the Execute IF _myTask.Execute() THEN _myCounter := _myCounter + ULINT#1; _myTask.DoneWhen(_myCounter = ULINT#100); END_IF; IF _myTask.IsDone() THEN _myCounter := ULINT#0; END_IF; END_METHOD END_CLASS The AxoTask executes upon the Invoke method call. Invoke fires the execution of Execute logic upon the first call, and it does not need cyclical calling. _myTask.Invoke(); Invoke() method returns IAxoTaskState with the following members: IsBusy indicates the execution started and is running. IsDone indicates the execution completed with success. HasError indicates the execution terminated with a failure. IsAborted indicates that the execution of the AxoTask has been aborted. It should continue by calling the method Resume(). Examples of using: Invoking the AxoTask and waiting for its completion at the same place. IF _myTask.Invoke().IsDone() THEN ; //Do something END_IF; Invoking the AxoTask and waiting for its completion at the different places. _myTask.Invoke(); IF _myTask.IsDone() THEN ; //Do something END_IF; Checking if the AxoTask is executing. IF _myTask.Invoke().IsBusy() THEN ; //Do something END_IF; Check for the AxoTask's error state. IF _myTask.Invoke().HasError() THEN ; //Do something END_IF; The AxoTask can be started only from the Ready state by calling the Invoke() method in the same Context cycle as the Execute() method is called, regardless the order of the methods calls. After AxoTask completion, the state of the AxoTask will remain in Done, unless: 1.) AxoTask's Restore method is called (AxoTask changes it's state to Ready state). 2.) Invoke method is not called for two or more consecutive cycles of its context (that usually means the same as PLC cycle); successive call of Invoke will switch the task into the Ready state and immediately into the Kicking state. The AxoTask may finish also in an Error state. In that case, the only possibility to get out of Error state is by calling the Restore() method. To implement any of the already mentioned \"event-like\" methods the new class that extends from the AxoTask needs to be created. The required method with PROTECTED OVERRIDE access modifier needs to be created as well, and the custom logic needs to be placed in. These methods are: OnAbort() - executes once when the task is aborted. OnResume() - executes once when the task is resumed. OnDone() - executes once when the task reaches the Done state. OnError() - executes once when the task reaches the Error state. OnRestore() - executes once when the task is restored. OnStart() - executes once when the task starts (at the moment of transition from the Kicking state into the Busy state). WhileError() - executes repeatedly while the task is in Error state (and Execute() method is called). Example of implementing \"event-like\" methods: CLASS MyTaskExample EXTENDS AXOpen.Core.AxoTask VAR OnAbortCounter : ULINT; OnResumeCounter : ULINT; OnDoneCounter : ULINT; OnErrorCounter : ULINT; OnRestoreCounter : ULINT; OnStartCounter : ULINT; WhileErrorCounter : ULINT; END_VAR METHOD PROTECTED OVERRIDE OnAbort OnAbortCounter := OnAbortCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnResume OnResumeCounter := OnResumeCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnDone OnDoneCounter := OnDoneCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnError OnErrorCounter := OnErrorCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnRestore OnRestoreCounter := OnRestoreCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnStart OnStartCounter := OnStartCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE WhileError WhileErrorCounter := WhileErrorCounter + ULINT#1; END_METHOD END_CLASS How to visualize AxoTask On the UI side there are several possibilities how to visualize the AxoTask. You use the AxoTaskView and set its Component according the placement of the instance of the AxoTask. Based on the value of Disable the control element could be controllable: <AxoTaskView Component=\"@Entry.Plc.AxoTaskDocu._myTask\" Disable=\"false\" /> or display only: <AxoTaskView Component=\"@Entry.Plc.AxoTaskDocu._myTask\" Disable=\"true\" /> The next possibility is to use the RenderableContentControl and set its Context according the placement of the instance of the AxoTask. Again as before the element could be controlable when the value of the Presentation is Command: <RenderableContentControl Context=\"@Entry.Plc.AxoTaskDocu._myTask\" Presentation=\"Command\" /> or display only when the value of the Presentation is Status <RenderableContentControl Context=\"@Entry.Plc.AxoTaskDocu._myTask\" Presentation=\"Status\"/> The displayed result should looks like:"
  },
  "articles/core/AXOTEXTLIST.html": {
    "href": "articles/core/AXOTEXTLIST.html",
    "title": "AxoTextList | System.Dynamic.ExpandoObject",
    "keywords": "AxoTextList AxoTextList provides displaying the string value from the list defined in the extended class inside the .NET twin based on the numerical value read out from the PLC. Moreover, the display form could also change the background colour with the numerical value change. To achieve this, the attributes WarningLevel and ErrorLevel need to be declared as in the following example. {#ix-set:AttributeName = \"Description: |[[1]TextList]|\"} {#ix-attr:[WarningLevel(600)]} {#ix-attr:[ErrorLevel(700)]} _myTextList1 : AXOpen.Core.AxoTextList; The final text displayed in the UI application will be static prefix+[text value from text list(Id)](for example Description : + [TextList(Id)]). The static prefix is optional. Use the following example to display the same text list without static prefix and with different levels. {#ix-set:AttributeName = \"|[[1]TextList]|\"} {#ix-attr:[WarningLevel(300)]} {#ix-attr:[ErrorLevel(500)]} _myTextList2 : AXOpen.Core.AxoTextList; If the WarningLevel is greater than 0 and the ErrorLevel is greater than the WarningLevel, all items with the Id lower than the WarningLevel are displayed with the Primary background, all items with the Id greater or equal to the WarningLevel and lower then the ErrorLevel are displayed with the Warning background and all the rest are displayed with the Danger background. The final colours depend on the style used. If the attributes WarningLevel and ErrorLevel are not declared as in the following example, all items are displayed with the Primary background. {#ix-set:AttributeName = \"Totaly different description without error elevation: |[[1]DifferentTextList]|\"} _myTextList3 : AXOpen.Core.AxoTextList; For each AxoTextList, there must be a defined property, named exactly as in the Attributes inside the examples above. It must be defined in the extended class that the particular AxoTextList is a member of. This property must return a string value from the dictionary defined in the same class based on the numerical value of the Id variable. Declaration of the dictionary: Dictionary<uint, string> textList = new Dictionary<uint, string>(); Filling the items of the dictionary: if (textList == null) { textList = new Dictionary<uint, string>(); } if (textList.Count == 0) { textList.Add(0, \" \"); for (int i = 1; i < 1000; i++) { textList.Add((uint)i, \"Text list item : \" + i.ToString()); } } Returning the string item from the dictionary: string _textItem = \" \"; if (textList.TryGetValue(_myTextList1.Id.LastValue, out _textItem)) { return _textItem; } else { return \" \"; } Complete example for two different AxoTextList: using System.Collections.Generic; namespace AxoTextListExample { public partial class AxoTextListExampleContext : AXOpen.Core.AxoContext { //<DeclarationOfTheDictionary> Dictionary<uint, string> textList = new Dictionary<uint, string>(); //</DeclarationOfTheDictionary> public string TextList { get { //<FillingTheItemsOfTheDictionary> if (textList == null) { textList = new Dictionary<uint, string>(); } if (textList.Count == 0) { textList.Add(0, \" \"); for (int i = 1; i < 1000; i++) { textList.Add((uint)i, \"Text list item : \" + i.ToString()); } } //</FillingTheItemsOfTheDictionary> //<ReturningTheItemBasedOnId> string _textItem = \" \"; if (textList.TryGetValue(_myTextList1.Id.LastValue, out _textItem)) { return _textItem; } else { return \" \"; } //</ReturningTheItemBasedOnId> } } Dictionary<uint, string> differentTextList = new Dictionary<uint, string>(); public string DifferentTextList { get { if (differentTextList == null) { differentTextList = new Dictionary<uint, string>(); } if (differentTextList.Count == 0) { differentTextList.Add(0, \" \"); for (int i = 1; i < 1000; i++) { differentTextList.Add((uint)i, \"Item from the totally different text list : \" + i.ToString()); } } string differentTextItem = \" \"; if (differentTextList.TryGetValue(_myTextList3.Id.LastValue, out differentTextItem)) { return differentTextItem; } else { return \" \"; } } } } } How to visualize AxoTextList On the UI side, to visualize the AxoTextList, use the RenderableContentControl and set its Context according to the placement of the instance of the AxoTextList. <div class=\"col\"> <RenderableContentControl Context=\"@Entry.Plc.AxoTextListExampleContext._myTextList1\" /> </div> <div class=\"col\"> <RenderableContentControl Context=\"@Entry.Plc.AxoTextListExampleContext._myTextList2\" /> </div> <div class=\"col\"> <RenderableContentControl Context=\"@Entry.Plc.AxoTextListExampleContext._myTextList3\" /> </div> The displayed result should look like this:"
  },
  "articles/core/AXOTOGGLETASK.html": {
    "href": "articles/core/AXOTOGGLETASK.html",
    "title": "AxoToggleTask | System.Dynamic.ExpandoObject",
    "keywords": "AxoToggleTask AxoToggleTask provides basic switching on and off functions. AxoToggleTask needs to be initialized to set the proper AxoContext. AxoToggleTask initialization within a AxoContext CLASS AxoToggleTaskDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:AttributeName = \"<#Toggle task example#>\"} {#ix-set:AttributeStateOnDesc = \"<#SwitchedOn#>\"} {#ix-set:AttributeStateOffDesc = \"<#SwitchedOff#>\"} _myToggleTask : AxoToggleTask; _myCounter : ULINT; END_VAR METHOD PUBLIC Initialize // Initialization of the context needs to be called first // It does not need to be called cyclically, just once _myToggleTask.Initialize(THIS); END_METHOD END_CLASS There are three key methods for managing the AxoToggleTask: SwitchOn() -ones is called and the AxoToggleTask is not Disabled, changes the state of the AxoToggleTask to TRUE if its previous state was FALSE. (can be called fire&forget or cyclically). The method returns TRUE if the change of the state was performed, otherwise FALSE. SwitchOff() -ones is called and the AxoToggleTask is not Disabled, changes the state of the AxoToggleTask to FALSE if its previous state was TRUE. (can be called fire&forget or cyclically). The method returns TRUE if the change of the state was performed, otherwise FALSE. Toggle() -ones is called and the AxoToggleTask is not Disabled, changes the state of the AxoToggleTask to TRUE if its previous state was FALSE and vice-versa . (can be called fire&forget or cyclically). The method returns TRUE if the change of the state was performed, otherwise FALSE. The methods SwitchOn() and SwitchOff() are designed to be used inside automatic logic, where change to exact value has to be performed, while Toggle() is designed to be used mostly in connection with manual control. Example of using SwitchOn() method with its return value. IF _myToggleTask.SwitchOn() THEN ; // do something on rising edge END_IF; Example of using SwitchOff() method with its return value. IF _myToggleTask.SwitchOff()THEN ; // do something on falling edge END_IF; Example of using Toggle() method with its return value. IF _myToggleTask.Toggle()THEN ; // do something on state change END_IF; To check the state of the task there are two methods: IsSwitchOn() - returns TRUE if the state of the task is TRUE. IsSwitchOff() - returns TRUE if the state of the task is FALSE. Example of using IsSwitchOn() method: IF _myToggleTask.IsSwitchedOn() THEN ; // do something END_IF; Example of using IsSwitchOff() method: IF _myToggleTask.IsSwitchedOff() THEN ; // do something END_IF; Moreover, there are five more \"event-like\" methods that are called when a specific event occurs (see the chart below). To implement any of the already mentioned \"event-like\" methods the new class that extends from the AxoToggleTask needs to be created. The required method with PROTECTED OVERRIDE access modifier needs to be created as well, and the custom logic needs to be placed in. These methods are: OnSwitchedOn() - executes once when the task changes its state from FALSE to TRUE. OnSwitchedOff() - executes once when the task changes its state from TRUE to FALSE. OnStateChanged() - executes once when the task changes its state. SwitchedOn() - executes repeatedly while the task is in TRUE state. SwitchedOff() - executes repeatedly while the task is in FALSE state. Example of implementing \"event-like\" methods: CLASS MyToogleTaskExample Extends AxoToggleTask VAR OnSwitchedOnCounter : ULINT; OnSwitchedOffCounter : ULINT; OnStateChangedCounter : ULINT; SwitchOnExecutionCounter : ULINT; SwitchOffExecutionCounter : ULINT; END_VAR METHOD PROTECTED OVERRIDE OnSwitchedOn OnSwitchedOnCounter := OnSwitchedOnCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnSwitchedOff OnSwitchedOffCounter := OnSwitchedOffCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnStateChanged OnStateChangedCounter := OnStateChangedCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE SwitchedOn SwitchOnExecutionCounter := SwitchOnExecutionCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE SwitchedOff SwitchOffExecutionCounter := SwitchOffExecutionCounter + ULINT#1; END_METHOD END_CLASS How to visualize AxoToggleTask On the UI side there are several possibilities how to visualize the AxoToggleTask. You use the AxoToggleTaskView and set its Component according the placement of the instance of the AxoToggleTask. Based on the value of Disable the control element could be controllable: <AxoToggleTaskView Component=\"@Entry.Plc.AxoToggleTaskDocu._myToggleTask\" Disable=\"false\" /> or display only: <AxoToggleTaskView Component=\"@Entry.Plc.AxoToggleTaskDocu._myToggleTask\" Disable=\"true\" /> The next possibility is to use the RenderableContentControl and set its Context according the placement of the instance of the AxoToggleTask. Again as before the element could be controlable when the value of the Presentation is Command: <RenderableContentControl Context=\"@Entry.Plc.AxoToggleTaskDocu._myToggleTask\" Presentation=\"Command\" /> or display only when the value of the Presentation is Status <RenderableContentControl Context=\"@Entry.Plc.AxoToggleTaskDocu._myToggleTask\" Presentation=\"Status\" /> The displayed result should looks like:"
  },
  "articles/core/README.html": {
    "href": "articles/core/README.html",
    "title": "AXOpen.Core | System.Dynamic.ExpandoObject",
    "keywords": "AXOpen.Core AXOpen.Core provides basic blocks for building AXOpen applications. Basic concepts AxoContext AxoContext encapsulates entire application or application units. Any solution may contain one or more contexts, however the each should be considered to be an isolated island and any direct inter-context access to members must be avoided. Note Each AxoContext must belong to a single PLC task.Multiple AxoContexts can be however running on the same task. classDiagram class Context{ +Main()* +Run() } In its basic implementation AxoContext has relatively simple interface. Main is the method where we place all calls of our sub-routines. In other words the Run is the root of the call tree of our program. Run method runs the AxoContext. It must be called cyclically within a program unit that is attached to a cyclic task. Why do we need AxoContext AxoContext provides counters, object identification and other information about the execution of the program. These information is then used by the objects contained at different levels of the AxoContext. How AxoContext works When you call Run method on an instance of a AxoContext, it will ensure opening AxoContext, running Main method (root of all your program calls) and AxoContext closing. flowchart LR classDef run fill:#80FF00,stroke:#0080FF,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold classDef main fill:#ff8000,stroke:#0080ff,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold id1(Open):::run-->id2(#Main*):::main-->id3(Close):::run-->id1 How to use AxoContext Base class for the AxoContext is AXOpen.Core.AxoContext. The entry point of call execution of the AxoContext is Main method. Notice that the AxoContext class is abstract and cannot be instantiated if not extended. Main method must be overridden in derived class notice the use of override keyword and also that the method is protected which means the it is visible only from within the AxoContext and derived classes. How to extend AxoContext class CLASS PUBLIC AxoContextExample EXTENDS AXOpen.Core.AxoContext METHOD PROTECTED OVERRIDE Main // Here goes all your logic for given AxoContext. ; END_METHOD END_CLASS Cyclical call of the AxoContext logic (Main method) is ensured when AxoContext Run method is called. Run method is public therefore accessible and visible to any part of the program that whishes to call it. How to start AxoContext's execution PROGRAM ProgramExample VAR MyContext : AxoContextExample; END_VAR MyContext.Run(); END_PROGRAM AxoObject AxoObject is the base class for any other classes of AXOpen.Core. It provides access to the parent AxoObject and the AxoContext in which it was initialized. classDiagram class Object{ +Initialize(IAxoContext context) +Initialize(IAxoObject parent) } AxoObject initialization within a AxoContext CLASS PUBLIC MyContext EXTENDS AXOpen.Core.AxoContext VAR _myObject : AxoObject; END_VAR METHOD PROTECTED OVERRIDE Main _myObject.Initialize(THIS); END_METHOD END_CLASS AxoObject initialization within another AxoObject CLASS PUBLIC MyParentObject EXTENDS AxoContext VAR _myChildObject : AxoObject; END_VAR METHOD PROTECTED OVERRIDE Main _myChildObject.Initialize(THIS); END_METHOD END_CLASS AxoTask AxoTask provides basic task execution. AxoTask needs to be initialized to set the proper AxoContext. AxoTask initialization within a AxoContext CLASS AxoTaskDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:AttributeName = \"<#Task name#>\"} _myTask : AxoTask; _myCounter : ULINT; END_VAR METHOD PUBLIC Initialize // Initialization of the context needs to be called first // It does not need to be called cyclically, just once _myTask.Initialize(THIS); END_METHOD END_CLASS There are two key methods for managing the AxoTask: Invoke() fires the execution of the AxoTask (can be called fire&forget or cyclically) Execute() method must be called cyclically. The method returns TRUE when the AxoTask is required to run until enters Done state or terminates in error. For termination of the execution of the AxoTask there are following methods: DoneWhen(Done_Condition) - terminates the execution of the AxoTask and enters the Done state when the Done_Condition is TRUE. ThrowWhen(Error_Condition) - terminates the execution of the AxoTask and enters the Error state when the Error_Condition is TRUE. Abort() - terminates the execution of the AxoTask and enters the Ready state if the AxoTask is in the Busy state, otherwise does nothing. To reset the AxoTask from any state in any moment there is following method: Restore() acts as reset of the AxoTask (sets the state into Ready state from any state of the AxoTask). Moreover, there are seven more \"event-like\" methods that are called when a specific event occurs (see the chart below). flowchart TD classDef states fill:#80FF00,stroke:#0080FF,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold classDef actions fill:#ff8000,stroke:#0080ff,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold classDef events fill:#80FF00,stroke:#0080ff,stroke-width:4px,color:#7F00FF,font-size:15px,font-weight:bold s1((Ready)):::states s2((Kicking)):::states s3((Busy)):::states s4((Done)):::states s5((Error)):::states s6((Aborted)):::states a1(\"Invoke()#128258;\"):::actions a2(\"Execute()#128260;\"):::actions a3(\"DoneWhen(TRUE)#128258;\"):::actions a4(\"ThrowWhen(TRUE)#128258;\"):::actions a5(\"NOT Invoke() call for at<br>least two Context cycles#128260;\"):::actions a6(\"Restore()#128258;\"):::actions a7(\"Abort()#128258;\"):::actions a8(\"Resume()#128258;\"):::actions e1{{\"OnStart()#128258;\"}}:::events e2{{\"OnError()#128258;\"}}:::events e3{{\"WhileError()#128260;\"}}:::events e4{{\"OnDone()#128258;\"}}:::events e5{{\"OnAbort()#128258;\"}}:::events e6{{\"OnRestore()#128258;\"}}:::events subgraph legend[\" \"] direction LR s((State)):::states ac(\"Action #128260;:called<br>cyclically\"):::actions as(\"Action #128258;:single<br>or cyclical call \"):::actions ec{{\"Event #128260;:called<br>cyclically\"}}:::events es{{\"Event #128258;:triggered<br>once \"}}:::events end subgraph chart[\" \"] direction TB s1 s1-->a1 a1-->s2 s2-->a2 s3-->a3 s3-->a7 a7-->e5 a7-->s6 s6-->a8 a8-->s3 a3-->s4 s4---->a5 a5-->a1 a2--->s3 s3--->a4 a4-->s5 s5-->a6 a6-->e6 a2-->e1 a4-->e2 a4-->e3 a3-->e4 a6-->s1 end Example of using AxoTask: CLASS AxoTaskDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:AttributeName = \"<#Task name#>\"} _myTask : AxoTask; _myCounter : ULINT; END_VAR METHOD PUBLIC Initialize // Initialization of the context needs to be called first // It does not need to be called cyclically, just once _myTask.Initialize(THIS); END_METHOD METHOD PROTECTED OVERRIDE Main _myTask.Initialize(THIS); // Cyclicall call of the Execute IF _myTask.Execute() THEN _myCounter := _myCounter + ULINT#1; _myTask.DoneWhen(_myCounter = ULINT#100); END_IF; IF _myTask.IsDone() THEN _myCounter := ULINT#0; END_IF; END_METHOD END_CLASS The AxoTask executes upon the Invoke method call. Invoke fires the execution of Execute logic upon the first call, and it does not need cyclical calling. _myTask.Invoke(); Invoke() method returns IAxoTaskState with the following members: IsBusy indicates the execution started and is running. IsDone indicates the execution completed with success. HasError indicates the execution terminated with a failure. IsAborted indicates that the execution of the AxoTask has been aborted. It should continue by calling the method Resume(). Examples of using: Invoking the AxoTask and waiting for its completion at the same place. IF _myTask.Invoke().IsDone() THEN ; //Do something END_IF; Invoking the AxoTask and waiting for its completion at the different places. _myTask.Invoke(); IF _myTask.IsDone() THEN ; //Do something END_IF; Checking if the AxoTask is executing. IF _myTask.Invoke().IsBusy() THEN ; //Do something END_IF; Check for the AxoTask's error state. IF _myTask.Invoke().HasError() THEN ; //Do something END_IF; The AxoTask can be started only from the Ready state by calling the Invoke() method in the same Context cycle as the Execute() method is called, regardless the order of the methods calls. After AxoTask completion, the state of the AxoTask will remain in Done, unless: 1.) AxoTask's Restore method is called (AxoTask changes it's state to Ready state). 2.) Invoke method is not called for two or more consecutive cycles of its context (that usually means the same as PLC cycle); successive call of Invoke will switch the task into the Ready state and immediately into the Kicking state. The AxoTask may finish also in an Error state. In that case, the only possibility to get out of Error state is by calling the Restore() method. To implement any of the already mentioned \"event-like\" methods the new class that extends from the AxoTask needs to be created. The required method with PROTECTED OVERRIDE access modifier needs to be created as well, and the custom logic needs to be placed in. These methods are: OnAbort() - executes once when the task is aborted. OnResume() - executes once when the task is resumed. OnDone() - executes once when the task reaches the Done state. OnError() - executes once when the task reaches the Error state. OnRestore() - executes once when the task is restored. OnStart() - executes once when the task starts (at the moment of transition from the Kicking state into the Busy state). WhileError() - executes repeatedly while the task is in Error state (and Execute() method is called). Example of implementing \"event-like\" methods: CLASS MyTaskExample EXTENDS AXOpen.Core.AxoTask VAR OnAbortCounter : ULINT; OnResumeCounter : ULINT; OnDoneCounter : ULINT; OnErrorCounter : ULINT; OnRestoreCounter : ULINT; OnStartCounter : ULINT; WhileErrorCounter : ULINT; END_VAR METHOD PROTECTED OVERRIDE OnAbort OnAbortCounter := OnAbortCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnResume OnResumeCounter := OnResumeCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnDone OnDoneCounter := OnDoneCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnError OnErrorCounter := OnErrorCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnRestore OnRestoreCounter := OnRestoreCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnStart OnStartCounter := OnStartCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE WhileError WhileErrorCounter := WhileErrorCounter + ULINT#1; END_METHOD END_CLASS How to visualize AxoTask On the UI side there are several possibilities how to visualize the AxoTask. You use the AxoTaskView and set its Component according the placement of the instance of the AxoTask. Based on the value of Disable the control element could be controllable: <AxoTaskView Component=\"@Entry.Plc.AxoTaskDocu._myTask\" Disable=\"false\" /> or display only: <AxoTaskView Component=\"@Entry.Plc.AxoTaskDocu._myTask\" Disable=\"true\" /> The next possibility is to use the RenderableContentControl and set its Context according the placement of the instance of the AxoTask. Again as before the element could be controlable when the value of the Presentation is Command: <RenderableContentControl Context=\"@Entry.Plc.AxoTaskDocu._myTask\" Presentation=\"Command\" /> or display only when the value of the Presentation is Status <RenderableContentControl Context=\"@Entry.Plc.AxoTaskDocu._myTask\" Presentation=\"Status\"/> The displayed result should looks like: AxoToggleTask AxoToggleTask provides basic switching on and off functions. AxoToggleTask needs to be initialized to set the proper AxoContext. AxoToggleTask initialization within a AxoContext CLASS AxoToggleTaskDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:AttributeName = \"<#Toggle task example#>\"} {#ix-set:AttributeStateOnDesc = \"<#SwitchedOn#>\"} {#ix-set:AttributeStateOffDesc = \"<#SwitchedOff#>\"} _myToggleTask : AxoToggleTask; _myCounter : ULINT; END_VAR METHOD PUBLIC Initialize // Initialization of the context needs to be called first // It does not need to be called cyclically, just once _myToggleTask.Initialize(THIS); END_METHOD END_CLASS There are three key methods for managing the AxoToggleTask: SwitchOn() -ones is called and the AxoToggleTask is not Disabled, changes the state of the AxoToggleTask to TRUE if its previous state was FALSE. (can be called fire&forget or cyclically). The method returns TRUE if the change of the state was performed, otherwise FALSE. SwitchOff() -ones is called and the AxoToggleTask is not Disabled, changes the state of the AxoToggleTask to FALSE if its previous state was TRUE. (can be called fire&forget or cyclically). The method returns TRUE if the change of the state was performed, otherwise FALSE. Toggle() -ones is called and the AxoToggleTask is not Disabled, changes the state of the AxoToggleTask to TRUE if its previous state was FALSE and vice-versa . (can be called fire&forget or cyclically). The method returns TRUE if the change of the state was performed, otherwise FALSE. The methods SwitchOn() and SwitchOff() are designed to be used inside automatic logic, where change to exact value has to be performed, while Toggle() is designed to be used mostly in connection with manual control. Example of using SwitchOn() method with its return value. IF _myToggleTask.SwitchOn() THEN ; // do something on rising edge END_IF; Example of using SwitchOff() method with its return value. IF _myToggleTask.SwitchOff()THEN ; // do something on falling edge END_IF; Example of using Toggle() method with its return value. IF _myToggleTask.Toggle()THEN ; // do something on state change END_IF; To check the state of the task there are two methods: IsSwitchOn() - returns TRUE if the state of the task is TRUE. IsSwitchOff() - returns TRUE if the state of the task is FALSE. Example of using IsSwitchOn() method: IF _myToggleTask.IsSwitchedOn() THEN ; // do something END_IF; Example of using IsSwitchOff() method: IF _myToggleTask.IsSwitchedOff() THEN ; // do something END_IF; Moreover, there are five more \"event-like\" methods that are called when a specific event occurs (see the chart below). To implement any of the already mentioned \"event-like\" methods the new class that extends from the AxoToggleTask needs to be created. The required method with PROTECTED OVERRIDE access modifier needs to be created as well, and the custom logic needs to be placed in. These methods are: OnSwitchedOn() - executes once when the task changes its state from FALSE to TRUE. OnSwitchedOff() - executes once when the task changes its state from TRUE to FALSE. OnStateChanged() - executes once when the task changes its state. SwitchedOn() - executes repeatedly while the task is in TRUE state. SwitchedOff() - executes repeatedly while the task is in FALSE state. Example of implementing \"event-like\" methods: CLASS MyToogleTaskExample Extends AxoToggleTask VAR OnSwitchedOnCounter : ULINT; OnSwitchedOffCounter : ULINT; OnStateChangedCounter : ULINT; SwitchOnExecutionCounter : ULINT; SwitchOffExecutionCounter : ULINT; END_VAR METHOD PROTECTED OVERRIDE OnSwitchedOn OnSwitchedOnCounter := OnSwitchedOnCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnSwitchedOff OnSwitchedOffCounter := OnSwitchedOffCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnStateChanged OnStateChangedCounter := OnStateChangedCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE SwitchedOn SwitchOnExecutionCounter := SwitchOnExecutionCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE SwitchedOff SwitchOffExecutionCounter := SwitchOffExecutionCounter + ULINT#1; END_METHOD END_CLASS How to visualize AxoToggleTask On the UI side there are several possibilities how to visualize the AxoToggleTask. You use the AxoToggleTaskView and set its Component according the placement of the instance of the AxoToggleTask. Based on the value of Disable the control element could be controllable: <AxoToggleTaskView Component=\"@Entry.Plc.AxoToggleTaskDocu._myToggleTask\" Disable=\"false\" /> or display only: <AxoToggleTaskView Component=\"@Entry.Plc.AxoToggleTaskDocu._myToggleTask\" Disable=\"true\" /> The next possibility is to use the RenderableContentControl and set its Context according the placement of the instance of the AxoToggleTask. Again as before the element could be controlable when the value of the Presentation is Command: <RenderableContentControl Context=\"@Entry.Plc.AxoToggleTaskDocu._myToggleTask\" Presentation=\"Command\" /> or display only when the value of the Presentation is Status <RenderableContentControl Context=\"@Entry.Plc.AxoToggleTaskDocu._myToggleTask\" Presentation=\"Status\" /> The displayed result should looks like: AxoMomentaryTask AxoMomentaryTask provides basic momentary function. It is mainly designed for some manual operations from the UI side. AxoMomentaryTask needs to be initialized to set the proper AxoContext. AxoMomentaryTask initialization within a AxoContext CLASS AxoMomentaryTaskDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:AttributeName = \"<#Momentary task example#>\"} {#ix-set:AttributeStateOnDesc = \"<#Currently On#>\"} {#ix-set:AttributeStateOffDesc = \"<#Currently Off#>\"} _myMomentaryTask : AxoMomentaryTask; END_VAR METHOD PUBLIC Initialize // Initialization of the context needs to be called first // It does not need to be called cyclically, just once _myMomentaryTask.Initialize(THIS); END_METHOD END_CLASS To check the state of the task there are two methods: IsSwitchOn() - returns TRUE if the state of the task is TRUE. IsSwitchOff() - returns TRUE if the state of the task is FALSE. Example of using IsSwitchOn() method: IF _myMomentaryTask.IsSwitchedOn() THEN ; // do something END_IF; Example of using IsSwitchOff() method: IF _myMomentaryTask.IsSwitchedOff() THEN ; // do something END_IF; Moreover, there are five more \"event-like\" methods that are called when a specific event occurs (see the chart below). To implement any of the already mentioned \"event-like\" methods the new class that extends from the AxoMomentaryTask needs to be created. The required method with PROTECTED OVERRIDE access modifier needs to be created as well, and the custom logic needs to be placed in. These methods are: OnSwitchedOn() - executes once when the task changes its state from FALSE to TRUE. OnSwitchedOff() - executes once when the task changes its state from TRUE to FALSE. OnStateChanged() - executes once when the task changes its state. SwitchedOn() - executes repeatedly while the task is in TRUE state. SwitchedOff() - executes repeatedly while the task is in FALSE state. Example of implementing \"event-like\" methods: CLASS MyMomentaryTaskExample Extends AxoMomentaryTask VAR OnSwitchedOnCounter : ULINT; OnSwitchedOffCounter : ULINT; OnStateChangedCounter : ULINT; SwitchOnExecutionCounter : ULINT; SwitchOffExecutionCounter : ULINT; END_VAR METHOD PROTECTED OVERRIDE OnSwitchedOn OnSwitchedOnCounter := OnSwitchedOnCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnSwitchedOff OnSwitchedOffCounter := OnSwitchedOffCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE OnStateChanged OnStateChangedCounter := OnStateChangedCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE SwitchedOn SwitchOnExecutionCounter := SwitchOnExecutionCounter + ULINT#1; END_METHOD METHOD PROTECTED OVERRIDE SwitchedOff SwitchOffExecutionCounter := SwitchOffExecutionCounter + ULINT#1; END_METHOD END_CLASS How to visualize AxoMomentaryTask On the UI side there are several possibilities how to visualize the AxoMomentaryTask. You use the AxoMomentaryTaskView and set its Component according the placement of the instance of the AxoMomentaryTask. Based on the value of Disable the control element could be controllable: <AxoMomentaryTaskView Component=\"@Entry.Plc.AxoMomentaryTaskDocu._myMomentaryTask\" Disable=\"false\" /> or display only: <AxoMomentaryTaskView Component=\"@Entry.Plc.AxoMomentaryTaskDocu._myMomentaryTask\" Disable=\"true\" /> The next possibility is to use the RenderableContentControl and set its Context according the placement of the instance of the AxoMomentaryTask. Again as before the element could be controlable when the value of the Presentation is Command: <RenderableContentControl Context=\"@Entry.Plc.AxoMomentaryTaskDocu._myMomentaryTask\" Presentation=\"Command\" /> or display only when the value of the Presentation is Status <RenderableContentControl Context=\"@Entry.Plc.AxoMomentaryTaskDocu._myMomentaryTask\" Presentation=\"Status\" /> The displayed result should looks like: AxoRemoteTask AxoRemoteTask provides task execution, where the execution of the task is deferred to .NET environment. AxoRemoteTask derives from AxoTask. AxoRemoteTask needs to be initialized to set the proper AxoContext. Important The deferred execution in .NET environment is not hard-real time nor deterministic. You would typically use the AxoRemoteTask when it would be hard to achieve a goal in the PLC, but you can delegate the access to the non-hard-real and nondeterministic environment. Examples of such use would be database access, complex calculations, and email sending. AxoTask initialization within a AxoContext _remoteTask.Initialize(THIS); // THIS = IAxoContext There are two key methods for managing the AxoRemoteTask: Invoke() fires the execution of the AxoRemoteTask (can be called fire&forget or cyclically) Execute() method must be called cyclically. In contrast to AxoTask the method does not execute any logic. You will need to call the Execute method cyclically which will deffer the logic execution in .NET environment. There are the following differences in behavior of DoneWhen and ThrowWhen methods: DoneWhen(Done_Condition) - Unlike AxoTask Done condition is handled internally. It does not have an effect. ThrowWhen(Error_Condition) - Unlike AxoTask Exception emission is handled internally. It does not have an effect. For termination of the execution of the AxoRemoteTask there are the following methods: Abort() - terminates the execution of the AxoRemoteTask and enters the Ready state if the AxoRemoteTask is in the Busy state; otherwise does nothing. To reset the AxoRemoteTask from any state at any moment, there is the following method: Restore() acts as a reset of the AxoRemoteTask (sets the state into Ready from any state of the AxoRemoteTask). The AxoRemoteTask executes upon the Invoke method call. Invoke fires the execution of Execute logic upon the first call, and Invoke does not need cyclical calling. _remoteTask.Invoke('hello'); Invoke() method returns IAxoTaskState with the following members: IsBusy indicates the execution started and is running. IsDone indicates the execution completed with success. HasError indicates the execution terminated with a failure. IsAborted indicates that the execution of the AxoRemoteTask has been aborted. It should continue by calling the method Resume(). Task initialization in .NET Entry.Plc.AxoRemoteTasks._remoteTask.Initialize(() => Console.WriteLine($\"Remote task executed PLC sent this string: '{Entry.Plc.AxoRemoteTasks._remoteTask.Message.GetAsync().Result}'\")); In this example, when the PLC invokes this task it will write a message into console. You can use arbitrary code in place of the labmda expression. Executing from PLC Invoking the AxoRemoteTask and waiting for its completion at the same place. IF(_remoteTask.Invoke('hello').IsDone()) THEN _doneCounter := _doneCounter + 1; END_IF; Invoking the AxoRemoteTask and waiting for its completion at the different places. // Fire & Forget _remoteTask.Invoke('hello'); // Wait for done somwhere else IF(_remoteTask.IsDone()) THEN _doneCounter := _doneCounter + 1; END_IF; Checking if the AxoRemoteTask is executing. IF(_remoteTask.IsBusy()) THEN ;// Do something after task started END_IF; Check for the AxoRemoteTask's error state. IF(_remoteTask.HasError()) THEN ;// Do something when an exception occurs on remote task. END_IF; AxoStep AxoStep is an extension class of the AxoTask and provides the basics for the coordinated controlled execution of the task in the desired order based on the coordination mechanism used. AxoStep contains the Execute() method so as its base class overloaded and extended by following parameters: coord (mandatory): instance of the coordination controlling the execution of the AxoStep. Enable (optional): if this value is FALSE, AxoStep body is not executed and the current order of the execution is incremented. Description (optional): AxoStep description text describing the action the AxoStep is providing. AxoStep class contains following public members: Order: Order of the AxoStep in the coordination. This value can be set by calling the method SetStepOrder() and read by the method GetStepOrder(). StepDescription: AxoStep description text describing the action the AxoStep is providing. This value can be set by calling the Execute() method with Description parameter. IsActive: if TRUE, the AxoStep is currently executing, or is in the order of the execution, otherwise FALSE. This value can be set by calling the method SetIsActive() and read by the method GetIsActive(). IsEnabled: if FALSE, AxoStep body is not executed and the current order of the execution is incremented. This value can be set by calling the method SetIsEnabled() or calling the Execute() method with Enable parameter and read by the method GetIsEnabled(). AxoSequencer AxoSequencer is an AxoCordinator class provides triggering the AxoStep-s inside the sequence in the order they are written. AxoSequencer extends from AxoTask so it also has to be initialized by calling its Initialize() method and started using its Invoke() method. AxoSequencer contains following methods: Open(): this method must be called cyclically before any logic. All the logic of the sequencers must be placed inside the if condition. It provides some configuration mechanism that ensures that the steps are going to be executed in the order, they are written. During the very first call of the sequence, no step is executed as the AxoSequencer is in the configuring state. From the second context cycle after the AxoSequencer has been invoked the AxoSequencer change its state to running and starts the execution from the first step upto the last one. When AxoSequencer is in running state, order of the step cannot be changed. MoveNext(): Terminates the currently executed step and moves the AxoSequencer's pointer to the next step in order of execution. RequestStep(): Terminates the currently executed step and set the AxoSequencer's pointer to the order of the RequestedStep. When the order of the RequestedStep is higher than the order of the currently finished step (the requested step is \"after\" the current one) the requested step is started in the same context cycle. When the order of the RequestedStep is lower than the order of the currently finished step (the requested step is \"before\" the current one) the requested step is started in the next context cycle. CompleteSequence(): Terminates the currently executed step, completes (finishes) the execution of this AxoSequencer and set the coordination state to Idle. If the SequenceMode of the AxoSequencer is set to Cyclic, following Open() method call in the next context cycle switch it again into the configuring state, reasign the order of the individual steps (even if the orders have been changed) and subsequently set AxoSequencer back into the running state. If the SequenceMode of the AxoSequencer is set to RunOnce, terminates also execution of the AxoSequencer itself. `GetCoordinatorState()': Returns the current state of the AxoSequencer. Idle Configuring: assigning the orders to the steps, no step is executed. Running: orders to the steps are already assigned, step is executed. SetSteppingMode(): Sets the stepping mode of the AxoSequencer. Following values are possible. None: StepByStep: if this mode is choosen, each step needs to be started by the invocation of the StepIn commmand. Continous: if this mode is choosen (default), each step is started automaticcaly after the previous one has been completed. GetSteppingMode(): Gets the current stepping mode of the AxoSequencer. SetSequenceMode(): Sets the sequence mode of the AxoSequencer. Following values are possible. None: RunOnce: if this mode is choosen, after calling the method CompleteSequence() the execution of the sequence is terminated. Cyclic: if this mode is choosen (default), after calling the method CompleteSequence() the execution of the sequence is \"reordered\" and started from beginning. GetSequenceMode(): Gets the current sequence mode of the AxoSequencer. GetNumberOfConfiguredSteps(): Gets the number of the configured steps in the sequence. Example of using AxoSequencer Example of the declaration of the AxoSequencer and AxoStep CLASS AxoSequencerDocuExample EXTENDS AXOpen.Core.AxoContext VAR PUBLIC _mySequencer : AXOpen.Core.AxoSequencer; _step_1 : AxoStep; _step_2 : AxoStep; _step_3 : AxoStep; _myCounter : ULINT; END_VAR END_CLASS Initialization Initialization of the context needs to be called first. It does not need to be called cyclically, just once. METHOD PUBLIC Initialize _mySequencer.Initialize(THIS); _step_1.Initialize(THIS); _step_2.Initialize(THIS); _step_3.Initialize(THIS); END_METHOD Open The Open() method must be called cyclically before any logic. All the logic of the sequencers must be placed inside the if condition, as follows. THIS.Initialize(); IF _mySequencer.Open() THEN //All sequence logic needs to be placed inside the condition _myCounter := _myCounter + ULINT#1; IF _step_1.Execute(_mySequencer) THEN IF (_myCounter > ULINT#50) THEN _mySequencer.MoveNext(); END_IF; END_IF; IF _step_2.Execute(_mySequencer) THEN IF (_myCounter > ULINT#100) THEN _mySequencer.MoveNext(); END_IF; END_IF; IF _step_3.Execute(_mySequencer) THEN IF (_myCounter > ULINT#150) THEN _myCounter := ULINT#0; _mySequencer.CompleteSequence(); END_IF; END_IF; END_IF; Step Example of the most simple use of the Execute() method of the AxoStep class, only with the AxoCoordinator defined. IF _step_1.Execute(_mySequencer) THEN _myCounter := _myCounter + ULINT#1; // do something IF (_myCounter MOD ULINT#5) = ULINT#0 THEN // continue to the next step of the sequence _mySequencer.MoveNext(); END_IF; END_IF; Example of use of the Execute() method of the AxoStep class with the Enable condition. This step is going to be executed just in the first run of the sequence, as during the second one, the Enable parameter will have the value of FALSE. IF _step_2.Execute(coord := _mySequencer, Enable := _myCounter <= ULINT#20) THEN _myCounter := _myCounter + ULINT#1; IF _myCounter = ULINT#20 THEN // Jumping to step 1. As it is jumping backwards, the execution of step 1 // is going to be started in the next context cycle. _mySequencer.RequestStep(_step_1); END_IF; END_IF; Example of use of the Execute() method of the AxoStep class with all three parameters defined. IF _step_3.Execute(coord := _mySequencer, Enable := TRUE, Description := 'This is a description of the step 3' ) THEN _myCounter := _myCounter + ULINT#1; IF (_myCounter MOD ULINT#7) = ULINT#0 THEN // Finalize the sequence and initiate the execution from the first step. _mySequencer.CompleteSequence(); END_IF; END_IF; AxoSequencerContainer AxoSequencerContainer is an AxoCordinator class that extends from AxoSequencer. The main difference is that this class is abstract so it is not possible to instantiate it directly. The user-defined class that extends from AxoSequencerContainer needs to be created and then instantiated. In the extended class MAIN() method needs to be created and all sequencer logic needs to be placed there. Then the sequencer is called via Run(IAxoObject) or Run(IAxoContext) methods, that ensure initialization of the sequencer with AxoObject or with AxoContext. Moreover the Run() method also ensures calling the Open() method, so it is not neccessary to call it explicitelly in comparison with AxoSequencer. Example of using AxoSequencerContainer Example of the declaration of the user-defined class that extends from AxoSequencerContainer CLASS AxoSequencerContainerDocuExample EXTENDS AXOpen.Core.AxoSequencerContainer VAR PUBLIC _step_1 : AxoStep; _step_2 : AxoStep; _step_3 : AxoStep; _myCounter : ULINT; END_VAR END_CLASS Example of implementation MAIN method inside the user-defined class that extends from AxoSequencerContainer All the custom logic of the sequencer needs to be placed here. METHOD PROTECTED OVERRIDE MAIN _step_1.Initialize(THIS); _step_2.Initialize(THIS); _step_3.Initialize(THIS); _myCounter := _myCounter + ULINT#1; IF(_step_1.Execute(THIS)) THEN IF(_myCounter >= ULINT#100 ) THEN _myCounter := ULINT#0; THIS.MoveNext(); END_IF; END_IF; IF(_step_2.Execute(THIS)) THEN IF(_myCounter >= ULINT#100) THEN _myCounter := ULINT#0; THIS.MoveNext(); END_IF; END_IF; IF(_step_3.Execute(THIS)) THEN IF(_myCounter >= ULINT#100) THEN _myCounter := ULINT#0; _step_3.ThrowWhen(TRUE); THIS.CompleteSequence(); END_IF; END_IF; END_METHOD Example of declaration of the instance of the user-defined class that extends from AxoSequencerContainer VAR PUBLIC _mySequencerContainer : AxoSequencerContainerDocuExample; END_VAR Example of calling of the instance of the user-defined class that extends from AxoSequencerContainer _mySequencerContainer.Run(THIS); AxoComponent AxoComponent is an abstract class extending the AxoObject, and it is the base building block for the \"hardware-related devices\" like a pneumatic piston, servo drive, robot, etc., so as for the, let's say, \"virtual devices\" like counter, database, etc. AxoComponent is designed to group all possible methods, tasks, settings, and status information into one consistent class. As the AxoComponent is an abstract class, it cannot be instantiated and must be extended. In the extended class, two methods are mandatory. Restore() - inside this method, the logic for resetting the AxoComponent or restoring it from any state to its initial state should be placed. ManualControl() - inside this method, the logic for manual operations with the component should be placed. To be able to control the AxoComponent instance manually, the method ActivateManualControl() of this instance needs to be called cyclically. The base class contains two additional method to deal with the manual control of the AxoComponent. ActivateManualControl() - when this method is called cyclically, the AxoComponent changes its behavior to manually controllable and ensure the call of the ManualControl() method in the derived class. IsManuallyControllable() -returns TRUE when the AxoComponent is manually controllable. Layout attributes ComponentHeader and ComponentDetails The visual view of the extended AxoComponent on the UI side could be done both ways. Manually with complete control over the design or by using the auto-rendering mechanism of the RenderableContentControl (TODO add a link to docu of the RenderableContentControl) element, which is, in most cases, more than perfect. To take full advantage of the auto-rendering mechanism, the base class has implemented the additional layout attributes ComponentHeader and ComponentDetails(TabName). The auto-rendered view is divided into two parts: the fAxoed one and the expandable one. All AxoComponent members with the ComponentHeader layout attribute defined will be displayed in the fixed part. All members with the ComponentDetails(TabName) layout attribute defined will be displayed in the expandable part inside the TabControl with \"TabName\". All members are added in the order in which they are defined, taking into account their layout attributes like Container(Layout.Wrap) or Container(Layout.Stack). How to implement AxoComponent Example of the implementation very simple AxoComponent with members placed only inside the Header. {#ix-attr:[Container(Layout.Stack)]} {#ix-set:AttributeName = \"AxoComponent with header only example\"} CLASS PUBLIC AxoComponentHeaderOnlyExample EXTENDS AXOpen.Core.AxoComponent METHOD PROTECTED OVERRIDE Restore: IAxoTask // Some logic for Restore could be placed here. For Example: valueReal := REAL#1.0; valueDint := DINT#0; END_METHOD METHOD PROTECTED OVERRIDE ManualControl // Some logic for manual control could be placed here. ; END_METHOD // Main method of the `AxoComponent` that must be // called inside the `AxoContext` cyclically. METHOD PUBLIC Run // Declaration of the input and output variables. // In the case of \"hardware-related\" `AxoComponent`, // these would be the variables linked to the hardware. VAR_INPUT inReal : REAL; inDint : DINT; END_VAR VAR_OUTPUT outReal : REAL; outDint : DINT; END_VAR // This must be called first. SUPER.Open(); // Place the custom logic here. valueReal := valueReal * inReal; valueDint := valueDint + inDint; outReal := valueReal; outDint := valueDint; END_METHOD VAR PUBLIC {#ix-attr:[Container(Layout.Wrap)]} {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Real product value\"} valueReal : REAL := REAL#1.0; {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Dint sum value\"} valueDint : DINT:= DINT#0; END_VAR END_CLASS How to use AxoComponent The instance of the extended AxoComponent must be defined inside the AxoContext. CLASS ComponentHeaderOnlyExampleContext EXTENDS AxoContext VAR PUBLIC {#ix-set:AttributeName = \"Very simple component example with header only defined\"} MyComponentWithHeaderOnly : AxoComponentHeaderOnlyExample; {#ix-set:AttributeName = \"<#Activate manual control#>\"} ActivateManualControl : BOOL; inHwReal : REAL := REAL#1.0001; inHwDint : DINT := DINT#1; outHwReal : REAL; outHwDint : DINT; END_VAR METHOD PROTECTED OVERRIDE Main // The `Initialize()` method must be called before any other method. MyComponentWithHeaderOnly.Initialize(THIS); // Example of the activation of the manual control. IF ActivateManualControl THEN MyComponentWithHeaderOnly.ActivateManualControl(); END_IF; // Calling the main method `Run` with respective input and output variables. MyComponentWithHeaderOnly.Run(inReal := inHwReal, inDint := inHwDint, outReal => outHwReal, outDint => outHwDint); END_METHOD END_CLASS Inside the Main() method of the related AxoContext following rules must be applied. The Initialize() method of the extended instance of the AxoComponent must be called first. The Run() method with the respective input and output variables must be called afterwards. How to visualize AxoComponent On the UI side use the RenderableContentControl and set its Context according the placement of the instance of the AxoComponent. <RenderableContentControl Context=\"@Entry.Plc.myComponentHeaderOnlyExample.MyComponentWithHeaderOnly\" Presentation=\"Command\" /> The rendered result should then looks as follows: In case of more complex AxoComponent the most important members should be placed in the fixed part (Header) and the rest of the members should be placed inside the expandable part (Details). The members inside the expandable part should be organize inside the tabs. More complex AxoComponent Example of the implementation more complex AxoComponent with members placed also in several tabs inside the expandable part (Details). {#ix-attr:[Container(Layout.Stack)]} {#ix-set:AttributeName = \"AxoComponent example name\"} CLASS PUBLIC AxoComponentExample EXTENDS AXOpen.Core.AxoComponent METHOD PROTECTED OVERRIDE Restore: IAxoTask ; END_METHOD METHOD PROTECTED OVERRIDE ManualControl ; END_METHOD METHOD PUBLIC Run VAR_INPUT inReal : REAL; inDint : DINT; END_VAR VAR_OUTPUT outReal : REAL; outDint : DINT; END_VAR // This must be called first. SUPER.Open(); // Place the custom logic here. Status.SomeStatusValue1 := Status.SomeStatusValue1 * inReal; Status.SomeStatusValue2 := Status.SomeStatusValue2 + inDint; outReal := Status.SomeStatusValue1; outDint := Status.SomeStatusValue2; END_METHOD VAR PUBLIC // Complete structure as a part of the component header. // All structure members are going to be displayed in the component header. {#ix-attr:[Container(Layout.Wrap)]} {#ix-attr:[ComponentHeader()]} Header : Header_ComponentExample; // Two separate tasks as a part of the component header. // These tasks are going to be added to the previous members of the component header. {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Header task 1\"} HeaderTask1 : AxoTask; // Complete structure as a part of the component details tab `Tasks`. // All structure members are going to be added to the previous members of the component details tab `Tasks`. {#ix-set:AttributeName = \"Tasks\"} {#ix-attr:[Container(Layout.Stack)]} Tasks : Tasks_ComponentExample; // Single task as a part of the component details tab `Tasks`. // This task is going to be displayed in the component details tab `Tasks` {#ix-attr:[ComponentDetails(\"Tasks\")]} {#ix-attr:[Container(Layout.Stack)]} {#ix-set:AttributeName = \"Detail task in Tasks tab\"} DetailTaskInTasksTab : AxoTask; // Additional separate task as a part of the component header. // This task is going to be added to the previous members of the component header. {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Header task 2\"} HeaderTask2 : AxoTask; // Complete structure as a part of the component details tab `Status` as the attribute [ComponentDetails(\"Status\")] // is defined on the class Status_ComponentExample. // All structure members are going to be added to the previous members of the component details tab `Status`. {#ix-set:AttributeName = \"Status class\"} Status :Status_ComponentExample; // Single variable as a part of the component details tab `Status`. // This variable is going to be added to the previous members of the component details tab `Status`. {#ix-attr:[ComponentDetails(\"Status\")]} {#ix-attr:[Container(Layout.Stack)]} {#ix-set:AttributeName = \"Status string\"} Status2 : string; // Additional separate task as a part of the component header. // This task is going to be added to the previous members of the component header. {#ix-attr:[ComponentHeader()]} {#ix-set:AttributeName = \"Header task 3\"} HeaderTask3 : AxoTask; // Complete structure as a part of the component details tab `Settings` as the attribute [ComponentDetails(\"Settings\")] // is defined on the class Settings_ComponentExample. // All structure members are going to be added to the previous members of the component details tab `Settings`. {#ix-set:AttributeName = \"Settings\"} Settings : Settings_ComponentExample; // Complete structure as a part of the component details tab `Diagnostics` as the attribute [ComponentDetails(\"Diagnostics\")] // is defined on the class Diagnostics_ComponentExample. git // All structure members are going to be added to the previous members of the component details tab `Diagnostics`. {#ix-set:AttributeName = \"Diagnostics\"} Diagnostics : Diagnostics_ComponentExample; // Complete structure as a part of the component details tab `Help` as the attribute [ComponentDetails(\"Help\")] // is defined on the class Help_ComponentExample. // All structure members are going to be added to the previous members of the component details tab `Help`. {#ix-set:AttributeName = \"Help\"} Help : Help_ComponentExample; END_VAR END_CLASS For the complex types of the AxoComponent it is also recomended to organize partial groups of the members into the classes as it is in this example. CLASS PUBLIC Header_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Start\"} Start : AxoTask; {#ix-set:AttributeName = \"Stop\"} Stop : AxoTask; {#ix-set:AttributeName = \"Status\"} Status : STRING:='Some status description'; END_VAR END_CLASS {#ix-attr:[Container(Layout.Stack)]} {#ix-attr:[ComponentDetails(\"Tasks\")]} CLASS PUBLIC Tasks_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some status value 1\"} SomeStatusValue1 : REAL := REAL#45.3; {#ix-set:AttributeName = \"Some advanced component task 1\"} SomeAdvancedComponentTask1 : AxoTask; {#ix-set:AttributeName = \"Some advanced component task 2\"} SomeAdvancedComponentTask2 : AxoTask; {#ix-set:AttributeName = \"Some advanced component task 3\"} SomeAdvancedComponentTask3 : AxoTask; {#ix-set:AttributeName = \"Some advanced component task 4\"} SomeAdvancedComponentTask4 : AxoTask; {#ix-set:AttributeName = \"Some advanced component task 5\"} SomeAdvancedComponentTask5 : AxoTask; END_VAR END_CLASS {#ix-attr:[Container(Layout.Stack)]} {#ix-attr:[ComponentDetails(\"Status\")]} CLASS PUBLIC Status_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some status value 1\"} SomeStatusValue1 : REAL := REAL#45.3; {#ix-set:AttributeName = \"Some status value 2\"} SomeStatusValue2 : DINT := DINT#46587; {#ix-set:AttributeName = \"Some status value 3\"} SomeStatusValue3 : STRING := 'some description'; END_VAR END_CLASS {#ix-attr:[ComponentDetails(\"Settings\")]} {#ix-attr:[Container(Layout.Stack)]} CLASS PUBLIC Settings_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some setting value 1\"} SomeSettingValue1 : REAL := REAL#45.3; {#ix-set:AttributeName = \"Some setting value 2\"} SomeSettingValue2 : DINT := DINT#46587; {#ix-set:AttributeName = \"Some setting value 3\"} SomeSettingValue3 : STRING := 'some setting'; END_VAR END_CLASS {#ix-attr:[ComponentDetails(\"Diagnostics\")]} {#ix-attr:[Container(Layout.Stack)]} CLASS PUBLIC Diagnostics_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some diagnostic message\"} SomeDiagnosticMessage : STRING := 'TODO: Some diagnostic message needs to be placed here'; END_VAR END_CLASS {#ix-attr:[ComponentDetails(\"Help\")]} {#ix-attr:[Container(Layout.Stack)]} CLASS PUBLIC Help_ComponentExample VAR PUBLIC {#ix-set:AttributeName = \"Some help\"} SomeHelp : STRING := 'TODO: Provide some help'; END_VAR END_CLASS Instantiate and call the AxoComponent instance. CLASS ComponentExampleContext EXTENDS AxoContext VAR PUBLIC {#ix-set:AttributeName = \"Component example name\"} MyComponent : AxoComponentExample; {#ix-set:AttributeName = \"<#Activate manual control#>\"} ActivateManualControl : BOOL; inHwReal : REAL := REAL#1.0001; inHwDint : DINT := DINT#1; outHwReal : REAL; outHwDint : DINT; END_VAR METHOD PROTECTED OVERRIDE Main // The `Initialize()` method must be called before any other method. MyComponent.Initialize(THIS); // Example of the activation of the manual control. IF ActivateManualControl THEN MyComponent.ActivateManualControl(); END_IF; // Calling the main method `Run` with respective input and output variables. MyComponent.Run(inReal := inHwReal, inDint := inHwDint, outReal => outHwReal, outDint => outHwDint); END_METHOD END_CLASS UI side of the AxoComponent. <RenderableContentControl Context=\"@Entry.Plc.myComponentExample.MyComponent\" Presentation=\"Command\" /> and the rendered result: Alarm Level AxoComponent provides visual indicators to represent different alarm levels. Below is an explanation of each alarm level and its corresponding visual indicator. 1. No Alarms Description: No active alarms or messages are present. Icon: There's no visual indicator for this state. 2. Unacknowledged Description: There are messages that are waiting for acknowledgment. 3. Active Info Description: Active informational messages are present. 4. Active Warnings Description: Active warning messages are present. 5. Active Errors Description: Active error messages are present. [!include[AlertDialog](ALERTDIALOG.md)]"
  },
  "articles/data/AxoDataExchange.html": {
    "href": "articles/data/AxoDataExchange.html",
    "title": "AxoDataExchange | System.Dynamic.ExpandoObject",
    "keywords": "AxoDataExchange Getting started Data exchange manager Data exchange object must be extended by AxoDataExchange. CLASS AxoProcessDataManager EXTENDS AXOpen.Data.AxoDataExchange VAR PUBLIC {#ix-generic:TOnline} {#ix-generic:TPlain as POCO} {#ix-attr:[AxoDataEntityAttribute]} Data : AxoProductionData; // <- Manager will operate on this member. END_VAR END_CLASS Data exchange object The data entity variable must be created. It contains data that we want to exchange between PLC and repository. This variable must be annotated with following attributes: AxoDataEntityAttribute -- unique attribute for finding a correct instance of data exchange. #ix-generic:TOnline -- type information attribute. #ix-generic:TPlain as POCO -- type information attribute. Note The AxoDataExchange object must be unique. Annotations AxoDataEntityAttribute, #ix-generic:TOnline and #ix-generic:TPlain as POCO must be attributed to only one member AxoDataExchange object, which is used to locate data object that contains data to be exchanged between PLC and the target repository. An exception is thrown when AxoDataEntityAttribute is missing or multiple members have the annotation. Note The 'Data' variable must be of a type that extends AxoDataEntity. CLASS AxoProductionData EXTENDS AXOpen.Data.AxoDataEntity VAR PUBLIC {#ix-set:AttributeName = \"Some string data\"} SomeData : STRING; {#ix-set:AttributeName = \"Some number\"} SomeNumber : INT; {#ix-set:AttributeName = \"Some boolean\"} SomeBool : BOOL; END_VAR END_CLASS Data exchange initialization in PLC As mentioned earlier, we use remote calls to execute the CRUD operations. These calls are a variant of AxoTask, which allows for invoking a C# code. We will now need to create an instance of AxoProcessDataManager in a context object (AxoContext) (or as a member of another class that derives from AxoObject). We will also need to call DataManager in the Main method of appropriate context. CLASS PUBLIC Context EXTENDS AXOpen.Core.AxoContext VAR PUBLIC DataManager : AxoProcessDataManager; END_VAR METHOD OVERRIDE Main DataManager.Run(THIS); END_METHOD END_CLASS Instantiate context in a configuration CONFIGURATION MyConfiguration VAR_GLOBAL _myContext : Context; END_VAR END_CONFIGURATION Execute the context in a program PROGRAM MAIN VAR_EXTERNAL _myContext : Context; END_VAR _myContext.Run(); Data exchange initialization in .NET At this point, we have everything ready in the PLC. We must now tell the DataManager what repository to use. As a example, data repository is set as JSON files. Let's create a configuration for the repository and initialize remote data exchange: var exampleRepositorySettings = new AXOpen.Data.Json.JsonRepositorySettings<Pocos.AxoDataExamplesDocu.AxoProductionData>( Path.Combine(Environment.CurrentDirectory, \"exampledata\")); var exampleRepository = Ix.Repository.Json.Repository.Factory(exampleRepositorySettings); Entry.Plc.AxoDataExamplesDocu.DataManager.InitializeRemoteDataExchange(exampleRepository); Note MyData should be of type from Pocos. Usage Now we can freely shuffle the data between PLC and the local folder. CLASS UseManager VAR _create : BOOL; _read : BOOL; _update : BOOL; _delete : BOOL; _id : STRING; END_VAR METHOD Use VAR_IN_OUT DataManager : AxoProcessDataManager; END_VAR IF(_create) THEN IF(DataManager.Create(_id).IsDone()) THEN _create := FALSE; END_IF; END_IF; IF(_read) THEN IF(DataManager.Read(_id).IsDone()) THEN _read := FALSE; END_IF; END_IF; IF(_update) THEN IF(DataManager.Update(_id).IsDone()) THEN _update := FALSE; END_IF; END_IF; IF(_delete) THEN IF(DataManager.Delete(_id).IsDone()) THEN _delete := FALSE; END_IF; END_IF; END_METHOD END_CLASS Tracking changes Every change to the data is meticulously tracked and saved. These changes are recorded in two distinct locations: Directly in the Database - Each record maintains its own history of changes: { \"ComesFrom\": 1, \"GoesTo\": 0, \"RecordId\": null, \"Changes\": [ { \"DateTime\": \"2020-10-10T10:10:10.00\", \"UserName\": \"admin\", \"ValueTag\": { \"HumanReadable\": \"PneumaticManipulator.ProcessData.Shared.Set.ComesFrom\", \"Symbol\": \"Context.PneumaticManipulator.ProcessData.Shared.Set.ComesFrom\" }, \"OldValue\": 0, \"NewValue\": 1 } ], \"DataEntityId\": \"testRecord\" } In Logs - All operations involving records are meticulously logged: [10:10:10 INF] Create testRecord in examples.PneumaticManipulator.ProcessDataManger by user action. { UserName = admin } [10:10:10 INF] Value change Context.PneumaticManipulator.ProcessData.Shared.Set.ComesFrom of testRecord from 0 to 1 changed by user action. { UserName = admin } Every action as creation, update, deletion, or copying data is captured in the logs. Also every record has its own set of changes. Its important to note that modifications originating from the PLC are not logged, tracked, or saved. Locking When a client is in the process of editing, copying, or attempting to delete a record, the entire repository becomes locked. While the repository is locked, no one can make edits to records, until the repository is unlocked. Important The repository is locked by clicking on the edit, copy, or delete buttons, and it can be unlocked by clicking the save or close button. If the modal is closed in an incorrect manner, such as clicking outside of it, the repository will remain locked. Hashing Data are hashed each time they are created or updated. To enable hash verification, you can add the attribute: {#ix-attr:[AXOpen.Data.AxoDataVerifyHashAttribute]} above the data manager. With this attribute in place, the hash will be checked whenever you interact with the data. In case the verification process fails, a log will be generated, and the user will be warned about external modifications to the record. Data visualization Automated rendering using RenderableContentControl With Command presentation type, options exist for adding, editing, and deleting records. <RenderableContentControl Context=\"Entry.Plc.AxoDataExamplesDocu.DataManager\" Presentation=\"Command\"></RenderableContentControl> If you use Status presentation type, data will be only displayed and cannot be manipulated. <RenderableContentControl Context=\"Entry.Plc.AxoDataExamplesDocu.DataManager\" Presentation=\"Status\"></RenderableContentControl> Custom columns There is a possibility to add custom columns if it is needed. You must add AXOpen.Data.ColumnData view as a child in DataView. The BindingValue must be set in ColumnData and contains a string representing the attribute name of custom columns. If you want to add a custom header name, you can set the name in HeaderName attribute. Also, there is an attribute to make the column not clickable, which is clickable by default. The example using all attributes: <DataExchangeView Vm=\"VM\" Presentation=\"Command\"> <ColumnData HeaderName=\"Some data\" BindingValue=\"SomeData\" Clickable=\"false\" /> <ColumnData HeaderName=\"A number\" BindingValue=\"SomeNumber\" Clickable=\"false\" /> <ColumnData HeaderName=\"Yes/No\" BindingValue=\"SomeBool\" Clickable=\"false\" /> </DataExchangeView> When adding data view manually, you will need to create ViewModel: @code { protected DataExchangeViewModel VM { get; } = new () { Model = Entry.Plc.AxoDataExamplesDocu.DataManager }; } Export/Import If you want to be able to export data, you must add CanExport attribute with true value. Like this: <DataView Vm=\"@ViewModel.DataViewModel\" Presentation=\"Command\" CanExport=\"true\" /> With this option, buttons for export and import data will appear. After clicking on the export button, the .zip file will be created, which contains all existing records. If you want to import data, you must upload .zip file with an equal data structure as we get in the export file. Custom export You have the option to customize the exported files according to your preferences. This includes selecting specific columns and rows, choosing the desired file type, and specifying the separator. It's important to note that if you don't select all columns for export, importing the files may not be done correctly. During the importing process, it is crucial to enter the same separator that was used during the export. If the default separator was used during the export, there is no need to make any changes. You also can create own exporter. To do this, you must create a class that implements IDataExporter<TPlain, TOnline> interface. This interface requires you to implement the Export, Import and GetName method. Once you've done this, your custom exporter will be displayed in the custom export and import modal view. Users will be able to choose the exported file type through this view. For a better user experience, it is strongly recommended to clean the Temp directory when starting the application. The best way to do this is to add the following lines to the \"Program.cs\" file: // Clean Temp directory IAxoDataExchange.CleanUp(); Important Export and import functions creates high load on the application. Don't use them with large datasets. These function can be used only on a limited number (100 or less) documents. Typical usage would be for recipes and settings, but not for large collections of production or event data. Modal detail view The Detail View of a record is shown like modal. That means if you click on some record, the modal window with a detail view will be shown. If necessary, this option can be changed with ModalDetailView attribute. This change will show a detail view under the record table. Example with ModalDetailView attribute: <DataView Vm=\"@ViewModel.DataViewModel\" Presentation=\"Command\" ModalDetailView=\"false\" />"
  },
  "articles/data/AxoDataFragmentExchange.html": {
    "href": "articles/data/AxoDataFragmentExchange.html",
    "title": "AxoDataFragmentExchange | System.Dynamic.ExpandoObject",
    "keywords": "AxoDataFragmentExchange Fragment data exchange allows to group of multiple data managers into a single object and perform repository operations jointly on all nested repositories. Data fragment exchange manager We must create a class extending the AxoDataFragmentExchange for the data fragment exchange to work. CLASS ProcessDataManager EXTENDS AXOpen.Data.AxoDataFragmentExchange VAR PUBLIC {#ix-attr:[AXOpen.Data.AxoDataFragmentAttribute]} SharedHeader : SharedDataHeaderManger; {#ix-attr:[AXOpen.Data.AxoDataFragmentAttribute]} Station_1 : Station_1_ProcessDataManger; END_VAR END_CLASS Nesting AxoDataExchanger(s) AxoDataFragmenExchange can group several data managers where each can point to a different repository. Nested data managers must be set up as explained here. Note Note that each data manager must be annotated with AXOpen.Data.AxoDataFragmentAttribute that will provide information to the parent manager that the member takes part in data operations. Important First data manager declared as a fragment is considered a master fragment. The overview and list of existing data are retrieved only from the master fragment. Initialization and handling in the controller We will now need to create an instance of AxoDataFragmentExchange in a context object (AxoContext) (or as a member of another class that derives from AxoObject). We will also need to call AxoDataFragmentExchangeContext in the Main method of appropriate context. CLASS AxoDataFragmentExchangeContext EXTENDS AXOpen.Core.AxoContext VAR PUBLIC ProcessData : ProcessDataManager; END_VAR METHOD PROTECTED OVERRIDE Main // This is required to run cyclically. Method provides handling of data exchange tasks. ProcessData.Run(THIS); END_METHOD END_CLASS Instantiate context in a configuration CONFIGURATION MyConfiguration VAR_GLOBAL _myContext : AxoDataFragmentExchangeContext; END_VAR END_CONFIGURATION Execute the context in a program. PROGRAM MAIN VAR_EXTERNAL _myContext : AxoDataFragmentExchangeContext; END_VAR _myContext.Run(); Data exchange initialization in .NET At this point, we have everything ready in the PLC. If the nested data exchange object does not have the repository set previously, we will need to tell the to fragment manager wich repositories we be used by in data exchange. We will work with data stored in files in JSON format. var scatteredDataBuilder = Entry.Plc.AxoDataFragmentExchangeContext.ProcessData.CreateBuilder<AxoDataFramentsExchangeDocuExample.ProcessDataManager>(); // Setting up repositories scatteredDataBuilder.SharedHeader.SetRepository(new JsonRepository<Pocos.AxoDataFramentsExchangeDocuExample.SharedDataHeaderData>( new AXOpen.Data.Json.JsonRepositorySettings<Pocos.AxoDataFramentsExchangeDocuExample.SharedDataHeaderData>(Path.Combine(Environment.CurrentDirectory, \"bin\", \"data-framents-docu\", \"set\")))); scatteredDataBuilder.Station_1.SetRepository( new JsonRepository<Pocos.AxoDataFramentsExchangeDocuExample.Station_1_Data>( new AXOpen.Data.Json.JsonRepositorySettings<Pocos.AxoDataFramentsExchangeDocuExample.Station_1_Data>(Path.Combine(Environment.CurrentDirectory, \"bin\", \"data-framents\", \"fm\")))); Note MyData should be of type from Pocos. Usage Now we can freely shuffle the data between PLC and the local folder. CLASS UseManager VAR _create : BOOL; _read : BOOL; _update : BOOL; _delete : BOOL; _id : STRING; END_VAR METHOD Use VAR_IN_OUT DataFragmentManager : ProcessDataManager; END_VAR IF(_create) THEN IF(DataFragmentManager.Create(_id).IsDone()) THEN _create := FALSE; END_IF; END_IF; IF(_read) THEN IF(DataFragmentManager.Read(_id).IsDone()) THEN _read := FALSE; END_IF; END_IF; IF(_update) THEN IF(DataFragmentManager.Update(_id).IsDone()) THEN _update := FALSE; END_IF; END_IF; IF(_delete) THEN IF(DataFragmentManager.Delete(_id).IsDone()) THEN _delete := FALSE; END_IF; END_IF; END_METHOD END_CLASS Tracking changes Every change to the data is meticulously tracked and saved. These changes are recorded in two distinct locations: Directly in the Database - Each record maintains its own history of changes: { \"ComesFrom\": 1, \"GoesTo\": 0, \"RecordId\": null, \"Changes\": [ { \"DateTime\": \"2020-10-10T10:10:10.00\", \"UserName\": \"admin\", \"ValueTag\": { \"HumanReadable\": \"PneumaticManipulator.ProcessData.Shared.Set.ComesFrom\", \"Symbol\": \"Context.PneumaticManipulator.ProcessData.Shared.Set.ComesFrom\" }, \"OldValue\": 0, \"NewValue\": 1 } ], \"DataEntityId\": \"testRecord\" } In Logs - All operations involving records are meticulously logged: [10:10:10 INF] Create testRecord in examples.PneumaticManipulator.ProcessDataManger by user action. { UserName = admin } [10:10:10 INF] Value change Context.PneumaticManipulator.ProcessData.Shared.Set.ComesFrom of testRecord from 0 to 1 changed by user action. { UserName = admin } Every action as creation, update, deletion, or copying data is captured in the logs. Also every record has its own set of changes. Its important to note that modifications originating from the PLC are not logged, tracked, or saved. Locking When a client is in the process of editing, copying, or attempting to delete a record, the entire repository becomes locked. While the repository is locked, no one can make edits to records, until the repository is unlocked. Important The repository is locked by clicking on the edit, copy, or delete buttons, and it can be unlocked by clicking the save or close button. If the modal is closed in an incorrect manner, such as clicking outside of it, the repository will remain locked. Hashing Data are hashed each time they are created or updated. To enable hash verification, you can add the attribute: {#ix-attr:[AXOpen.Data.AxoDataVerifyHashAttribute]} above the data manager. With this attribute in place, the hash will be checked whenever you interact with the data. In case the verification process fails, a log will be generated, and the user will be warned about external modifications to the record. Data visualization Automated rendering using RenderableContentControl With Command presentation type, options exist for adding, editing, and deleting records. <RenderableContentControl Context=\"Entry.Plc.AxoDataFragmentExchangeContext.ProcessData\" Presentation=\"Command\"></RenderableContentControl> If you use Status presentation type, data will be only displayed and cannot be manipulated. <RenderableContentControl Context=\"Entry.Plc.AxoDataFragmentExchangeContext.ProcessData\" Presentation=\"Status\"></RenderableContentControl> Custom columns There is a possibility to add custom columns if it is needed. You must add AXOpen.Data.ColumnData view as a child in DataView. The BindingValue must be set in ColumnData and contains a string representing the attribute name of custom columns. If you want to add a custom header name, you can set the name in HeaderName attribute. Also, there is an attribute to make the column not clickable, which is clickable by default. The example using all attributes: <DataExchangeView Vm=\"VM\" Presentation=\"Command\"> <ColumnData HeaderName=\"Some data\" BindingValue=\"SomeData\" Clickable=\"false\" /> <ColumnData HeaderName=\"A number\" BindingValue=\"SomeNumber\" Clickable=\"false\" /> <ColumnData HeaderName=\"Yes/No\" BindingValue=\"SomeBool\" Clickable=\"false\" /> </DataExchangeView> When adding data view manually, you will need to create ViewModel: @code { protected DataExchangeViewModel VM { get; } = new() { Model = Entry.Plc.AxoDataFragmentExchangeContext.ProcessData }; } Note Custom columns can only added from master fragment (first declared repository). Export/Import If you want to be able to export data, you must add CanExport attribute with true value. Like this: <DataView Vm=\"@ViewModel.DataViewModel\" Presentation=\"Command\" CanExport=\"true\" /> With this option, buttons for export and import data will appear. After clicking on the export button, the .zip file will be created, which contains all existing records. If you want to import data, you must upload .zip file with an equal data structure as we get in the export file. Custom export You have the option to customize the exported files according to your preferences. This includes selecting specific columns and rows, choosing the desired file type, and specifying the separator. It's important to note that if you don't select all columns for export, importing the files may not be done correctly. During the importing process, it is crucial to enter the same separator that was used during the export. If the default separator was used during the export, there is no need to make any changes. You also can create own exporter. To do this, you must create a class that implements IDataExporter<TPlain, TOnline> interface. This interface requires you to implement the Export, Import and GetName method. Once you've done this, your custom exporter will be displayed in the custom export and import modal view. Users will be able to choose the exported file type through this view. For a better user experience, it is strongly recommended to clean the Temp directory when starting the application. The best way to do this is to add the following lines to the \"Program.cs\" file: // Clean Temp directory IAxoDataExchange.CleanUp(); Important Export and import function will create high load on the application. Don't use with large datasets. These function can be used only on a limited number (100 or less) documents. Typical used would be for recipes and settings, but not for large collections of production or event data. Modal detail view The Detail View is default shown like modal view. That means if you click on some record, the modal window with a detail view will be shown. If necessary, this option can be changed with ModalDetailView attribute. This change will show a detail view under the record table. Example with ModalDetailView attribute: <DataExchangeView Vm=\"@ViewModel.DataViewModel\" Presentation=\"Command\" ModalDetailView=\"false\" />"
  },
  "articles/data/README.html": {
    "href": "articles/data/README.html",
    "title": "AXOpen.Data | System.Dynamic.ExpandoObject",
    "keywords": "AXOpen.Data AXOpen.Data provides data exchange between the controller and an arbitrary repository. AXOpen.Data library provides a simple yet powerful data exchange between PLC and an arbitrary data repository. It includes the implementation of a series of repository operations known as CRUD (Create Read Update Delete), accessible directly from the PLC. Benefits The main benefit of this solution is data scalability; once the repository is set up, any modification of the data structure(s) will result in an automatic update of mapped objects. And therefore, there is no need for additional coding and configuration. How it works The basic PLC block is AxoDataExchange, which has its .NET counterpart (or .NET twin) that handles complex repository operations using a modified AxoRemoteTask, which is a form of RPC (Remote Procedure Call), that allows you to execute the code from the PLC in a remote .NET application. Implemented repositories The AxoDataExchange uses a predefined interface, IRepository, that allows for the virtually unlimited implementation of different target repositories. At this point, AXOpen supports these repositories directly: InMemory Json MongoDB RavenDB AxoDataExchange Getting started Data exchange manager Data exchange object must be extended by AxoDataExchange. CLASS AxoProcessDataManager EXTENDS AXOpen.Data.AxoDataExchange VAR PUBLIC {#ix-generic:TOnline} {#ix-generic:TPlain as POCO} {#ix-attr:[AxoDataEntityAttribute]} Data : AxoProductionData; // <- Manager will operate on this member. END_VAR END_CLASS Data exchange object The data entity variable must be created. It contains data that we want to exchange between PLC and repository. This variable must be annotated with following attributes: AxoDataEntityAttribute -- unique attribute for finding a correct instance of data exchange. #ix-generic:TOnline -- type information attribute. #ix-generic:TPlain as POCO -- type information attribute. Note The AxoDataExchange object must be unique. Annotations AxoDataEntityAttribute, #ix-generic:TOnline and #ix-generic:TPlain as POCO must be attributed to only one member AxoDataExchange object, which is used to locate data object that contains data to be exchanged between PLC and the target repository. An exception is thrown when AxoDataEntityAttribute is missing or multiple members have the annotation. Note The 'Data' variable must be of a type that extends AxoDataEntity. CLASS AxoProductionData EXTENDS AXOpen.Data.AxoDataEntity VAR PUBLIC {#ix-set:AttributeName = \"Some string data\"} SomeData : STRING; {#ix-set:AttributeName = \"Some number\"} SomeNumber : INT; {#ix-set:AttributeName = \"Some boolean\"} SomeBool : BOOL; END_VAR END_CLASS Data exchange initialization in PLC As mentioned earlier, we use remote calls to execute the CRUD operations. These calls are a variant of AxoTask, which allows for invoking a C# code. We will now need to create an instance of AxoProcessDataManager in a context object (AxoContext) (or as a member of another class that derives from AxoObject). We will also need to call DataManager in the Main method of appropriate context. CLASS PUBLIC Context EXTENDS AXOpen.Core.AxoContext VAR PUBLIC DataManager : AxoProcessDataManager; END_VAR METHOD OVERRIDE Main DataManager.Run(THIS); END_METHOD END_CLASS Instantiate context in a configuration CONFIGURATION MyConfiguration VAR_GLOBAL _myContext : Context; END_VAR END_CONFIGURATION Execute the context in a program PROGRAM MAIN VAR_EXTERNAL _myContext : Context; END_VAR _myContext.Run(); Data exchange initialization in .NET At this point, we have everything ready in the PLC. We must now tell the DataManager what repository to use. As a example, data repository is set as JSON files. Let's create a configuration for the repository and initialize remote data exchange: var exampleRepositorySettings = new AXOpen.Data.Json.JsonRepositorySettings<Pocos.AxoDataExamplesDocu.AxoProductionData>( Path.Combine(Environment.CurrentDirectory, \"exampledata\")); var exampleRepository = Ix.Repository.Json.Repository.Factory(exampleRepositorySettings); Entry.Plc.AxoDataExamplesDocu.DataManager.InitializeRemoteDataExchange(exampleRepository); Note MyData should be of type from Pocos. Usage Now we can freely shuffle the data between PLC and the local folder. CLASS UseManager VAR _create : BOOL; _read : BOOL; _update : BOOL; _delete : BOOL; _id : STRING; END_VAR METHOD Use VAR_IN_OUT DataManager : AxoProcessDataManager; END_VAR IF(_create) THEN IF(DataManager.Create(_id).IsDone()) THEN _create := FALSE; END_IF; END_IF; IF(_read) THEN IF(DataManager.Read(_id).IsDone()) THEN _read := FALSE; END_IF; END_IF; IF(_update) THEN IF(DataManager.Update(_id).IsDone()) THEN _update := FALSE; END_IF; END_IF; IF(_delete) THEN IF(DataManager.Delete(_id).IsDone()) THEN _delete := FALSE; END_IF; END_IF; END_METHOD END_CLASS Tracking changes Every change to the data is meticulously tracked and saved. These changes are recorded in two distinct locations: Directly in the Database - Each record maintains its own history of changes: { \"ComesFrom\": 1, \"GoesTo\": 0, \"RecordId\": null, \"Changes\": [ { \"DateTime\": \"2020-10-10T10:10:10.00\", \"UserName\": \"admin\", \"ValueTag\": { \"HumanReadable\": \"PneumaticManipulator.ProcessData.Shared.Set.ComesFrom\", \"Symbol\": \"Context.PneumaticManipulator.ProcessData.Shared.Set.ComesFrom\" }, \"OldValue\": 0, \"NewValue\": 1 } ], \"DataEntityId\": \"testRecord\" } In Logs - All operations involving records are meticulously logged: [10:10:10 INF] Create testRecord in examples.PneumaticManipulator.ProcessDataManger by user action. { UserName = admin } [10:10:10 INF] Value change Context.PneumaticManipulator.ProcessData.Shared.Set.ComesFrom of testRecord from 0 to 1 changed by user action. { UserName = admin } Every action as creation, update, deletion, or copying data is captured in the logs. Also every record has its own set of changes. Its important to note that modifications originating from the PLC are not logged, tracked, or saved. Locking When a client is in the process of editing, copying, or attempting to delete a record, the entire repository becomes locked. While the repository is locked, no one can make edits to records, until the repository is unlocked. Important The repository is locked by clicking on the edit, copy, or delete buttons, and it can be unlocked by clicking the save or close button. If the modal is closed in an incorrect manner, such as clicking outside of it, the repository will remain locked. Hashing Data are hashed each time they are created or updated. To enable hash verification, you can add the attribute: {#ix-attr:[AXOpen.Data.AxoDataVerifyHashAttribute]} above the data manager. With this attribute in place, the hash will be checked whenever you interact with the data. In case the verification process fails, a log will be generated, and the user will be warned about external modifications to the record. Data visualization Automated rendering using RenderableContentControl With Command presentation type, options exist for adding, editing, and deleting records. <RenderableContentControl Context=\"Entry.Plc.AxoDataExamplesDocu.DataManager\" Presentation=\"Command\"></RenderableContentControl> If you use Status presentation type, data will be only displayed and cannot be manipulated. <RenderableContentControl Context=\"Entry.Plc.AxoDataExamplesDocu.DataManager\" Presentation=\"Status\"></RenderableContentControl> Custom columns There is a possibility to add custom columns if it is needed. You must add AXOpen.Data.ColumnData view as a child in DataView. The BindingValue must be set in ColumnData and contains a string representing the attribute name of custom columns. If you want to add a custom header name, you can set the name in HeaderName attribute. Also, there is an attribute to make the column not clickable, which is clickable by default. The example using all attributes: <DataExchangeView Vm=\"VM\" Presentation=\"Command\"> <ColumnData HeaderName=\"Some data\" BindingValue=\"SomeData\" Clickable=\"false\" /> <ColumnData HeaderName=\"A number\" BindingValue=\"SomeNumber\" Clickable=\"false\" /> <ColumnData HeaderName=\"Yes/No\" BindingValue=\"SomeBool\" Clickable=\"false\" /> </DataExchangeView> When adding data view manually, you will need to create ViewModel: @code { protected DataExchangeViewModel VM { get; } = new () { Model = Entry.Plc.AxoDataExamplesDocu.DataManager }; } Export/Import If you want to be able to export data, you must add CanExport attribute with true value. Like this: <DataView Vm=\"@ViewModel.DataViewModel\" Presentation=\"Command\" CanExport=\"true\" /> With this option, buttons for export and import data will appear. After clicking on the export button, the .zip file will be created, which contains all existing records. If you want to import data, you must upload .zip file with an equal data structure as we get in the export file. Custom export You have the option to customize the exported files according to your preferences. This includes selecting specific columns and rows, choosing the desired file type, and specifying the separator. It's important to note that if you don't select all columns for export, importing the files may not be done correctly. During the importing process, it is crucial to enter the same separator that was used during the export. If the default separator was used during the export, there is no need to make any changes. You also can create own exporter. To do this, you must create a class that implements IDataExporter<TPlain, TOnline> interface. This interface requires you to implement the Export, Import and GetName method. Once you've done this, your custom exporter will be displayed in the custom export and import modal view. Users will be able to choose the exported file type through this view. For a better user experience, it is strongly recommended to clean the Temp directory when starting the application. The best way to do this is to add the following lines to the \"Program.cs\" file: // Clean Temp directory IAxoDataExchange.CleanUp(); Important Export and import functions creates high load on the application. Don't use them with large datasets. These function can be used only on a limited number (100 or less) documents. Typical usage would be for recipes and settings, but not for large collections of production or event data. Modal detail view The Detail View of a record is shown like modal. That means if you click on some record, the modal window with a detail view will be shown. If necessary, this option can be changed with ModalDetailView attribute. This change will show a detail view under the record table. Example with ModalDetailView attribute: <DataView Vm=\"@ViewModel.DataViewModel\" Presentation=\"Command\" ModalDetailView=\"false\" /> AxoDataFragmentExchange Fragment data exchange allows to group of multiple data managers into a single object and perform repository operations jointly on all nested repositories. Data fragment exchange manager We must create a class extending the AxoDataFragmentExchange for the data fragment exchange to work. CLASS ProcessDataManager EXTENDS AXOpen.Data.AxoDataFragmentExchange VAR PUBLIC {#ix-attr:[AXOpen.Data.AxoDataFragmentAttribute]} SharedHeader : SharedDataHeaderManger; {#ix-attr:[AXOpen.Data.AxoDataFragmentAttribute]} Station_1 : Station_1_ProcessDataManger; END_VAR END_CLASS Nesting AxoDataExchanger(s) AxoDataFragmenExchange can group several data managers where each can point to a different repository. Nested data managers must be set up as explained here. Note Note that each data manager must be annotated with AXOpen.Data.AxoDataFragmentAttribute that will provide information to the parent manager that the member takes part in data operations. Important First data manager declared as a fragment is considered a master fragment. The overview and list of existing data are retrieved only from the master fragment. Initialization and handling in the controller We will now need to create an instance of AxoDataFragmentExchange in a context object (AxoContext) (or as a member of another class that derives from AxoObject). We will also need to call AxoDataFragmentExchangeContext in the Main method of appropriate context. CLASS AxoDataFragmentExchangeContext EXTENDS AXOpen.Core.AxoContext VAR PUBLIC ProcessData : ProcessDataManager; END_VAR METHOD PROTECTED OVERRIDE Main // This is required to run cyclically. Method provides handling of data exchange tasks. ProcessData.Run(THIS); END_METHOD END_CLASS Instantiate context in a configuration CONFIGURATION MyConfiguration VAR_GLOBAL _myContext : AxoDataFragmentExchangeContext; END_VAR END_CONFIGURATION Execute the context in a program. PROGRAM MAIN VAR_EXTERNAL _myContext : AxoDataFragmentExchangeContext; END_VAR _myContext.Run(); Data exchange initialization in .NET At this point, we have everything ready in the PLC. If the nested data exchange object does not have the repository set previously, we will need to tell the to fragment manager wich repositories we be used by in data exchange. We will work with data stored in files in JSON format. var scatteredDataBuilder = Entry.Plc.AxoDataFragmentExchangeContext.ProcessData.CreateBuilder<AxoDataFramentsExchangeDocuExample.ProcessDataManager>(); // Setting up repositories scatteredDataBuilder.SharedHeader.SetRepository(new JsonRepository<Pocos.AxoDataFramentsExchangeDocuExample.SharedDataHeaderData>( new AXOpen.Data.Json.JsonRepositorySettings<Pocos.AxoDataFramentsExchangeDocuExample.SharedDataHeaderData>(Path.Combine(Environment.CurrentDirectory, \"bin\", \"data-framents-docu\", \"set\")))); scatteredDataBuilder.Station_1.SetRepository( new JsonRepository<Pocos.AxoDataFramentsExchangeDocuExample.Station_1_Data>( new AXOpen.Data.Json.JsonRepositorySettings<Pocos.AxoDataFramentsExchangeDocuExample.Station_1_Data>(Path.Combine(Environment.CurrentDirectory, \"bin\", \"data-framents\", \"fm\")))); Note MyData should be of type from Pocos. Usage Now we can freely shuffle the data between PLC and the local folder. CLASS UseManager VAR _create : BOOL; _read : BOOL; _update : BOOL; _delete : BOOL; _id : STRING; END_VAR METHOD Use VAR_IN_OUT DataFragmentManager : ProcessDataManager; END_VAR IF(_create) THEN IF(DataFragmentManager.Create(_id).IsDone()) THEN _create := FALSE; END_IF; END_IF; IF(_read) THEN IF(DataFragmentManager.Read(_id).IsDone()) THEN _read := FALSE; END_IF; END_IF; IF(_update) THEN IF(DataFragmentManager.Update(_id).IsDone()) THEN _update := FALSE; END_IF; END_IF; IF(_delete) THEN IF(DataFragmentManager.Delete(_id).IsDone()) THEN _delete := FALSE; END_IF; END_IF; END_METHOD END_CLASS Tracking changes Every change to the data is meticulously tracked and saved. These changes are recorded in two distinct locations: Directly in the Database - Each record maintains its own history of changes: { \"ComesFrom\": 1, \"GoesTo\": 0, \"RecordId\": null, \"Changes\": [ { \"DateTime\": \"2020-10-10T10:10:10.00\", \"UserName\": \"admin\", \"ValueTag\": { \"HumanReadable\": \"PneumaticManipulator.ProcessData.Shared.Set.ComesFrom\", \"Symbol\": \"Context.PneumaticManipulator.ProcessData.Shared.Set.ComesFrom\" }, \"OldValue\": 0, \"NewValue\": 1 } ], \"DataEntityId\": \"testRecord\" } In Logs - All operations involving records are meticulously logged: [10:10:10 INF] Create testRecord in examples.PneumaticManipulator.ProcessDataManger by user action. { UserName = admin } [10:10:10 INF] Value change Context.PneumaticManipulator.ProcessData.Shared.Set.ComesFrom of testRecord from 0 to 1 changed by user action. { UserName = admin } Every action as creation, update, deletion, or copying data is captured in the logs. Also every record has its own set of changes. Its important to note that modifications originating from the PLC are not logged, tracked, or saved. Locking When a client is in the process of editing, copying, or attempting to delete a record, the entire repository becomes locked. While the repository is locked, no one can make edits to records, until the repository is unlocked. Important The repository is locked by clicking on the edit, copy, or delete buttons, and it can be unlocked by clicking the save or close button. If the modal is closed in an incorrect manner, such as clicking outside of it, the repository will remain locked. Hashing Data are hashed each time they are created or updated. To enable hash verification, you can add the attribute: {#ix-attr:[AXOpen.Data.AxoDataVerifyHashAttribute]} above the data manager. With this attribute in place, the hash will be checked whenever you interact with the data. In case the verification process fails, a log will be generated, and the user will be warned about external modifications to the record. Data visualization Automated rendering using RenderableContentControl With Command presentation type, options exist for adding, editing, and deleting records. <RenderableContentControl Context=\"Entry.Plc.AxoDataFragmentExchangeContext.ProcessData\" Presentation=\"Command\"></RenderableContentControl> If you use Status presentation type, data will be only displayed and cannot be manipulated. <RenderableContentControl Context=\"Entry.Plc.AxoDataFragmentExchangeContext.ProcessData\" Presentation=\"Status\"></RenderableContentControl> Custom columns There is a possibility to add custom columns if it is needed. You must add AXOpen.Data.ColumnData view as a child in DataView. The BindingValue must be set in ColumnData and contains a string representing the attribute name of custom columns. If you want to add a custom header name, you can set the name in HeaderName attribute. Also, there is an attribute to make the column not clickable, which is clickable by default. The example using all attributes: <DataExchangeView Vm=\"VM\" Presentation=\"Command\"> <ColumnData HeaderName=\"Some data\" BindingValue=\"SomeData\" Clickable=\"false\" /> <ColumnData HeaderName=\"A number\" BindingValue=\"SomeNumber\" Clickable=\"false\" /> <ColumnData HeaderName=\"Yes/No\" BindingValue=\"SomeBool\" Clickable=\"false\" /> </DataExchangeView> When adding data view manually, you will need to create ViewModel: @code { protected DataExchangeViewModel VM { get; } = new() { Model = Entry.Plc.AxoDataFragmentExchangeContext.ProcessData }; } Note Custom columns can only added from master fragment (first declared repository). Export/Import If you want to be able to export data, you must add CanExport attribute with true value. Like this: <DataView Vm=\"@ViewModel.DataViewModel\" Presentation=\"Command\" CanExport=\"true\" /> With this option, buttons for export and import data will appear. After clicking on the export button, the .zip file will be created, which contains all existing records. If you want to import data, you must upload .zip file with an equal data structure as we get in the export file. Custom export You have the option to customize the exported files according to your preferences. This includes selecting specific columns and rows, choosing the desired file type, and specifying the separator. It's important to note that if you don't select all columns for export, importing the files may not be done correctly. During the importing process, it is crucial to enter the same separator that was used during the export. If the default separator was used during the export, there is no need to make any changes. You also can create own exporter. To do this, you must create a class that implements IDataExporter<TPlain, TOnline> interface. This interface requires you to implement the Export, Import and GetName method. Once you've done this, your custom exporter will be displayed in the custom export and import modal view. Users will be able to choose the exported file type through this view. For a better user experience, it is strongly recommended to clean the Temp directory when starting the application. The best way to do this is to add the following lines to the \"Program.cs\" file: // Clean Temp directory IAxoDataExchange.CleanUp(); Important Export and import function will create high load on the application. Don't use with large datasets. These function can be used only on a limited number (100 or less) documents. Typical used would be for recipes and settings, but not for large collections of production or event data. Modal detail view The Detail View is default shown like modal view. That means if you click on some record, the modal window with a detail view will be shown. If necessary, this option can be changed with ModalDetailView attribute. This change will show a detail view under the record table. Example with ModalDetailView attribute: <DataExchangeView Vm=\"@ViewModel.DataViewModel\" Presentation=\"Command\" ModalDetailView=\"false\" />"
  },
  "articles/guidelines/components.html": {
    "href": "articles/guidelines/components.html",
    "title": "WORK IN PORGRESS | System.Dynamic.ExpandoObject",
    "keywords": "WORK IN PORGRESS Components REVISION DATE NOTES 0.0 June 2023 Initial release 0.1 August 2023 Initial release 0.2 August 2023 Documentation requirements and others This document describes the format and practices for writing components in TcOpen. These are universal rules to observe. Each rule knows exception when there is a reasonable argument behind it. General rules Component must inherit from AXOpen.Core.AxoComponent Components methods and properties should not be marked FINAL (sealed) Component should implement appropriate INTERFACE for a public contract; this is the interface that the consumers of the library will use to interact with the component. It represents the public contract that must not change during the lifetime of the particular major version of the library/framework. See semantic versioning. Component members must explicitly state access modifier for methods and properties (PUBLIC, INTERNAL, PROTECTED, or PRIVATE) Component should properly hide implementation details by marking methods preferably PROTECTED. Consider using the PRIVATE access modifier to prevent any access to that member if you deem it necessary. Be aware, though, that private members cannot be overridden by a derived class. If there are any testing methods in the same library with the component, these must be marked INTERNAL. Each action of the component should be implemented using the AxoTask class. There is no exception to this rule, even for the actions that require a single cycle to complete. Task's Invoke should be placed into a method with an appropriate name (MoveAbsolute, MoveHome, Measure). Cyclic call Each component implements the logic required to run cyclically in the Run method of the CLASS. Components methods The methods that perform actions MUST return AXOpen.IAxoTaskStatus (typically AXOpen.Core.AxoTask). This rule applies even to the logic that requires a single-cycle execution. Library placement Library must be placed in src folder of the repository. The containing folder should be named components.[manufacturer].[function_group] (e.g. components.cognex.vision). Abstractions Each component should implement basic contract interface defined in the AxoAbstractions library (e.g. AxoAbbRobot should implenent IAxoRobot, AxoCognexReader should impement IAxoReader) I/O variables Components must not contain I/O (%I*, %Q*) variables directly (no AT directive). I/O variables naming The AxOpen does not use Hungarian prefixes, with few exceptions. IN/OUT and REF_TO method argument parameters are one of those exceptions where it is required to use prefixes ino and ref respectively. Structure Config Config structure can contain arbitrary data relative to the configuration of the component (timeouts, parameters, etc.). Config type must be STRUCT. Config data class must be named in the following format {ComponentName}Config (e.g. AxoCylinderConfig) Config class must be accessible via GetConfig method that returns REF_TO {ComponentName}Config. The backing field of the Config property must be named Config (it must be public to allow access from higher level application) Config class can contain multiple nested and complex classes when it is necessary to organize better the information. Nested classes must be CLASS and must be named in the following format {ComponentName}Config{Specifier} where specifier is descriptive name of the nested information. Wherever possible the data must be initialized to default values (e.g., timeouts, speeds etc.). The default settings should not prevent the component from functioning unless there is a specific requirement to provide parameters relative to the component model or a particular hardware configuration (drive model, gearing ratio, etc.). Each data member of the Config structure must be documented in the code, with an example. Whenever possible, a link to more detailed documentation must also be provided in the in-code documentation. Method SetConfig should be implemented when it is expected an external provision of configuration at runtime. Status Status class can contain arbitrary data relative to the state of the component. Status type must be CLASS. Status data structure must be named in the following format {ComponentName}Status (e.g. AxoCylinderStatus) Status structure must be accessible via GetStatus method that returns RET_TO {ComponentName}Status. - The backing field of the Status must be named Status (it must be public to allow access from higher level application). Status class can contain multiple nested and complex classes when it is necessary to organize the information. Nested structures must be CLASSEs and must be named in the following format {ComponentName}State{Specifier} where specifier is descriptive name of the nested information. Each data member of the Status structure must be documented in the code, with an example. Whenever possible, a link to more detailed documentation must also be provided in the in-code documentation. Tasks Operations are run by tasks (AxoTask). Member variable of the task must have the following format {OperationName}Task. Each task must be exposed via a method in the following format {OperationName} that will return IAxoTaskStatus. Executing logic of a task is run from the Run method of components class. States States are properties or methods that retrieve information about arbitrary states that do not require multiple cycles to return the result (sensor's signal state). All state-related members must be placed into States folder of the component. Component requirements Each component must inherit from AXOpen.Core.AxoComponent, which is an abstract block that requires concrete implementation of following memebers: Restore() method that restores the component into intial state and ManualControl() method that provided additional logic for manual control. Restore() must contain logic that will bring the component's internal states into the initial state. Restore method does not mean getting the component into physical ground position/state; it serves purely the purpose of having the component ready for operations from the programatic perspective. ManualControl() method is required to be implemented. It can contain arbitrary logic that will be executed while the component is in a serviceable state. Each component must implement Run method that will provide cyclic execution of tasks, I/O update, data transformation for given component. Run method is not formally required by AxoComponent and it can take arguments necessary for the cylic update and execution. For variaous scenarions component can implement different Run methods taking advantage of method overload. Components naming conventions The components for particular components are placed into appropriate library. Library name reflects the name of the manufacturer and the class of the product. POUs that belongs to a specific component reflect the product name and products' version information. UNIT NAME PATTERN EXAMPLE (fully qualified name) Library (namespace) AXOpen.{Manufacturer}.[{Group}] AXOpen.ABB.Robotics CLASS v_{ModelVersion}.Axo{Model} AXOpen.ABB.Robotics.v_1_0_0.AxoOmnicore CLASS Config v_{ModelVersion}.Axo{Model}_Config AXOpen.ABB.Robotics.v_1_0_0.AxoOmnicore_Config CLASS Status v_{ModelVersion}.Axo{Model}_Status AXOpen.ABB.Robotics.v_1_0_0.AxoOmnicore_Status other v_{ModelVersion}.Axo{Model}_{DescriptiveName} AXOpen.ABB.Robotics.v_1_0_0.AxoOmnicore_Aux Testing requirements Each public and protected controller's method must be unit-tested using axunit. When reasonable use integration testing using prober library to test the interaction between controller and .NET twin. Documentation requirements Public classes Public and protected members (methods, fields) must have in code documentation. See Documentation comments for more details and docfx markup. Public methods than implement actions and initialization must have application examples (should be referenced from the actuall app code). PLC Application examples should be placed in app/src/Documentation/ of the library folder, the code should be compilable and functional to the extent it is possible with ommited hardware. NET twin examples should be places in app/ix-blazor and app/ix folder. For details how to reference code snippet see here."
  },
  "articles/guidelines/Conventions.html": {
    "href": "articles/guidelines/Conventions.html",
    "title": "WORK IN PROGRESS... | System.Dynamic.ExpandoObject",
    "keywords": "WORK IN PROGRESS... AXOpen Conventions REVISION DATE NOTES 0.0 July 2023 Initial release Introduction Thanks for taking the time to read this document. Here we aim to outline a set of rules that will help us write consistent libraries that will serve their other consumers and us. This document follows recommendations from SIMATIC-AX ST Style guide for AXOpen project(s). This document defines the minimum coding standards and will be updated as the project develops in time. Why do we need to agree on conventions They create a consistent look to the code so that readers can focus on content, not layout. They enable readers to understand the code more quickly by making assumptions based on previous experience. They facilitate copying, changing, and maintaining the code. They demonstrate Structured Text best practices. A general note on naming Names should be self-describing, readable considered in calling context. Use of prefixes is discouraged, except for those outlined in this document. For example to inform/warn about some property like a reference, IN_OUT reference, or to aid to IntelliSense to narrow the scope of search. General note on the use of PLC-Language AXOpen uses exclusively IEC 61131-3 Structured Test (ST). Namespaces Each type must be enclosed in an appropriate namespace. Orphaned types with no namespace are not allowed. Naming Type Naming Block type Notation Prefix Example FB/CLASS name PascalCase NoPrefix Cyclinder ENUM type name PascalCase e eMachineState.Start INTERFACE name PascalCase I ICyclinder FUNCTION name PascalCase NoPrefix Add() STRUCT name PascalCase NoPrefix Data CLASS member naming Variable section Notation Prefix Example METHOD name PascalCase NoPrefix MoveToWork() METHOD arguments camelCase NoPrefix targetPosition : LREAL *PROPERTY name PascalCase NoPrefix IsEnabled CLASS member naming Variable section Notation Prefix Example VAR_INPUT camelCase in inActualPosition : LREAL VAR_OUTPUT camelCase out outActualPosition : LREAL VAR_IN_OUT camelCase ino inoActualPosition : LREAL VAR camelCase _ _actualPosition : LREAL, VAR_STAT camelCase _ _actualPosition : LREAL, VAR_INST camelCase _ _actualPosition : LREAL , VAR CONSTANT UpperCase NoPrefix MAX_747_CRUISING_ALTITUDE REFERENCE PascalCase ref refDrive INTERFACE name PascalCase NoPrefix Cyclinder STRUCT member naming Group Notation Prefix Example VARIABLE PascalCase NoPrefix ActualPosition REFERENCE PascalCase ref refDrive INTERFACE name PascalCase NoPrefix Cyclinder Features to avoid Avoid Use instead FUNCTION_BLOCK CLASS Features to prefer IF YOU REALLY MUST EVERYWHERE ELSE FUNCTION CLASS.METHOD Identifiers Any identifier (variable, methods, properties) should have an identifier that clearly expresses intent. Identifiers with less than 4 characters should be avoided (unless they represent well-known acronyms or expressions). There is no formal constraint on a maximum number of characters; however, about 25 characters should suffice to name the variable appropriately. Scope All variables should be declared closest to the scope where they are used. Avoid using global declarations unless it is necessary or the global scope is required for the application. Global scope Generally, the global scope should be avoided where possible. Member Variables Private CLASS member variables should begin with underscore _, followed by the variable name. VAR PRIVATE _trigger : BOOL; _counter : INT; _analogStatus : AnalogStatus; END_VAR Constants Use constants instead of magic numbers. Constants should be all caps. Where magic numbers are required for low-level domain-specific operations, these should be managed in the highest level block that makes sense without breaking an abstraction layer. Arrays Arrays should be 0 based index due to consistency when used on HMI platforms (based on JavaScript, TypeScript, C#). VAR myArray : ARRAY[0..9] OF BOOL; // Prefered myArray1 : ARRAY[1..10] OF BOOL; // AVOID END_VAR Namespaces Variables defined in referenced libraries must be declared using a fully qualified name with the namespace. VAR _mixer : fbMixer; // AVOID! _mixer : Mixers.fbMixer; // Like this END_VAR Methods Methods names should clearly state the intent. Method name should not have any prefix. The methods should be used to perform some action (Movement, Measurement, Trigger etc.). For obtaining or setting values, prefer properties. piston.MoveToWork(); laser.Measure(); dmcReader.Trigger(); Properties* Property names should clearly describe intent. Properties should not start with any prefix. Parameter transfer in cyclic execution. Whenever a parameter transfer is required during the initialization/cyclic-update of a class, use the Run method, the parameters passed using this method must not be changed at runtime. Components Expecting future implementation"
  },
  "articles/inspectors/AXOANALOGUEINSPECTOR.html": {
    "href": "articles/inspectors/AXOANALOGUEINSPECTOR.html",
    "title": "AxoAnalogueInspector | System.Dynamic.ExpandoObject",
    "keywords": "AxoAnalogueInspector Provides evaluation of continuous values. The inspector checks that the input value falls within the limit of Min and Max. The inspection passes when the input value is within the required limit without interruption for the duration of stabilization time. Common inspector data are extended with following analogue inspector data: RequiredMin : LREAL; // min required value for inspection DetectedStatus : LREAL; // detected value RequiredMax: LREAL; // max required value for inspection"
  },
  "articles/inspectors/AXODATAINSPECTOR.html": {
    "href": "articles/inspectors/AXODATAINSPECTOR.html",
    "title": "AxoDataInspector | System.Dynamic.ExpandoObject",
    "keywords": "AxoDataInspector Provides evaluation of alphanumerical values. The input value compares against the Required value. The inspection passes when the input value matches the required value without interruption for the duration of stabilization time. In addition to exact comparison, data inspector allows for simple pattern matching where # = any number and * = any character. Common inspector data are extended with following data inspector data: RequiredStatus : STRING; //required value for inspection DetectedStatus : STRING; //detected value for inspection StarNotationEnabled: BOOL; //star notation enable/disable"
  },
  "articles/inspectors/AXODIGITALINSPECTOR.html": {
    "href": "articles/inspectors/AXODIGITALINSPECTOR.html",
    "title": "AxoDigitalInspector | System.Dynamic.ExpandoObject",
    "keywords": "AxoDigitalInspector Inspector provides evaluation of discrete value. The input value compares against the Required value. The inspection passes when the input value matches the required value without interruption for the duration of stabilization time. Common inspector data are extended with following digital inspector data: RequiredStatus : BOOL; //required value for inspection DetectedStatus : BOOL; //detected value for inspection"
  },
  "articles/inspectors/README.html": {
    "href": "articles/inspectors/README.html",
    "title": "AXOpen.Inspectors | System.Dynamic.ExpandoObject",
    "keywords": "AXOpen.Inspectors AXOpen.Inspectors provides mechanism of inspection of different types of data. The input value is compared to required value. If input value is the same as required value for a stabilization time period, the inspection will succeed. If values are different, timeout will occur and inspection will fail. Inspectors can integrate with coordination primitives like AxoSequencer. In consequence, inspectors offer extended capabilities in decision flow for failed checks. Each inspector contains: Inspect method, which input is current parent and inspection variable OnFail method, which provides methods for making a decision after a failed inspection (see Handling failure section) UpdateComprehensiveResult method, which input is object of type AxoComprehesiveResult, which can be used to gather results of all inspections. Common data about inspection inputs and result. See below. Example inspection Example of inspection within a sequencer in PLC: _presenceInspector.WithCoordinator(THIS).Inspect(THIS,_inspectionResult) .UpdateComprehensiveResult(_comprehensiveResult) .OnFail().CarryOn(); A _presenceInspector is created instance of AxoDigitalInspector A coordinator is passed to this inspector with WithCoordinator(THIS) method, in this case it is a sequencer, a parent object. Inspect methods takes parent and inspection variable, on which inspection is performing. If inspection fails, the result is updated to _comprehensiveResult object with UpdateComprehensiveResult method. If inspection fails, OnFail method provides CarryOn method, which tells the coordinator to continue in execution. Common inspector data Inspectors contain common data, which are used to store data about inspection. Each inspector contain following data: Timestamp: LDATE_AND_TIME; // timestamp of inspection PassTime : TIME; // stabilization time, inspection must be success for this period of time FailTime : TIME; // timeout, after which inspection fails Result : eInspectorResult; // result of inspection IsExcluded: BOOL; // inspection will be performed, however result will be omitted in overall result IsByPassed : BOOL; // inspection will be skipped NumberOfAllowedRetries : UINT; // maximum number of retries of inspection, from which overinspection will occur RetryAttemptsCount : UINT; // actual number of retries, if RetryAttemptsCount > NumberOfAllowedRetries, overinspection occurs AxoDigitalInspector Inspector provides evaluation of discrete value. The input value compares against the Required value. The inspection passes when the input value matches the required value without interruption for the duration of stabilization time. Common inspector data are extended with following digital inspector data: RequiredStatus : BOOL; //required value for inspection DetectedStatus : BOOL; //detected value for inspection AxoAnalogueInspector Provides evaluation of continuous values. The inspector checks that the input value falls within the limit of Min and Max. The inspection passes when the input value is within the required limit without interruption for the duration of stabilization time. Common inspector data are extended with following analogue inspector data: RequiredMin : LREAL; // min required value for inspection DetectedStatus : LREAL; // detected value RequiredMax: LREAL; // max required value for inspection AxoDataInspector Provides evaluation of alphanumerical values. The input value compares against the Required value. The inspection passes when the input value matches the required value without interruption for the duration of stabilization time. In addition to exact comparison, data inspector allows for simple pattern matching where # = any number and * = any character. Common inspector data are extended with following data inspector data: RequiredStatus : STRING; //required value for inspection DetectedStatus : STRING; //detected value for inspection StarNotationEnabled: BOOL; //star notation enable/disable Handling failure When an inspector fails, OnFail() provides a series of methods for making decisions about the process. In order for this is feature to work the inspector needs to be aware of the coordinator of IAxoCoordinator. The coordinator must be passed to the inspector by WithCoordinator(coordinator) method. Syntax Description Dialog(inRetryStep, inTerminateStep) Opens dialog for the user to take a decision. Parameter inRetryStep represent state from which the inspection should start again. Parameter inTerminateStep represent terminate state of coordinator. Retry(inRetryStep) Retries the inspector. Retry state parameter tells from which state the inspection should start again. Override() Marks the inspection as failed but continues with the following states of the coordinator. Terminate(inTerminateStep) Marks the inspection as failed and aborts the execution of the coordinator. The following example specify, that when inspection fails, dialog is shown and is requesting user decision. _valueInspector.WithCoordinator(THIS).Inspect(THIS,_inspectionValue).OnFail().Dialog(Steps[20], Steps[145]); Over-inspection When RetryAttemptsCount is same as NumberOfAllowedRetries, no more inspection are allowed, as data are overinspected. Preserving overall result Overall result of a series of inspections can be preserved in AxoComprehensiveResult. Each inspector has UpdateComprehensiveResult method that provides the update function. Once the UpdateComprehensiveResult marks the overall result as Failed, successive inspection will not overwrite the result. IF (Steps[30].Execute(THIS, TRUE, 'Example Digital inspection')) THEN _presenceInspector.WithCoordinator(THIS).Inspect(THIS,_inspectionResult) .UpdateComprehensiveResult(_comprehensiveResult) .OnFail().CarryOn(); END_IF; IF (Steps[40].Execute(THIS, TRUE, 'Example Analog inspection')) THEN _valueInspector.WithCoordinator(THIS).Inspect(THIS,_inspectionValue) .UpdateComprehensiveResult(_comprehensiveResult) .OnFail().CarryOn(); END_IF; END_IF;"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Source repositories | System.Dynamic.ExpandoObject",
    "keywords": "AXOpen is an open-source application framework project developed by a group of automation engineers. It is based on SIMATIC AX platfrom and AX# technology Source repositories AX# AXOpen Note This project is under development. We periodically release versions that can be used for testing and in non-production environments. Disclaimer Important It is necessary to have a valid license for SIMATIC AX in order to use AX# and AXOpen! SIMATIC AX is currently in a limited sales release in selected European countries only. You will need to request access from the AX team which will check if your use case is suitable for the current state of the product. The first step to getting the approval is contacting your local SIEMENS sales representative or writing an email to simatic-ax@siemens.com."
  },
  "articles/localization/README.html": {
    "href": "articles/localization/README.html",
    "title": "Template localization | System.Dynamic.ExpandoObject",
    "keywords": "Template localization Localization is a useful feature of any application. It allows you to translate the application into different languages. This guide will show you how localization is achieved in our template Blazor application - templates.simple. Prerequisites Microsoft.Extensions.Localization NuGet package Localization in Blazor To make use of localization in Blazor, make sure that: Localization services are added in Program.cs: builder.Services.AddLocalization(); Localization middleware with supported languages is added in the correct order to the middleware pipeline in Program.cs: var supportedCultures = new[] { \"en-US\", \"sk-SK\", \"es-ES\"}; var localizationOptions = new RequestLocalizationOptions() .AddSupportedCultures(supportedCultures) .AddSupportedUICultures(supportedCultures); app.UseRequestLocalization(localizationOptions); In _Imports.razor the following @using directives are added: @using System.Globalization @using Microsoft.Extensions.Localization For more information on localization in Blazor visit Microsoft Docs. Adding support for a new language In order to add a new language support to the application, a resource file (.resx) needs to be created. Resource file are in the forefront of localization in .NET. They are used to store app data (in our case strings), that can be easily accessed and changed without recompiling the app. In our template application, resource files are located in the Resources folder. Create a new resource file for the language you want to add. The name of the file should be in the following format: ResourceName.culture.resx, where culture is the culture code of the language. E.g. ResourceName.de.resx would be a resource file for German language. If you want to make resource files easier to work with, check out ResXManager extension for Visual Studio. In _Imports.razor make sure that the @using directive for the newly created resource file is added and inject the IStringLocalizer service of the resource file. E.g.: @using axosimple.hmi.Resources @inject IStringLocalizer<ResourceName> Localizer Changing the language dynamically To change the language dynamically, add a new CultureInfo object to the supportedCultures array in the code section of Index.razor. E.g.: private CultureInfo[] supportedCultures = new[] { new CultureInfo(\"en-US\"), new CultureInfo(\"sk-SK\"), new CultureInfo(\"es-ES\"), new CultureInfo(\"de-DE\") // newly added language }; When selecting a language from the <select> menu in Index.razor, a cookie with selected language is created by ChangeCulture method of CultureController. Using localized strings To use localized strings, simply use Localizer service previously injected in _Imports.razor E.g.: <h1>@Localizer[\"Hello World!\"]</h1> If the string is not found in the resource file, the key is returned instead. If it is found, however, the localized string is returned. English: Slovak: Spanish:"
  },
  "articles/logging/AXOLOGGER.html": {
    "href": "articles/logging/AXOLOGGER.html",
    "title": "Logging with AXOpen.Core | System.Dynamic.ExpandoObject",
    "keywords": "Logging with AXOpen.Core Overview In this example, we illustrate how to use the logging functionalities provided by AxoLogger. Our objective is to create and use loggers, produce log messages of various severity levels, and showcase how to access a logger from the context within a nested object. We'll be using two classes for our demonstration: Loggers and ContextLoggerInNestedObject. Loggers Class The Loggers class is an extension of AxoContext, part of the AXOpen.Core namespace. This class is the central hub for the logging actions carried out in this example. Logger Declarations We declare two instances of AxoLogger, named LoggerOne and LoggerTwo. Additionally, we declare InnerObject, which is an instance of the ContextLoggerInNestedObject class. VAR PUBLIC LoggerOne : AXOpen.Logging.AxoLogger; LoggerTwo : AXOpen.Logging.AxoLogger; InnerObject : ContextLoggerInNestedObject; END_VAR Logging Activities In the Main method, we first inject LoggerOne into THIS, which refers to the current instance of Loggers. Following this injection, we set the minimum log level for LoggerOne to Error using THIS.GetLogger().SetMinimumLevel(eLogLevel#Error);. This configuration ensures that LoggerOne will only log messages with a severity level of Error or higher. Subsequently, we create an error log message and an informational log message using LoggerOne. Note that due to the log level setting, the informational message will not be logged. Next, we inject LoggerTwo into THIS and set the minimum log level for LoggerTwo to Information using THIS.GetLogger().SetMinimumLevel(eLogLevel#Information);. This configuration will cause LoggerTwo to log all messages with a severity level of Information or higher. We then create an error log message and an informational log message using LoggerTwo. Due to the log level setting, both messages will be logged. Finally, we initialize InnerObject and invoke its Foo method to showcase logging from within a nested object. By adjusting the minimum log level for each logger, we can control the severity of messages that each logger will handle. This offers flexibility in categorizing and prioritizing log messages based on their importance. METHOD PROTECTED OVERRIDE Main // Logging to `LoggerOne` THIS.InjectLogger(LoggerOne); // This will report only Errors and more severe THIS.GetLogger().SetMinimumLevel(eLogLevel#Error); THIS.GetLogger().Log('Here I am logging an error.', eLogLevel#Error); THIS.GetLogger().Log('Here I am logging an infomation.', eLogLevel#Information); // Logging to `LoggerTwo` THIS.InjectLogger(LoggerTwo); // This will report all messages from Infomation level and more severe THIS.GetLogger().SetMinimumLevel(eLogLevel#Information); THIS.GetLogger().Log('Here I am logging an error.', eLogLevel#Error); THIS.GetLogger().Log('Here I am logging an infomation.', eLogLevel#Information); // Logging from inner object InnerObject.Initialize(THIS); InnerObject.Foo(); END_METHOD Logging from nested objects This class demonstrates how to fetch and log messages using a logger from a parent context from within a nested object. The Foo method retrieves the context's logger using THIS.GetContext().GetLogger() and logs an Error level message. This shows how to access and use the logger of a containing context, enabling nested objects to utilize the same logging functionalities as their parent. CLASS ContextLoggerInNestedObject EXTENDS AxoObject METHOD PUBLIC Foo THIS.GetContext().GetLogger().Log('Loggin on context logger', eLogLevel#Error, THIS); END_METHOD END_CLASS Summary Through this example, we've shown how to declare and utilize the AxoLogger for logging messages with different levels of severity. We've also illustrated how nested objects can retrieve and use the logger of their parent context to log messages, showcasing a flexible and potent approach to handle logging in applications with complex, nested structures. Initialization of Logger in .NET In this section, we'll be discussing how to initialize the logger in a .NET application, specifically using the Serilog library for logging. We'll also demonstrate how to link the logger to our AxoLogger instances from our previous examples: LoggerOne and LoggerTwo. Initializing Object Identities Before you start logging with AxoLogger, you need to ensure the object identities are initialized. This is important because it allows the AxoLogger to correctly identify the source of log messages, which aids in debugging and log analysis. To initialize the object identities in a .NET part of your application, use the following method: await Entry.Plc.Connector.IdentityProvider.ConstructIdentitiesAsync(); This method call is usually performed during the application initialization process, right after the AxoApplication and loggers are configured. It constructs all the identities required by the application, preparing the AxoLogger for logging. Here's how it could fit into the .NET application initialization process: // Initialize the object identities. Entry.Plc.Connector.SubscriptionMode = ReadSubscriptionMode.Polling; Entry.Plc.Connector.BuildAndStart().ReadWriteCycleDelay = 250; await Entry.Plc.Connector.IdentityProvider.ConstructIdentitiesAsync(); This sets up the AxoApplication, configures a logger with Serilog, initializes the object identities, and then connects AxoLogger instances to the application. Remember to always await the ConstructIdentitiesAsync method, as it is an asynchronous operation and your application should not proceed until it has been completed. This ensures all object identities are fully initialized before your AxoLogger instances start logging. Important Failure to initialize object identities before starting the logging process can result in incorrect or incomplete log entries, which can hinder the debugging and analysis of your application. Always ensure that object identities are correctly initialized before you start logging. Creating the AxoApplication Before initializing the logger, we first create an instance of AxoApplication using the CreateBuilder method. This sets up the application builder required for the logger configuration. var axoAppBuilder = AxoApplication.CreateBuilder(); Configuring the Logger Next, we configure our logger. We are using the Serilog library, a popular .NET logging library that allows flexible and complex logging setups. In this example, we're creating a simple setup where all logs of any level (Verbose level and above) will be written to the console. // Creates serilog logger with single sink to Console window. axoAppBuilder.ConfigureLogger(new SerilogLogger(new LoggerConfiguration() .WriteTo.Console().MinimumLevel.Verbose() .CreateLogger())); This code sets up a new Serilog logger with a single sink directed to the console window. The MinimumLevel.Verbose() method specifies that all logs, regardless of their severity level, will be outputted to the console. Connecting Loggers to the Application Finally, we connect our previously defined AxoLogger instances, LoggerOne and LoggerTwo, to our application. Entry.Plc.AxoLoggers.LoggerOne.StartDequeuing(AxoApplication.Current.Logger, 250); The StartDequeuing method is now called with two parameters. The first parameter AxoApplication.Current.Logger refers to the instance of the logger that was created and configured in the previous step. The second parameter is 250. This starts a loop that dequeues log messages from the AxoLogger's message queue every 250 milliseconds, passing them to the configured sinks—in our case, the console window. Adding Custom Target Loggers The Serilog library allows you to add and configure custom target loggers. In the previous example, we've used AxoApplication.Current.Logger as our target logger. This is the logger instance created and configured during the application setup. However, if you want to log messages to a different target, you can create and configure additional Serilog loggers. For example, you might want to create a logger that writes to a file, a database, or a remote logging server. To add a new target logger, you would follow similar steps as before, but specify your custom target in the WriteTo method. var fileLogger = new LoggerConfiguration() .WriteTo.File(\"log.txt\") .CreateLogger(); var databaseLogger = new LoggerConfiguration() .WriteTo.MyDatabase(myConnectionString) .CreateLogger(); In these examples, fileLogger is a logger that writes logs to a text file named log.txt, and databaseLogger is a logger that writes logs to a database, using a connection string myConnectionString. The WriteTo.MyDatabase(myConnectionString) method is a placeholder; replace this with the appropriate method for your specific database sink. After creating these loggers, you can connect them to your AxoLogger instances using the StartDequeuing method, just as we did before with AxoApplication.Current.Logger. Entry.Plc.AxoLoggers.LoggerOne.StartDequeuing(fileLogger, 250); Entry.Plc.AxoLoggers.LoggerTwo.StartDequeuing(databaseLogger, 250); In this configuration, LoggerOne will send its queued log messages to log.txt every quarter of a second, while LoggerTwo will send its messages to the specified database. Please note that these are just examples, and the Serilog library supports many different types of log targets (also known as \"sinks\"), which you can use to customize the logging behavior of your application as needed. Always refer to the official Serilog documentation for more detailed information and the latest features. Summary This example showcases how to initialize a logger in a .NET application using the Serilog library and then how to connect the AxoLogger instances from our Loggers class to it. With this setup, the AxoLogger instances will send their queued log messages to the console every quarter of a second. Important In the context of logging level configuration, it's important to note that the minimum logging level of the .NET logger (set up in C#) and the AxoLogger (set up in the controller's software) are independent settings. You can configure them individually to fine-tune the verbosity of your logs both at the controller level and in your .NET application. AxoLogger and AxoMessenger AxoMessenger uses Context AxoLogger to log the rising and falling of an alarm. There is no particular need for the configuration fo this behaviour. Here are the mappings between eAxoMessageCategory and eLogLevel as per the code: Trace messages are logged as Verbose. Debug messages are logged as Debug. Info, TimedOut, and Notification messages are logged as - Information. Warning messages are logged as Warning. Error and ProgrammingError messages are logged as Error. Critical, Fatal, and Catastrophic messages are logged as Fatal. Limitations Log Entry Limit Important Please note that the AxoLogger instances in this example (LoggerOne and LoggerTwo) have an internal limit of 100 log entries. This means that once the number of log entries in the logger's queue reaches this limit, any new log entries will be discarded until older log entries are dequeued and the total number drops below this limit. This limit is designed to prevent excessive memory usage if the dequeuing process is unable to keep up with the rate of new log entries. Regularly dequeuing log entries, as shown in this example with the StartDequeuing(250) calls, helps to ensure that log entries are processed promptly and do not exceed this limit. As always, it is important to consider the potential for high rates of log entries when designing your application's logging strategy and ensure that your dequeuing interval and log entry limit are appropriately configured for your specific needs. Logging Performance Considerations Important Logging in an application, while essential for debugging and monitoring, can impact the overall performance of your controller, especially when logging at high rates. The controller may have resource limitations such as CPU power and memory, which can be strained by excessive logging activities. Each log operation involves creating the log entry, formatting it, and adding it to the logger's message queue. These operations consume computational resources and memory. If the log entry queue becomes excessively large due to high logging rates and insufficient dequeuing, it can further strain the controller's resources. Also, note that the communication between the controller and the logger can introduce additional latency, especially if network-based logging is used. If a large number of log entries are sent over the network, this can congest the network and slow down other network operations. Therefore, it is crucial to balance the need for detailed logging with the impact on the controller's performance and resource usage. It's recommended to carefully select what needs to be logged based on its importance and potential to aid in debugging and monitoring. Optimizing the logging level, choosing an appropriate dequeuing interval, and regularly reviewing and maintaining your logging strategy can help to minimize the performance impact. Always keep these considerations in mind when designing and implementing logging in your applications, particularly in resource-constrained environments such as controllers."
  },
  "articles/logging/README.html": {
    "href": "articles/logging/README.html",
    "title": "Introduction to Logging with AXOpen.Core | System.Dynamic.ExpandoObject",
    "keywords": "Introduction to Logging with AXOpen.Core Effective logging is vital for monitoring the health and performance of software applications. By providing real-time insights into application behaviour and detailed diagnostic information during troubleshooting, logging plays a crucial role in development, debugging, and ongoing maintenance. In the world of PLC applications, logging can be a bit more complex due to the intricacies of the systems involved. AXOpen.Core, a library developed for industrial automation software, provides robust logging capabilities that meet these specific needs. With the AxoLogger class, it offers a potent tool for logging in both PLC controller software and .NET applications. In this guide, we explore the usage of AXOpen.Core's logging capabilities. We demonstrate how to declare, configure, and utilize the AxoLogger to log messages of various severity levels. We also cover the process of accessing a logger from within a nested object and configuring a logger in a .NET application using the Serilog library. A key aspect we will highlight is the ability to manage the verbosity of logs independently in the controller software and the .NET application, providing you with flexible control over your logging activities. Please keep in mind that excessive logging from the controller can degrade the overall system performance due to the limits imposed by the controller. There's also a limit of 100 log entries that can be stored in the logger's queue. If this limit is reached, the oldest log entries will be removed from the queue as new entries are added. Logging with AXOpen.Core Overview In this example, we illustrate how to use the logging functionalities provided by AxoLogger. Our objective is to create and use loggers, produce log messages of various severity levels, and showcase how to access a logger from the context within a nested object. We'll be using two classes for our demonstration: Loggers and ContextLoggerInNestedObject. Loggers Class The Loggers class is an extension of AxoContext, part of the AXOpen.Core namespace. This class is the central hub for the logging actions carried out in this example. Logger Declarations We declare two instances of AxoLogger, named LoggerOne and LoggerTwo. Additionally, we declare InnerObject, which is an instance of the ContextLoggerInNestedObject class. VAR PUBLIC LoggerOne : AXOpen.Logging.AxoLogger; LoggerTwo : AXOpen.Logging.AxoLogger; InnerObject : ContextLoggerInNestedObject; END_VAR Logging Activities In the Main method, we first inject LoggerOne into THIS, which refers to the current instance of Loggers. Following this injection, we set the minimum log level for LoggerOne to Error using THIS.GetLogger().SetMinimumLevel(eLogLevel#Error);. This configuration ensures that LoggerOne will only log messages with a severity level of Error or higher. Subsequently, we create an error log message and an informational log message using LoggerOne. Note that due to the log level setting, the informational message will not be logged. Next, we inject LoggerTwo into THIS and set the minimum log level for LoggerTwo to Information using THIS.GetLogger().SetMinimumLevel(eLogLevel#Information);. This configuration will cause LoggerTwo to log all messages with a severity level of Information or higher. We then create an error log message and an informational log message using LoggerTwo. Due to the log level setting, both messages will be logged. Finally, we initialize InnerObject and invoke its Foo method to showcase logging from within a nested object. By adjusting the minimum log level for each logger, we can control the severity of messages that each logger will handle. This offers flexibility in categorizing and prioritizing log messages based on their importance. METHOD PROTECTED OVERRIDE Main // Logging to `LoggerOne` THIS.InjectLogger(LoggerOne); // This will report only Errors and more severe THIS.GetLogger().SetMinimumLevel(eLogLevel#Error); THIS.GetLogger().Log('Here I am logging an error.', eLogLevel#Error); THIS.GetLogger().Log('Here I am logging an infomation.', eLogLevel#Information); // Logging to `LoggerTwo` THIS.InjectLogger(LoggerTwo); // This will report all messages from Infomation level and more severe THIS.GetLogger().SetMinimumLevel(eLogLevel#Information); THIS.GetLogger().Log('Here I am logging an error.', eLogLevel#Error); THIS.GetLogger().Log('Here I am logging an infomation.', eLogLevel#Information); // Logging from inner object InnerObject.Initialize(THIS); InnerObject.Foo(); END_METHOD Logging from nested objects This class demonstrates how to fetch and log messages using a logger from a parent context from within a nested object. The Foo method retrieves the context's logger using THIS.GetContext().GetLogger() and logs an Error level message. This shows how to access and use the logger of a containing context, enabling nested objects to utilize the same logging functionalities as their parent. CLASS ContextLoggerInNestedObject EXTENDS AxoObject METHOD PUBLIC Foo THIS.GetContext().GetLogger().Log('Loggin on context logger', eLogLevel#Error, THIS); END_METHOD END_CLASS Summary Through this example, we've shown how to declare and utilize the AxoLogger for logging messages with different levels of severity. We've also illustrated how nested objects can retrieve and use the logger of their parent context to log messages, showcasing a flexible and potent approach to handle logging in applications with complex, nested structures. Initialization of Logger in .NET In this section, we'll be discussing how to initialize the logger in a .NET application, specifically using the Serilog library for logging. We'll also demonstrate how to link the logger to our AxoLogger instances from our previous examples: LoggerOne and LoggerTwo. Initializing Object Identities Before you start logging with AxoLogger, you need to ensure the object identities are initialized. This is important because it allows the AxoLogger to correctly identify the source of log messages, which aids in debugging and log analysis. To initialize the object identities in a .NET part of your application, use the following method: await Entry.Plc.Connector.IdentityProvider.ConstructIdentitiesAsync(); This method call is usually performed during the application initialization process, right after the AxoApplication and loggers are configured. It constructs all the identities required by the application, preparing the AxoLogger for logging. Here's how it could fit into the .NET application initialization process: // Initialize the object identities. Entry.Plc.Connector.SubscriptionMode = ReadSubscriptionMode.Polling; Entry.Plc.Connector.BuildAndStart().ReadWriteCycleDelay = 250; await Entry.Plc.Connector.IdentityProvider.ConstructIdentitiesAsync(); This sets up the AxoApplication, configures a logger with Serilog, initializes the object identities, and then connects AxoLogger instances to the application. Remember to always await the ConstructIdentitiesAsync method, as it is an asynchronous operation and your application should not proceed until it has been completed. This ensures all object identities are fully initialized before your AxoLogger instances start logging. Important Failure to initialize object identities before starting the logging process can result in incorrect or incomplete log entries, which can hinder the debugging and analysis of your application. Always ensure that object identities are correctly initialized before you start logging. Creating the AxoApplication Before initializing the logger, we first create an instance of AxoApplication using the CreateBuilder method. This sets up the application builder required for the logger configuration. var axoAppBuilder = AxoApplication.CreateBuilder(); Configuring the Logger Next, we configure our logger. We are using the Serilog library, a popular .NET logging library that allows flexible and complex logging setups. In this example, we're creating a simple setup where all logs of any level (Verbose level and above) will be written to the console. // Creates serilog logger with single sink to Console window. axoAppBuilder.ConfigureLogger(new SerilogLogger(new LoggerConfiguration() .WriteTo.Console().MinimumLevel.Verbose() .CreateLogger())); This code sets up a new Serilog logger with a single sink directed to the console window. The MinimumLevel.Verbose() method specifies that all logs, regardless of their severity level, will be outputted to the console. Connecting Loggers to the Application Finally, we connect our previously defined AxoLogger instances, LoggerOne and LoggerTwo, to our application. Entry.Plc.AxoLoggers.LoggerOne.StartDequeuing(AxoApplication.Current.Logger, 250); The StartDequeuing method is now called with two parameters. The first parameter AxoApplication.Current.Logger refers to the instance of the logger that was created and configured in the previous step. The second parameter is 250. This starts a loop that dequeues log messages from the AxoLogger's message queue every 250 milliseconds, passing them to the configured sinks—in our case, the console window. Adding Custom Target Loggers The Serilog library allows you to add and configure custom target loggers. In the previous example, we've used AxoApplication.Current.Logger as our target logger. This is the logger instance created and configured during the application setup. However, if you want to log messages to a different target, you can create and configure additional Serilog loggers. For example, you might want to create a logger that writes to a file, a database, or a remote logging server. To add a new target logger, you would follow similar steps as before, but specify your custom target in the WriteTo method. var fileLogger = new LoggerConfiguration() .WriteTo.File(\"log.txt\") .CreateLogger(); var databaseLogger = new LoggerConfiguration() .WriteTo.MyDatabase(myConnectionString) .CreateLogger(); In these examples, fileLogger is a logger that writes logs to a text file named log.txt, and databaseLogger is a logger that writes logs to a database, using a connection string myConnectionString. The WriteTo.MyDatabase(myConnectionString) method is a placeholder; replace this with the appropriate method for your specific database sink. After creating these loggers, you can connect them to your AxoLogger instances using the StartDequeuing method, just as we did before with AxoApplication.Current.Logger. Entry.Plc.AxoLoggers.LoggerOne.StartDequeuing(fileLogger, 250); Entry.Plc.AxoLoggers.LoggerTwo.StartDequeuing(databaseLogger, 250); In this configuration, LoggerOne will send its queued log messages to log.txt every quarter of a second, while LoggerTwo will send its messages to the specified database. Please note that these are just examples, and the Serilog library supports many different types of log targets (also known as \"sinks\"), which you can use to customize the logging behavior of your application as needed. Always refer to the official Serilog documentation for more detailed information and the latest features. Summary This example showcases how to initialize a logger in a .NET application using the Serilog library and then how to connect the AxoLogger instances from our Loggers class to it. With this setup, the AxoLogger instances will send their queued log messages to the console every quarter of a second. Important In the context of logging level configuration, it's important to note that the minimum logging level of the .NET logger (set up in C#) and the AxoLogger (set up in the controller's software) are independent settings. You can configure them individually to fine-tune the verbosity of your logs both at the controller level and in your .NET application. AxoLogger and AxoMessenger AxoMessenger uses Context AxoLogger to log the rising and falling of an alarm. There is no particular need for the configuration fo this behaviour. Here are the mappings between eAxoMessageCategory and eLogLevel as per the code: Trace messages are logged as Verbose. Debug messages are logged as Debug. Info, TimedOut, and Notification messages are logged as - Information. Warning messages are logged as Warning. Error and ProgrammingError messages are logged as Error. Critical, Fatal, and Catastrophic messages are logged as Fatal. Limitations Log Entry Limit Important Please note that the AxoLogger instances in this example (LoggerOne and LoggerTwo) have an internal limit of 100 log entries. This means that once the number of log entries in the logger's queue reaches this limit, any new log entries will be discarded until older log entries are dequeued and the total number drops below this limit. This limit is designed to prevent excessive memory usage if the dequeuing process is unable to keep up with the rate of new log entries. Regularly dequeuing log entries, as shown in this example with the StartDequeuing(250) calls, helps to ensure that log entries are processed promptly and do not exceed this limit. As always, it is important to consider the potential for high rates of log entries when designing your application's logging strategy and ensure that your dequeuing interval and log entry limit are appropriately configured for your specific needs. Logging Performance Considerations Important Logging in an application, while essential for debugging and monitoring, can impact the overall performance of your controller, especially when logging at high rates. The controller may have resource limitations such as CPU power and memory, which can be strained by excessive logging activities. Each log operation involves creating the log entry, formatting it, and adding it to the logger's message queue. These operations consume computational resources and memory. If the log entry queue becomes excessively large due to high logging rates and insufficient dequeuing, it can further strain the controller's resources. Also, note that the communication between the controller and the logger can introduce additional latency, especially if network-based logging is used. If a large number of log entries are sent over the network, this can congest the network and slow down other network operations. Therefore, it is crucial to balance the need for detailed logging with the impact on the controller's performance and resource usage. It's recommended to carefully select what needs to be logged based on its importance and potential to aid in debugging and monitoring. Optimizing the logging level, choosing an appropriate dequeuing interval, and regularly reviewing and maintaining your logging strategy can help to minimize the performance impact. Always keep these considerations in mind when designing and implementing logging in your applications, particularly in resource-constrained environments such as controllers."
  },
  "articles/messaging/AXOMESSENGER.html": {
    "href": "articles/messaging/AXOMESSENGER.html",
    "title": "AxoMessenger | System.Dynamic.ExpandoObject",
    "keywords": "AxoMessenger Static AxoMessenger is a class that provides mechanism for delivering static message to the supervising applications (SCADA/HMI). This static messenger uses the text defined in the declaration. This text cannot be changed during runtime as the text is \"transfered\" just once during the compilation and it is not read during the runtime. The PLC code of the AxoMessenger just ensures the activation, deactivation and acknowledgement of the message. AxoMessenger contains following public methods. Serve() - this method must be called cyclically. It ensures the inicialization of the instance, so as the deactivation of the message. classDiagram class AxoMessenger{ +Serve(IAxoContext _context) +Serve(IAxoObject _object) } Activate(category) - this method immediatelly activate the message of the category where category is of the type eAxoMessageCategory. Deactivation is detected after one PLC cycle without calling the method Activate. ActivateOnCondition(condition,category) - this method activate the message of the category where category is of the type eAxoMessageCategory on the rising edge of the condition and imidiatelly deactivate the message on the falling edge of the condition. The ActivateOnCondition method is designed to be called cyclically. Note Do not use the both activation methods on the same AxoMessenger instance, please use just one of them. Acknowledge() - acknowledge the message if required. The message could be acknowledged so as before deactivation so as after. Depending on the eAxoMessageCategory the messenger should require the acknowledgement. By default the acknowledgement is not required for the levels Trace,Debug,Info,TimedOut,Notification and Warning. This could be overwritten by calling the RequireAcknowledgement() method. Contrariwise, the acknowledgement is required for the levels Error,ProgrammingError,Critical,Fatal and Catastrophic by default. This could be overwritten by calling the DoNotRequireAcknowledgement() method. Attributes MessageText and Help These attributes are used to set the values of the static texts of the messenger. These values are read out at the compilation time transfered to .NET counterpart and set as a constant strings. Therefore they can't be changed at the runtime. Example of declaration the instance and defining the attributes MessageText and Help. {#ix-set:MessageText = \"<#Message text for messenger 1#>\"} {#ix-set:Help = \"<#Help text for messenger 1#>\"} _messenger1 : AXOpen.Messaging.Static.AxoMessenger; How to use AxoMessenger The instance of the AxoMessenger must be defined inside the AxoContext or AxoObject. Inside the Main() method of the related AxoContext or inside the cyclically called method of the AxoObject following rules must be applied. The Serve() method of the instance of the AxoMessenger must be called cyclically. The Activate method should be used called the required condition or the AcitvateOnCondition should be called cyclically. Avoid to mix using the both methods with the same instance. CLASS Messengers EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:MessageText = \"<#Message text for messenger 1#>\"} {#ix-set:Help = \"<#Help text for messenger 1#>\"} _messenger1 : AXOpen.Messaging.Static.AxoMessenger; _messenger1condition : BOOL; {#ix-set:MessageText = \"<#Message text for messenger 2#>\"} {#ix-set:MessageText = \"<#Message text for messenger 2#>\"} _messenger2 : AXOpen.Messaging.Static.AxoMessenger; _messenger2condition : BOOL; END_VAR METHOD PROTECTED OVERRIDE Main _messenger1.Serve(THIS); IF _messenger1condition THEN _messenger1.Activate(eAxoMessageCategory#Error); END_IF; _messenger2.Serve(THIS); _messenger2.ActivateOnCondition(_messenger2condition,eAxoMessageCategory#Warning); END_METHOD END_CLASS If neccessary, the default behaviour of the acknowledgeable messenger should be changed as follows. _messenger2.ActivateOnCondition(_messenger2condition,eAxoMessageCategory#Error).DoNotRequireAcknowledgement(); Contrariwise, the default behaviour of the unacknowledgeable messenger should be changed as follows. _messenger2.ActivateOnCondition(_messenger2condition,eAxoMessageCategory#Warning).RequireAcknowledgement(); How to visualize AxoMessenger On the UI side use the RenderableContentControl and set its Context according the placement of the instance of the AxoMessenger. <RenderableContentControl Context=\"@Entry.Plc.AxoMessengersDocu._messenger1\" Presentation=\"Command-Control\" Class=\"ps-2\"/> See also AxoLogger"
  },
  "articles/messaging/README.html": {
    "href": "articles/messaging/README.html",
    "title": "AXOpen.Messaging | System.Dynamic.ExpandoObject",
    "keywords": "AXOpen.Messaging AXOpen.Messaging provides basic blocks for providing messaging. Basic concepts AxoMessenger Static AxoMessenger is a class that provides mechanism for delivering static message to the supervising applications (SCADA/HMI). This static messenger uses the text defined in the declaration. This text cannot be changed during runtime as the text is \"transfered\" just once during the compilation and it is not read during the runtime. The PLC code of the AxoMessenger just ensures the activation, deactivation and acknowledgement of the message. AxoMessenger contains following public methods. Serve() - this method must be called cyclically. It ensures the inicialization of the instance, so as the deactivation of the message. classDiagram class AxoMessenger{ +Serve(IAxoContext _context) +Serve(IAxoObject _object) } Activate(category) - this method immediatelly activate the message of the category where category is of the type eAxoMessageCategory. Deactivation is detected after one PLC cycle without calling the method Activate. ActivateOnCondition(condition,category) - this method activate the message of the category where category is of the type eAxoMessageCategory on the rising edge of the condition and imidiatelly deactivate the message on the falling edge of the condition. The ActivateOnCondition method is designed to be called cyclically. Note Do not use the both activation methods on the same AxoMessenger instance, please use just one of them. Acknowledge() - acknowledge the message if required. The message could be acknowledged so as before deactivation so as after. Depending on the eAxoMessageCategory the messenger should require the acknowledgement. By default the acknowledgement is not required for the levels Trace,Debug,Info,TimedOut,Notification and Warning. This could be overwritten by calling the RequireAcknowledgement() method. Contrariwise, the acknowledgement is required for the levels Error,ProgrammingError,Critical,Fatal and Catastrophic by default. This could be overwritten by calling the DoNotRequireAcknowledgement() method. Attributes MessageText and Help These attributes are used to set the values of the static texts of the messenger. These values are read out at the compilation time transfered to .NET counterpart and set as a constant strings. Therefore they can't be changed at the runtime. Example of declaration the instance and defining the attributes MessageText and Help. {#ix-set:MessageText = \"<#Message text for messenger 1#>\"} {#ix-set:Help = \"<#Help text for messenger 1#>\"} _messenger1 : AXOpen.Messaging.Static.AxoMessenger; How to use AxoMessenger The instance of the AxoMessenger must be defined inside the AxoContext or AxoObject. Inside the Main() method of the related AxoContext or inside the cyclically called method of the AxoObject following rules must be applied. The Serve() method of the instance of the AxoMessenger must be called cyclically. The Activate method should be used called the required condition or the AcitvateOnCondition should be called cyclically. Avoid to mix using the both methods with the same instance. CLASS Messengers EXTENDS AXOpen.Core.AxoContext VAR PUBLIC {#ix-set:MessageText = \"<#Message text for messenger 1#>\"} {#ix-set:Help = \"<#Help text for messenger 1#>\"} _messenger1 : AXOpen.Messaging.Static.AxoMessenger; _messenger1condition : BOOL; {#ix-set:MessageText = \"<#Message text for messenger 2#>\"} {#ix-set:MessageText = \"<#Message text for messenger 2#>\"} _messenger2 : AXOpen.Messaging.Static.AxoMessenger; _messenger2condition : BOOL; END_VAR METHOD PROTECTED OVERRIDE Main _messenger1.Serve(THIS); IF _messenger1condition THEN _messenger1.Activate(eAxoMessageCategory#Error); END_IF; _messenger2.Serve(THIS); _messenger2.ActivateOnCondition(_messenger2condition,eAxoMessageCategory#Warning); END_METHOD END_CLASS If neccessary, the default behaviour of the acknowledgeable messenger should be changed as follows. _messenger2.ActivateOnCondition(_messenger2condition,eAxoMessageCategory#Error).DoNotRequireAcknowledgement(); Contrariwise, the default behaviour of the unacknowledgeable messenger should be changed as follows. _messenger2.ActivateOnCondition(_messenger2condition,eAxoMessageCategory#Warning).RequireAcknowledgement(); How to visualize AxoMessenger On the UI side use the RenderableContentControl and set its Context according the placement of the instance of the AxoMessenger. <RenderableContentControl Context=\"@Entry.Plc.AxoMessengersDocu._messenger1\" Presentation=\"Command-Control\" Class=\"ps-2\"/> See also AxoLogger"
  },
  "articles/rendering/intro.html": {
    "href": "articles/rendering/intro.html",
    "title": "Automatic rendering in IXF | System.Dynamic.ExpandoObject",
    "keywords": "Automatic rendering in IXF IFX uses IX rendering for many advanced features. This document describes basic information about presentation used in IXF. Renderable content control Presentation type Description Command Provides access to UI control with ability to control/modfiy the component. Status Provides access to UI control with no ability to modify and control the component."
  },
  "articles/security/INSTALLATION.html": {
    "href": "articles/security/INSTALLATION.html",
    "title": "Installation | System.Dynamic.ExpandoObject",
    "keywords": "Installation All necessary logic for security is located in AxOpen.Security library. 1. Install AxOpen.Security NuGet package or add reference to this project 2. Add reference to AxOpen.Security assembly. Go to App.razor and add AdditionalAssemblies as parameter of Router component. The following line must be added to Router component: AdditionalAssemblies=\"new[] { typeof(BlazorSecurity).Assembly}\"> Also, make sure, that Router component is wrapped inside CascadingAuthenticationState component. At the end, the Router component should look like this: <CascadingAuthenticationState> <Router AppAssembly=\"@typeof(App).Assembly\" AdditionalAssemblies=\"new[] { typeof(BlazorSecurity).Assembly}\"> ... </Router> </CascadingAuthenticationState> 3. Configure Ax Blazor security services in dependency injection container of Blazor application located in Program.cs file. To correctly configure security services you must: configure repository create in-app roles configure AxBlazorSecurity in DI container Configuring repository The security requires 2 instances of repositories: for persistence of user data for persistence of groups of roles Within AXOpen 4 different types of repositories are available: InMemory Json MongoDB RavenDB For example, the Json repository can be configured as follows: static (IRepository<User>, IRepository<Group>) SetUpJSon(string path = \"..\\\\..\\\\..\\\\..\\\\..\\\\JSONREPOS\\\\\") { var executingAssemblyFile = new FileInfo(Assembly.GetExecutingAssembly().Location); var repositoryDirectory = Path.GetFullPath($\"{executingAssemblyFile.Directory}{path}\"); if (!Directory.Exists(repositoryDirectory)) { Directory.CreateDirectory(repositoryDirectory); } IRepository<User> userRepo = new JsonRepository<User>(new JsonRepositorySettings<User>(Path.Combine(repositoryDirectory, \"Users\"))); IRepository<Group> groupRepo = new JsonRepository<Group>(new JsonRepositorySettings<Group>(Path.Combine(repositoryDirectory, \"Groups\"))); return (userRepo, groupRepo); } Add SetUpJson method in Program.cs file. Creating in-app roles In your Blazor application create new static class Roles and specify the roles, that will be used in your application. You can add as many roles as you want. The Roles class can be defined like this: public static class Roles { public static List<Role> CreateRoles() { var roles = new List<Role> { new Role(process_settings_access), new Role(process_traceability_access), }; return roles; } public const string process_settings_access = nameof(process_settings_access); public const string process_traceability_access = nameof(process_traceability_access); } Configure AxBlazorSecurity services Finally, the AxBlazorSecurity security can be configured in DI container of Blazor application. Go to Program.cs file and add following line to builder: builder.Services.ConfigureAxBlazorSecurity(SetUpJSon(), Roles.CreateRoles()); The first parameter is set up repository and the second parameter are created roles. 4. Add security views to application Go to MainLayout.razor located in Shared folder and add LoginDisplay view inside top bar. <main> <div class=\"top-row px-4 auth\"> <AxOpen.Security.Views.LoginDisplay/> </div> <article class=\"content px-4\"> @Body </article> </main> Within Pages of the Blazor application, create new Security.razor page and add there SecurityManagementView. @page \"/Security\" <h3>Security</h3> <AxOpen.Security.Views.SecurityManagementView /> Add you security view inside the navigation menu in NavMenu.razor: <div class=\"nav-item px-3\"> <NavLink class=\"nav-link\" href=\"security\"> <span class=\"oi oi-list-rich\" aria-hidden=\"true\"></span> Security </NavLink> </div> Default login If everything done correctly, now security should be available in Blazor application. Now it should be possible to log-in with default user. The default user is created on application startup with following credentials: Username: admin Password: admin The user has default Administrator role and is in default AdminGroup."
  },
  "articles/security/README.html": {
    "href": "articles/security/README.html",
    "title": "AXOpen.Security | System.Dynamic.ExpandoObject",
    "keywords": "AXOpen.Security AxOpen.Security is library which provides authentication and authorization in Blazor AX applications. It is based on a default solution for authentication in Blazor, which is extended by using implemented repositories within Ax.Open.Data. As a result, multiple storage providers for security can be used. Installation The security library is available in form of NuGet package. Detailed installation instructions of security into empty Blazor project is located in security installation article. Basic concepts Each user is limited to having just a single group. A group is formed by a collection of multiple roles. When a user is assigned to a group, they possess all the roles associated with that group. It is possible for a single role to be assigned to multiple groups. Security views SecurityManagementView component serves for managing users. It is available only if user is logged in with administrator rights. When user is logged in with administrator rights, it is possible to modify all available users and groups. Administrator can delete users or change group. User management The SecurityManagementView component includes a tab dedicated to user management. Within this tab, users can be updated or newly created. When a user is selected, a card is displayed showing the current data for that user, there is an option to update or delete user. Group Management The SecurityManagementView component includes a tab for group management. Within this tab, groups can be updated or newly created. When a group is selected, a card is displayed showing the assigned roles for that group. Users have the option assigned or unassign roles or delete group. Account Management In account management view is possible to change the your user data, like email address or password. User Create In user create view is possible to new user. AuthorizeView and AuthenticationContext There are two ways how to work with authentication and authorization. Use of the AuthorizeView component in Blazor component Use of the AuthenticationStateProvider within a C# class Use of AuthorizeView The AuthorizeView is used to create a secure views within a Blazor application. It contains two child components Authorized and NotAuthorized, which serves for visualizing view in a corresponded views. In addition, the parameter Roles can be used to specified roles, based on which the authorized view is shown. The AuthorizeView contain base class named context, which is used to access identity of currently logged in user. The example of usage of AuthorizeView within a Blazor component is shown below: <AuthorizeView Roles=\"Administrator\"> <Authorized> <h4>You have role Administrator.</h4> <h4>Your name is: @context.User.Identity.Name</h4> </Authorized> <NotAuthorized> <h4>You dont have role Administrator.</h4> </NotAuthorized> </AuthorizeView> If the user is authenticated and is also authorized with the Administrator role, the authorized view is shown. Otherwise, non-authorized view is displayed. Also, there is a possibility to call method from RoleGroupManager called GetRoles, which takes as parameter name of the group and returns corresponded roles. RoleGroupManager is accessible from IRepositoryService. @inject IRepositoryService rs <AuthorizeView Roles=\"@rs.RoleGroupManager.GetRoles(\"AdminGroup\")\"> Use of AuthenticationStateProvider The AuthenticationStateProvider serves for accessing current logged in user and his claims. This provider can be injected to any C# class (either from constructor injection (in ViewModel) or with Inject attribute in Blazor component), where user need to work with authentication context. The authentication context of current user can be accessed in following way: @page \"/mypage\" @inject AuthenticationStateProvider _asp @code { protected override async Task OnInitializedAsync() { var context = await _asp.GetAuthenticationStateAsync(); var isAuth = context.User.Identity.IsAuthenticated; if (isAuth) { Console.Writeline(\"I'm authenticated\"); } } }"
  },
  "articles/themes/README.html": {
    "href": "articles/themes/README.html",
    "title": "AXOpen.Themes | System.Dynamic.ExpandoObject",
    "keywords": "AXOpen.Themes There is a way to change the look of the application by creating and using modified bootstrap files. 1. Modifying bootstrap Each theme is a separate bootstrap file. To get the desired color theme, bootstrap's variables need to be modified before compilation. Example of a file with modified variables: $primary: #0a6105 !default; $secondary: #13c70e !default; $success: #0e9e0a !default; $info: #f7f06d !default; $warning: #ff8a00 !default; $danger: #d33e43 !default; $brand: #f7f06d; $light: #f0f1ee !default; $dark: #021301 !default; $theme-colors: () !default; $theme-colors: map-merge( ( \"primary\": $primary, \"secondary\": $secondary, \"success\": $success, \"info\": $info, \"warning\": $warning, \"danger\": $danger, \"error\": $danger, \"brand\": $brand, \"add\": $primary, \"new\": $info, \"edit\": $primary, \"delete\": $danger, \"nav\": $secondary, \"change\": $warning, \"save\": $success, \"light\": $light, \"dark\": $dark, ), $theme-colors ); Besides changing the colors, the following css rules need to be added pre compilation for optimal look: /* forms */ /* Reduce the default form-group bottom margin*/ .form-group { margin-bottom: 0.25rem; } .form-control:focus { border-color: $warning; box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba($warning, 0.6); outline: 0 !important; } .form-select:focus { border-color: $warning; box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba($warning, 0.6); outline: 0 !important; } .valid.modified:not([type=\"checkbox\"]) { outline: 1px solid #26b050; } .invalid { outline: 1px solid red; } .validation-message { color: red; } /* set new margins and padding for small alerts*/ div.alert-sm .alert { padding: 0.25rem 1.25rem; margin-bottom: 0rem; } .nav-tabs .nav-link.active { color: $warning; } .content { padding-top: 1.1rem; } /* navigation */ .nav-menu .nav-link.active { background-color: $primary; color: $light; } .nav-menu .nav-link:hover { background-color: rgba($primary, 0.7); color: $light; } @media (min-width: 641px) { .nav-menu { border-left: 1px solid $primary; } } 2. Compiling bootstrap Compile these files in the following order using the sass compiler: @import \"Bootstrap/scss/_functions.scss\"; @import \"Bootstrap/custom/_variables\"; // modified variables @import \"Bootstrap/scss/bootstrap\"; @import \"Bootstrap/scss/_utilities\"; @import \"Bootstrap/scss/bootstrap-utilities.scss\"; @import \"Bootstrap/custom/_overrides\"; // modified css rules 3. Using a theme The custom compiled bootstrap files are stored in the wwwroot\\css\\custom folder. Add your custom compiled bootstrap to this folder. In order to be able to switch to your newly created theme, you need to add the name of the theme to the supportedThemes array in the Index.razor file: private string[] supportedThemes = new[] { \"New Theme\", \"Bootstrap\", }; Upon selecting a new theme, redirection to the theme uri is triggered: NavigationManager.NavigateTo($\"/theme?theme={theme}\", true); Upon navigating to the theme uri, the ChangeTheme method of the ThemeController (an API controller) is called: public async Task<ActionResult> ChangeTheme([FromQuery] string theme) { Response.Cookies.Append(\"theme\", theme); return Redirect(\"/\"); } This method creates a cookie with the name theme and the value of the selected theme. The cookie is then used to determine which stylesheet to use. The cookie expires after the browser session ends. In the _Host.cshtml file, the css file of the selected theme is loaded based on the value of the theme cookie: @switch (Request.Cookies[\"theme\"]) { case \"New Theme\": <link rel=\"stylesheet\" href=\"~/css/custom/new_theme.css\" /> break; case \"Bootstrap\": <link rel=\"stylesheet\" href=\"~/css/custom/bootstrap_default_custom.css\" /> break; default: <link rel=\"stylesheet\" href=\"~/css/custom/bootstrap_default_custom.css\" /> break; } Make sure that the string name of your theme in supportedThemes array in Index.razor file matches with the correct case string in the switch statement in the _Host.cshtml file. In case of an unknown theme name from the theme cookie or when the app is opened for the first time (the cookie has not been created yet), the default bootstrap theme is loaded. Theme changes in action:"
  },
  "index.html": {
    "href": "index.html",
    "title": "Source repositories | System.Dynamic.ExpandoObject",
    "keywords": "AXOpen is an open-source application framework project developed by a group of automation engineers. It is based on SIMATIC AX platfrom and AX# technology Source repositories AX# AXOpen Note This project is under development. We periodically release versions that can be used for testing and in non-production environments. Disclaimer Important It is necessary to have a valid license for SIMATIC AX in order to use AX# and AXOpen! SIMATIC AX is currently in a limited sales release in selected European countries only. You will need to request access from the AX team which will check if your use case is suitable for the current state of the product. The first step to getting the approval is contacting your local SIEMENS sales representative or writing an email to simatic-ax@siemens.com."
  }
}